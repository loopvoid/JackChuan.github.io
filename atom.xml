<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chuan·Yen</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://loopvoid.github.io/"/>
  <updated>2019-12-05T05:46:18.629Z</updated>
  <id>https://loopvoid.github.io/</id>
  
  <author>
    <name>Chuan Yen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SSE/SSE2/AVX/AVX2 Notes</title>
    <link href="https://loopvoid.github.io/2019/12/04/AVX-AVX2-Notes/"/>
    <id>https://loopvoid.github.io/2019/12/04/AVX-AVX2-Notes/</id>
    <published>2019-12-04T10:30:57.000Z</published>
    <updated>2019-12-05T05:46:18.629Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AVX-AVX2-SSE-SSE2指令集"><a href="#AVX-AVX2-SSE-SSE2指令集" class="headerlink" title="AVX/AVX2/SSE/SSE2指令集"></a>AVX/AVX2/SSE/SSE2指令集</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><div class="table-container"><table><thead><tr><th>数据类型</th><th>描述</th></tr></thead><tbody><tr><td>__m128</td><td>包含4个float类型数字的向量</td></tr><tr><td>__m128d</td><td>包含2个double类型数字的向量</td></tr><tr><td>__m128i</td><td>包含若干整形数字的向量</td></tr><tr><td>__m256</td><td>包含8个float类型数字的向量</td></tr><tr><td>__m256d</td><td>包含4个float类型数字的向量</td></tr><tr><td>__m256i</td><td>包含若干整形数字的向量</td></tr></tbody></table></div><ul><li>每一种类型，2个下划线开头，接着一个m，然后是vector的长度</li><li>若向量类型是d结尾，则向量存的double类型的数字。若无后缀则为float类型的数字。</li><li>整型的向量可以包含各种类型的整型数，如char,short,unsigned long long。也即, __m256i可以包含32个char，16个short，8个int，4个long类型。这些整型数可以是有符号和无符号类型。</li></ul><h2 id="函数名约定"><a href="#函数名约定" class="headerlink" title="函数名约定"></a>函数名约定</h2><p><code>_mm&lt;bit_width&gt;_&lt;name&gt;_&lt;data_type&gt;</code></p><ul><li><p><code>&lt;bit_width&gt;</code>：向量长度，对于128位向量，参数为空，256位向量，参数为256</p></li><li><p><code>&lt;name&gt;</code>：内联函数的算数操作简述</p></li><li><p><code>&lt;data_type&gt;</code>：函数主参数的数据类型</p><ul><li><code>p/s</code>：分别为<code>packed</code>和<code>scalar</code>。packed指令是对整个向量暂存器的所有数据都进行计算。而scalar只计算向量暂存器的低位中的数据进行计算。</li><li><code>s/d</code>：s为float类型，d为double类型</li></ul><blockquote><p><strong>ps：</strong>包含float类型的向量<br><strong>pd：</strong>包含double类型的向量<br><strong>epi8/epi16/epi32/epi64：</strong>包含8位/16位/32位/64位的<strong>有符号整数</strong><br><strong>epu8/epu16/epu32/epu64：</strong>包含8位/16位/32位/64位的<strong>无符号整数</strong><br><strong>si128/si256：</strong>未指定的128位或者256位向量<br><strong>m128/m128i/m128d/m256/m256i/m256d：</strong>当输入向量类型与返回向量的类型不同时，标识输入向量类型</p></blockquote></li></ul><p>示例1：<code>_mm256_srlv_epi64</code>，即使不知道<code>srlv</code>的含义，<code>_mm256</code>前缀说明该函数返回一个<strong>256-bit</strong>向量，后缀<code>_epi64</code>表示参数包含多个<strong>64-bit</strong>整型数。</p><p>示例2：<code>_mm_testnzc_ps</code>，其中<code>_mm</code>意味着该函数返回一个<strong>128-bit</strong>向量，后缀<code>ps</code>表示该参数包含float类型。</p><h2 id="写一个AVX程序"><a href="#写一个AVX程序" class="headerlink" title="写一个AVX程序"></a>写一个AVX程序</h2><p>首先需要包含<code>immintrin.h</code>头文件。</p><p>hello_avx.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;immintrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;isotream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// Initialize the two argument vectors</span></span><br><span class="line">    __m256 evens = _mm256_set_ps(<span class="number">2.0</span>,<span class="number">4.0</span>,<span class="number">6.0</span>,<span class="number">8.0</span>,<span class="number">10.0</span>,<span class="number">12.0</span>,<span class="number">14.0</span>,<span class="number">16.0</span>);</span><br><span class="line">    __m256 odds = _mm256_set_ps(<span class="number">1.0</span>, <span class="number">3.0</span>, <span class="number">5.0</span>, <span class="number">7.0</span>, <span class="number">9.0</span>, <span class="number">11.0</span>, <span class="number">13.0</span>, <span class="number">15.0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Compute the difference between the two vectors</span></span><br><span class="line">    __m256 result = _mm256_sub_ps(evens, odds);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Show the elements of the result vector</span></span><br><span class="line">    <span class="keyword">float</span> *f = (<span class="keyword">float</span>*)&amp;result;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f[<span class="number">0</span>] &lt;&lt; f[<span class="number">0</span>] &lt;&lt; f[<span class="number">0</span>] &lt;&lt; f[<span class="number">0</span>] &lt;&lt; f[<span class="number">0</span>] &lt;&lt; f[<span class="number">0</span>] &lt;&lt; f[<span class="number">0</span>] &lt;&lt; f[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数初始化"><a href="#函数初始化" class="headerlink" title="函数初始化"></a>函数初始化</h2><h3 id="标量初始化函数"><a href="#标量初始化函数" class="headerlink" title="标量初始化函数"></a>标量初始化函数</h3><div class="table-container"><table><thead><tr><th>数据类型</th><th>描述</th></tr></thead><tbody><tr><td>_mm256_setzero_ps/pd</td><td>返回一个全0的float/double类型向量</td></tr><tr><td>_mm256_setzero_si256</td><td>返回一个全0的整型向量</td></tr><tr><td>_mm256_set1_ps/pd</td><td>用一个float类型数填充向量</td></tr><tr><td>_mm256_set1_epi8/epi16/epi32/epi64x</td><td>用整型数填充向量</td></tr><tr><td>_mm256_set_epi8/epi16/epi32/epi64x</td><td>用一个整形数初始化向量</td></tr><tr><td>_mm256_set_ps/pd</td><td>用8个float或4个double类型数字初始化向量</td></tr><tr><td>_mm256_set_m128/m128d/m128i</td><td>用2个128位的向量初始化一个256位向量</td></tr><tr><td>_mm256_setr_ps/pd</td><td>用8个float或者4个double的转置顺序初始化向量</td></tr><tr><td>_mm256_setr_epi8/epi16/epi32/epi64x</td><td>用若干个整形数的转置顺序初始化向量</td></tr></tbody></table></div><h4 id="setzero"><a href="#setzero" class="headerlink" title="setzero"></a>setzero</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;immintrin.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setzero</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//单精度</span></span><br><span class="line">__m256 float_vec = _mm256_setzero_ps();</span><br><span class="line"><span class="keyword">float</span> *flo = (<span class="keyword">float</span>*)&amp;float_vec;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"float:\t%f, %f, %f, %f, %f, %f, %f, %f\n"</span>, flo[<span class="number">0</span>], flo[<span class="number">1</span>], flo[<span class="number">2</span>], flo[<span class="number">3</span>], flo[<span class="number">4</span>], flo[<span class="number">5</span>], flo[<span class="number">6</span>], flo[<span class="number">7</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//双精度</span></span><br><span class="line">__m256d double_vec = _mm256_setzero_pd();</span><br><span class="line"><span class="keyword">double</span> *dou = (<span class="keyword">double</span>*)&amp;double_vec;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"double:\t%lf, %lf, %lf, %lf\n"</span>, dou[<span class="number">0</span>], dou[<span class="number">1</span>], dou[<span class="number">2</span>], dou[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//整型</span></span><br><span class="line">__m256i int_vec = _mm256_setzero_si256();</span><br><span class="line"><span class="keyword">int</span>* i = (<span class="keyword">int</span>*)&amp;int_vec;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"int:\t%d, %d, %d, %d, %d, %d, %d, %d\n"</span>, i[<span class="number">0</span>], i[<span class="number">1</span>], i[<span class="number">2</span>], i[<span class="number">3</span>], i[<span class="number">4</span>], i[<span class="number">5</span>], i[<span class="number">6</span>], i[<span class="number">7</span>]);</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">float:  0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000, 0.000000</span><br><span class="line">double: 0.000000, 0.000000, 0.000000, 0.000000</span><br><span class="line">int:    0, 0, 0, 0, 0, 0, 0, 0</span><br></pre></td></tr></table></figure><h4 id="set1"><a href="#set1" class="headerlink" title="set1"></a>set1</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;immintrin.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">set1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//单精度</span></span><br><span class="line">__m256 float_vec = _mm256_set1_ps(<span class="number">1.0</span>);</span><br><span class="line"><span class="keyword">float</span> *flo = (<span class="keyword">float</span>*)&amp;float_vec;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"float:\t\t%f, %f, %f, %f, %f, %f, %f, %f\n"</span>, flo[<span class="number">0</span>], flo[<span class="number">1</span>], flo[<span class="number">2</span>], flo[<span class="number">3</span>], flo[<span class="number">4</span>], flo[<span class="number">5</span>], flo[<span class="number">6</span>], flo[<span class="number">7</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//双精度</span></span><br><span class="line">__m256d double_vec = _mm256_set1_pd(<span class="number">2.0</span>);</span><br><span class="line"><span class="keyword">double</span> *dou = (<span class="keyword">double</span>*)&amp;double_vec;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"double:\t\t%lf, %lf, %lf, %lf\n"</span>, dou[<span class="number">0</span>], dou[<span class="number">1</span>], dou[<span class="number">2</span>], dou[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//8-bit整型</span></span><br><span class="line">__m256i char_vec = _mm256_set1_epi8(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">char</span>* c = (<span class="keyword">char</span>*)&amp;char_vec;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"char:\t\t%d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d\n"</span>, c[<span class="number">0</span>], c[<span class="number">1</span>], c[<span class="number">2</span>], c[<span class="number">3</span>], c[<span class="number">4</span>], c[<span class="number">5</span>], c[<span class="number">6</span>], c[<span class="number">7</span>], c[<span class="number">8</span>], c[<span class="number">9</span>], c[<span class="number">10</span>], c[<span class="number">11</span>], c[<span class="number">12</span>], c[<span class="number">13</span>], c[<span class="number">14</span>], c[<span class="number">15</span>], c[<span class="number">16</span>], c[<span class="number">17</span>], c[<span class="number">18</span>], c[<span class="number">19</span>], c[<span class="number">20</span>], c[<span class="number">21</span>], c[<span class="number">22</span>], c[<span class="number">23</span>], c[<span class="number">24</span>], c[<span class="number">25</span>], c[<span class="number">26</span>], c[<span class="number">27</span>], c[<span class="number">28</span>], c[<span class="number">29</span>], c[<span class="number">30</span>], c[<span class="number">31</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//16-bit整型</span></span><br><span class="line">__m256i short_vec = _mm256_set1_epi16(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">short</span> *sho = (<span class="keyword">short</span>*)&amp;short_vec;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"short:\t\t%d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d\n"</span>, sho[<span class="number">0</span>], sho[<span class="number">1</span>], sho[<span class="number">2</span>], sho[<span class="number">3</span>], sho[<span class="number">4</span>], sho[<span class="number">5</span>], sho[<span class="number">6</span>], sho[<span class="number">7</span>], sho[<span class="number">8</span>], sho[<span class="number">9</span>], sho[<span class="number">10</span>], sho[<span class="number">11</span>], sho[<span class="number">12</span>], sho[<span class="number">13</span>], sho[<span class="number">14</span>], sho[<span class="number">15</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//32-bit整型</span></span><br><span class="line">__m256i int_vec = _mm256_set1_epi32(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">int</span> *i = (<span class="keyword">int</span>*)&amp;int_vec;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"int:\t\t%d, %d, %d, %d, %d, %d, %d, %d\n"</span>, i[<span class="number">0</span>], i[<span class="number">1</span>], i[<span class="number">2</span>], i[<span class="number">3</span>], i[<span class="number">4</span>], i[<span class="number">5</span>], i[<span class="number">6</span>], i[<span class="number">7</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//64-bit整数</span></span><br><span class="line">__m256i long_vec = _mm256_set1_epi64x(<span class="number">6</span>);</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> *lo = (<span class="keyword">long</span> <span class="keyword">long</span>*)&amp;long_vec;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"long long:\t%lld, %lld, %lld, %lld\n"</span>, lo[<span class="number">0</span>], lo[<span class="number">1</span>], lo[<span class="number">2</span>], lo[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">float:          1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000, 1.000000</span><br><span class="line">double:         2.000000, 2.000000, 2.000000, 2.000000</span><br><span class="line">char:           3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3</span><br><span class="line">short:          4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4</span><br><span class="line">int:            5, 5, 5, 5, 5, 5, 5, 5</span><br><span class="line">long long:      6, 6, 6, 6</span><br></pre></td></tr></table></figure><h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;immintrin.h&gt;//AVX/AVX2</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;xmmintrin.h&gt;//SSE</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;emmintrin.h&gt;//SSE2</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//单精度</span></span><br><span class="line">__m256 float_vec = _mm256_set_ps(<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>, <span class="number">5.0</span>, <span class="number">6.0</span>, <span class="number">7.0</span>, <span class="number">8.0</span>);</span><br><span class="line"><span class="keyword">float</span> *flo = (<span class="keyword">float</span> *)&amp;float_vec;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"float:\t\t%f, %f, %f, %f, %f, %f, %f, %f\n"</span>, flo[<span class="number">0</span>], flo[<span class="number">1</span>], flo[<span class="number">2</span>], flo[<span class="number">3</span>], flo[<span class="number">4</span>], flo[<span class="number">5</span>], flo[<span class="number">6</span>], flo[<span class="number">7</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//双精度</span></span><br><span class="line">__m256d double_vec = _mm256_set_pd(<span class="number">9.0</span>, <span class="number">10.0</span>, <span class="number">11.0</span>, <span class="number">12.0</span>);</span><br><span class="line"><span class="keyword">double</span> *dou = (<span class="keyword">double</span>*)&amp;double_vec;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"double:\t\t%lf, %lf, %lf, %lf\n"</span>, dou[<span class="number">0</span>], dou[<span class="number">1</span>], dou[<span class="number">2</span>], dou[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//8-bit整型</span></span><br><span class="line">__m256i char_vec = _mm256_set_epi8(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>);</span><br><span class="line"><span class="keyword">char</span> *c = (<span class="keyword">char</span>*)&amp;char_vec;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"char:\t\t%d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d\n"</span>, c[<span class="number">0</span>], c[<span class="number">1</span>], c[<span class="number">2</span>], c[<span class="number">3</span>], c[<span class="number">4</span>], c[<span class="number">5</span>], c[<span class="number">6</span>], c[<span class="number">7</span>], c[<span class="number">8</span>], c[<span class="number">9</span>], c[<span class="number">10</span>], c[<span class="number">11</span>], c[<span class="number">12</span>], c[<span class="number">13</span>], c[<span class="number">14</span>], c[<span class="number">15</span>], c[<span class="number">16</span>], c[<span class="number">17</span>], c[<span class="number">18</span>], c[<span class="number">19</span>], c[<span class="number">20</span>], c[<span class="number">21</span>], c[<span class="number">22</span>], c[<span class="number">23</span>], c[<span class="number">24</span>], c[<span class="number">25</span>], c[<span class="number">26</span>], c[<span class="number">27</span>], c[<span class="number">28</span>], c[<span class="number">29</span>], c[<span class="number">30</span>], c[<span class="number">31</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//16-bit整型</span></span><br><span class="line">__m256i short_vec = _mm256_set_epi16(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>);</span><br><span class="line"><span class="keyword">short</span> *sho = (<span class="keyword">short</span> *)&amp;short_vec;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"short:\t\t%d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d\n"</span>, sho[<span class="number">0</span>], sho[<span class="number">1</span>], sho[<span class="number">2</span>], sho[<span class="number">3</span>], sho[<span class="number">4</span>], sho[<span class="number">5</span>], sho[<span class="number">6</span>], sho[<span class="number">7</span>], sho[<span class="number">8</span>], sho[<span class="number">9</span>], sho[<span class="number">10</span>], sho[<span class="number">11</span>], sho[<span class="number">12</span>], sho[<span class="number">13</span>], sho[<span class="number">14</span>], sho[<span class="number">15</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//32-bit整型</span></span><br><span class="line">__m256i int_vec = _mm256_set_epi32(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>);</span><br><span class="line"><span class="keyword">int</span> *i = (<span class="keyword">int</span>*)&amp;int_vec;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"int:\t\t%d, %d, %d, %d, %d, %d, %d, %d\n"</span>, i[<span class="number">0</span>], i[<span class="number">1</span>], i[<span class="number">2</span>], i[<span class="number">3</span>], i[<span class="number">4</span>], i[<span class="number">5</span>], i[<span class="number">6</span>], i[<span class="number">7</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//64-bit整型</span></span><br><span class="line">__m256i long_vec = _mm256_set_epi64x(<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>);</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> *lo = (<span class="keyword">long</span> <span class="keyword">long</span>*)&amp;long_vec;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"long long:\t%lld, %lld, %lld, %lld\n"</span>, lo[<span class="number">0</span>], lo[<span class="number">1</span>], lo[<span class="number">2</span>], lo[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//从128-bit单精度向量初始化值</span></span><br><span class="line">__m128 float_vec_128_0 = _mm_set_ps(<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>);</span><br><span class="line">__m128 float_vec_128_1 = _mm_set_ps(<span class="number">5.0</span>, <span class="number">6.0</span>, <span class="number">7.0</span>, <span class="number">8.0</span>);</span><br><span class="line">__m256 float_vec_256 = _mm256_set_m128(float_vec_128_1, float_vec_128_0);</span><br><span class="line"><span class="keyword">float</span> *flo_256 = (<span class="keyword">float</span>*)&amp;float_vec_256;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"float:\t\t%f, %f, %f, %f, %f, %f, %f, %f\n"</span>, flo_256[<span class="number">0</span>], flo_256[<span class="number">1</span>], flo_256[<span class="number">2</span>], flo_256[<span class="number">3</span>], flo_256[<span class="number">4</span>], flo_256[<span class="number">5</span>], flo_256[<span class="number">6</span>], flo_256[<span class="number">7</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//从128-bit双精度向量初始化值</span></span><br><span class="line">__m128d double_vec_128_0 = _mm_set_pd(<span class="number">9.0</span>, <span class="number">10.0</span>);</span><br><span class="line">__m128d double_vec_128_1 = _mm_set_pd(<span class="number">11.0</span>, <span class="number">12.0</span>);</span><br><span class="line">__m256d double_vec_256 = _mm256_set_m128d(double_vec_128_1, double_vec_128_0);</span><br><span class="line"><span class="keyword">double</span> *dou_256 = (<span class="keyword">double</span>*)&amp;double_vec_256;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"double:\t\t%lf, %lf, %lf, %lf\n"</span>, dou_256[<span class="number">0</span>], dou_256[<span class="number">1</span>], dou_256[<span class="number">2</span>], dou_256[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//从128-bit整型向量初始化值</span></span><br><span class="line">__m128i int_vec_128_0 = _mm_set_epi32(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">__m128i int_vec_128_1 = _mm_set_epi32(<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>);</span><br><span class="line">__m256i int_vec_256 = _mm256_set_m128i(int_vec_128_1, int_vec_128_0);</span><br><span class="line"><span class="keyword">int</span> *i_256 = (<span class="keyword">int</span>*)&amp;int_vec_256;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"int:\t\t%d, %d, %d, %d, %d, %d, %d, %d\n"</span>, i_256[<span class="number">0</span>], i_256[<span class="number">1</span>], i_256[<span class="number">2</span>], i_256[<span class="number">3</span>], i_256[<span class="number">4</span>], i_256[<span class="number">5</span>], i_256[<span class="number">6</span>], i_256[<span class="number">7</span>]);</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">float:          8.000000, 7.000000, 6.000000, 5.000000, 4.000000, 3.000000, 2.000000, 1.000000</span><br><span class="line">double:         12.000000, 11.000000, 10.000000, 9.000000</span><br><span class="line">char:           32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1</span><br><span class="line">short:          16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1</span><br><span class="line">int:            8, 7, 6, 5, 4, 3, 2, 1</span><br><span class="line">long long:      12, 11, 10, 9</span><br><span class="line">float:          4.000000, 3.000000, 2.000000, 1.000000, 8.000000, 7.000000, 6.000000, 5.000000</span><br><span class="line">double:         10.000000, 9.000000, 12.000000, 11.000000</span><br><span class="line">int:            4, 3, 2, 1, 8, 7, 6, 5</span><br></pre></td></tr></table></figure><h4 id="setr"><a href="#setr" class="headerlink" title="setr"></a>setr</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;immintrin.h&gt;//AVX/AVX2</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;xmmintrin.h&gt;//SSE</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;emmintrin.h&gt;//SSE2</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//单精度  </span></span><br><span class="line">__m256 float_vec = _mm256_setr_ps(<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>, <span class="number">5.0</span>, <span class="number">6.0</span>, <span class="number">7.0</span>, <span class="number">8.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span>* flo = (<span class="keyword">float</span>*)&amp;float_vec;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"float:\t\t%f, %f, %f, %f, %f, %f, %f, %f\n"</span>, flo[<span class="number">0</span>], flo[<span class="number">1</span>], flo[<span class="number">2</span>], flo[<span class="number">3</span>], flo[<span class="number">4</span>], flo[<span class="number">5</span>], flo[<span class="number">6</span>], flo[<span class="number">7</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//双精度</span></span><br><span class="line">__m256d double_vec = _mm256_setr_pd(<span class="number">9.0</span>, <span class="number">10.0</span>, <span class="number">11.0</span>, <span class="number">12.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span>* dou = (<span class="keyword">double</span>*)&amp;double_vec;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"double:\t\t%lf, %lf, %lf, %lf\n"</span>, dou[<span class="number">0</span>], dou[<span class="number">1</span>], dou[<span class="number">2</span>], dou[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//32-bit整型</span></span><br><span class="line">__m256i int_vec = _mm256_setr_epi32(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>* i = (<span class="keyword">int</span>*)&amp;int_vec;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"int:\t\t%d, %d, %d, %d, %d, %d, %d, %d\n"</span>, i[<span class="number">0</span>], i[<span class="number">1</span>], i[<span class="number">2</span>], i[<span class="number">3</span>], i[<span class="number">4</span>], i[<span class="number">5</span>], i[<span class="number">6</span>], i[<span class="number">7</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//64-bit整型</span></span><br><span class="line">__m256i long_vec = _mm256_setr_epi64x(<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span>* lo = (<span class="keyword">long</span> <span class="keyword">long</span>*)&amp;long_vec;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"long long:\t%d, %d, %d, %d\n"</span>, lo[<span class="number">0</span>], lo[<span class="number">1</span>], lo[<span class="number">2</span>], lo[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//16-bit整型</span></span><br><span class="line">__m256i short_vec = _mm256_setr_epi16(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">short</span>* sho = (<span class="keyword">short</span>*)&amp;short_vec;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"short:\t\t%d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d\n"</span>, sho[<span class="number">0</span>], sho[<span class="number">1</span>], sho[<span class="number">2</span>], sho[<span class="number">3</span>], sho[<span class="number">4</span>], sho[<span class="number">5</span>], sho[<span class="number">6</span>], sho[<span class="number">7</span>], sho[<span class="number">8</span>], sho[<span class="number">9</span>], sho[<span class="number">10</span>], sho[<span class="number">11</span>], sho[<span class="number">12</span>], sho[<span class="number">13</span>], sho[<span class="number">14</span>], sho[<span class="number">15</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//8-bit整型</span></span><br><span class="line">__m256i char_vec = _mm256_setr_epi8(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* c = (<span class="keyword">char</span>*)&amp;char_vec;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"char:\t\t%d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d\n"</span>, c[<span class="number">0</span>], c[<span class="number">1</span>], c[<span class="number">2</span>], c[<span class="number">3</span>], c[<span class="number">4</span>], c[<span class="number">5</span>], c[<span class="number">6</span>], c[<span class="number">7</span>], c[<span class="number">8</span>], c[<span class="number">9</span>], c[<span class="number">10</span>], c[<span class="number">11</span>], c[<span class="number">12</span>], c[<span class="number">13</span>], c[<span class="number">14</span>], c[<span class="number">15</span>], c[<span class="number">16</span>], c[<span class="number">17</span>], c[<span class="number">18</span>], c[<span class="number">19</span>], c[<span class="number">20</span>], c[<span class="number">21</span>], c[<span class="number">22</span>], c[<span class="number">23</span>], c[<span class="number">24</span>], c[<span class="number">25</span>], c[<span class="number">26</span>], c[<span class="number">27</span>], c[<span class="number">28</span>], c[<span class="number">29</span>], c[<span class="number">30</span>], c[<span class="number">31</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set value from 128-bit single-precision vectors</span></span><br><span class="line">__m128 float_vec_128_0 = _mm_setr_ps(<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>);</span><br><span class="line">__m128 float_vec_128_1 = _mm_setr_ps(<span class="number">5.0</span>, <span class="number">6.0</span>, <span class="number">7.0</span>, <span class="number">8.0</span>);</span><br><span class="line"></span><br><span class="line">__m256 float_vec_256 = _mm256_setr_m128(float_vec_128_1, float_vec_128_0);</span><br><span class="line"><span class="keyword">float</span>* flo_256 = (<span class="keyword">float</span>*)&amp;float_vec_256;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"float:\t\t%f, %f, %f, %f, %f, %f, %f, %f\n"</span>, flo_256[<span class="number">0</span>], flo_256[<span class="number">1</span>], flo_256[<span class="number">2</span>], flo_256[<span class="number">3</span>], flo_256[<span class="number">4</span>], flo_256[<span class="number">5</span>], flo_256[<span class="number">6</span>], flo_256[<span class="number">7</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set value from 128-bit double-precision vectors</span></span><br><span class="line">__m128d double_vec_128_0 = _mm_setr_pd(<span class="number">9.0</span>, <span class="number">10.0</span>);</span><br><span class="line">__m128d double_vec_128_1 = _mm_setr_pd(<span class="number">11.0</span>, <span class="number">12.0</span>);</span><br><span class="line"></span><br><span class="line">__m256d double_vec_256 = _mm256_setr_m128d(double_vec_128_1, double_vec_128_0);</span><br><span class="line"><span class="keyword">double</span>* dou_256 = (<span class="keyword">double</span>*)&amp;double_vec_256;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"double:\t\t%lf, %lf, %lf, %lf\n"</span>, dou_256[<span class="number">0</span>], dou_256[<span class="number">1</span>], dou_256[<span class="number">2</span>], dou_256[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set value from 128-bit integer vectors</span></span><br><span class="line">__m128i int_vec_128_0 = _mm_setr_epi32(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">__m128i int_vec_128_1 = _mm_setr_epi32(<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">__m256i int_vec_256 = _mm256_setr_m128i(int_vec_128_1, int_vec_128_0);</span><br><span class="line"><span class="keyword">int</span>* i_256 = (<span class="keyword">int</span>*)&amp;int_vec_256;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"int:\t\t%d, %d, %d, %d, %d, %d, %d, %d\n"</span>, i_256[<span class="number">0</span>], i_256[<span class="number">1</span>], i_256[<span class="number">2</span>], i_256[<span class="number">3</span>], i_256[<span class="number">4</span>], i_256[<span class="number">5</span>], i_256[<span class="number">6</span>], i_256[<span class="number">7</span>]);</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">float:          1.000000, 2.000000, 3.000000, 4.000000, 5.000000, 6.000000, 7.000000, 8.000000</span><br><span class="line">double:         9.000000, 10.000000, 11.000000, 12.000000</span><br><span class="line">int:            1, 2, 3, 4, 5, 6, 7, 8</span><br><span class="line">long long:      9, 10, 11, 12</span><br><span class="line">short:          1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16</span><br><span class="line">char:           1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32</span><br><span class="line">float:          5.000000, 6.000000, 7.000000, 8.000000, 1.000000, 2.000000, 3.000000, 4.000000</span><br><span class="line">double:         11.000000, 12.000000, 9.000000, 10.000000</span><br><span class="line">int:            5, 6, 7, 8, 1, 2, 3, 4</span><br></pre></td></tr></table></figure><h3 id="从内存中加载数据"><a href="#从内存中加载数据" class="headerlink" title="从内存中加载数据"></a>从内存中加载数据</h3><div class="table-container"><table><thead><tr><th>数据类型</th><th>描述</th></tr></thead><tbody><tr><td>_mm256_load_ps/pd</td><td>从对齐的内存地址加载float/double向量</td></tr><tr><td>_mm256_load_si256</td><td>从对齐的内存地址加载整形向量</td></tr><tr><td>_mm256_loadu_ps/pd</td><td>从未对齐的内存地址加载浮点向量</td></tr><tr><td>_mm256_loadu_si256</td><td>从未对齐的内存地址加载整形向量</td></tr><tr><td>_mm_maskload_ps/pd</td><td>根据掩码加载128位浮点向量的部分</td></tr><tr><td>_mm256_maskload_ps/pd</td><td>根据掩码加载256位浮点向量的部分</td></tr><tr><td>_mm_maskload_epi32/64（只在avx2中支持）</td><td>根据掩码加载128位整形向量的部分</td></tr><tr><td>_mm256_maskload_epi32/64（只在avx2中支持）</td><td>根据掩码加载256位整形向量的部分</td></tr></tbody></table></div><p>调用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> *aligned_floats = (<span class="keyword">float</span>*)aligned_alloc(<span class="number">32</span>, <span class="number">64</span>*<span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line"><span class="comment">// Initialize data</span></span><br><span class="line">__m256 vec = _mm256_load_ps(aligned_floats);</span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> *unaligned_floats = (<span class="keyword">float</span>*)<span class="built_in">malloc</span>(<span class="number">64</span>*<span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line"><span class="comment">// Initialize data</span></span><br><span class="line">__m256 vec = _mm256_loadu_ps(unaligned_floats);</span><br></pre></td></tr></table></figure><p>若要处理的float数组长度为11不能被8整除。那么最后5个浮点数需要置0。或者使用上表中的<code>_maskload_</code>。</p><p><code>_maskload_</code>函数有两个参数：内存地址、相同元素数目的整型向量作为返回。整型向量中每个元素的最高位为1，返回的向量中对应元素是从内存中读取的。若整型向量中每个元素最高位为0，则返回的向量对应元素置0。</p><p>mask_load.cpp</p><p>读入8个int到向量，最后3个应该置0。使用了<code>_mm256_maskload_epi32</code>，第二个参数应为<code>__m256i</code>mask向量。该mask向量包含5个整型，其最高位是1，剩下3个整型的最高位置0.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;immintrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostram&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> int_array[<span class="number">8</span>] = &#123;<span class="number">100</span>,<span class="number">200</span>,<span class="number">300</span>,<span class="number">400</span>,<span class="number">500</span>,<span class="number">600</span>,<span class="number">700</span>,<span class="number">800</span>&#125;;</span><br><span class="line">    <span class="comment">// Initialize the mask vector</span></span><br><span class="line">    __m256i mask = _mm256_setr_epi32(<span class="number">-20</span>, <span class="number">-70</span>, <span class="number">-48</span>, <span class="number">-9</span>, <span class="number">-100</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>);</span><br><span class="line">    <span class="comment">// or</span></span><br><span class="line">    __m256i mask_1 = _mm256_set_epi32(<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">-100</span>,<span class="number">-9</span>,<span class="number">-48</span>,<span class="number">-70</span>,<span class="number">-20</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Selectively load data to the vector</span></span><br><span class="line">    __m256i result = _mm256_maskload_epi32(int_array, mask);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Selectively load data into reuslt vector</span></span><br><span class="line">    <span class="keyword">int</span> *res = (<span class="keyword">int</span>*)&amp;result;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d %d %d %d %d %d %d\n"</span>, </span><br><span class="line">    res[<span class="number">0</span>], res[<span class="number">1</span>], res[<span class="number">2</span>], res[<span class="number">3</span>], res[<span class="number">4</span>], res[<span class="number">5</span>], res[<span class="number">6</span>], res[<span class="number">7</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">100 200 300 400 500 0 0 0</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>负整型的最高位总为1。所以mask vector选用5个负数，3个正数</li><li><code>_mm256_maskload_epi32</code>是AVX2函数，因此用gcc编译加<code>-mavx2</code>参数</li></ul><h2 id="算术本质"><a href="#算术本质" class="headerlink" title="算术本质"></a>算术本质</h2><h3 id="加减法"><a href="#加减法" class="headerlink" title="加减法"></a>加减法</h3><div class="table-container"><table><thead><tr><th>数据类型</th><th>描述</th></tr></thead><tbody><tr><td>_mm256_add_ps/pd</td><td>对两个浮点向量做加法</td></tr><tr><td>_mm256_sub_ps/pd</td><td>对两个浮点向量做减法</td></tr><tr><td>(2)_mm256_add_epi8/16/32/64</td><td>对两个整形向量做加法</td></tr><tr><td>(2)_mm256_sub_epi8/16/32/64</td><td>对两个整形向量做减法</td></tr><tr><td>(2)_mm256_adds_epi8/16 (2)_mm256_adds_epu8/16</td><td>两个整数向量相加且考虑内存饱和问题</td></tr><tr><td>(2)_mm256_subs_epi8/16 (2)_mm256_subs_epu8/16</td><td>两个整数向量相减且考虑内存饱和问题</td></tr><tr><td>_mm256_hadd_ps/pd</td><td>水平方向上对两个float类型向量做加法</td></tr><tr><td>_mm256_hsub_ps/pd</td><td>垂直方向上最两个float类型向量做减法</td></tr><tr><td>(2)_mm256_hadd_epi16/32</td><td>水平方向上对两个整形向量做加法</td></tr><tr><td>(2)_mm256_hsub_epi16/32</td><td>水平方向上最两个整形向量做减法</td></tr><tr><td>(2)_mm256_hadds_epi16</td><td>对两个包含short类型的向量做加法且考虑内存饱和的问题</td></tr><tr><td>(2)_mm256_hsubs_epi16</td><td>对两个包含short类型的向量做减法且考虑内存饱和的问题</td></tr><tr><td>_mm256_addsub_ps/pd</td><td>加上和减去两个float类型的向量、(在偶数位置减去，奇数位置加上，获最后得目标向量。)</td></tr></tbody></table></div><p>前面有一个(2)，代表函数只在AVX2中支持。</p><p><code>_add_/_sub_</code>函数和<code>_adds_/_subs_</code>函数的区别在于。<code>s</code>表示饱和，即当结果需要更多的内存来保存结果也能存下。</p><p><strong>例1：</strong>一个向量包含signed bytes，因此每个元素最大值是127(0x7F).若有98加85的操作，结果是183(0xB7).</p><ul><li>若用<code>_mm256_add_epi8</code>，溢出部分会被忽略存储结果为<strong>-73(0xB7)</strong></li><li>若用<code>_mm256_adds_epi8</code>，结果会被限制在最大值即<strong>127(0x7F)</strong></li></ul><p><strong>例2：</strong>两个signed short整型向量，最小值为-32768。若计算-18000-19000，结果为-37000(0xFFFF6F78 as a 32-bit integer)</p><ul><li>若用<code>_mm256_sub_epi16</code>，溢出会被忽略存储结果为 <strong>28536(0x6F78)</strong></li><li>若用<code>_mm256_subs_epi16</code>，结果会被限制在最小值<strong>-32768(0x8000)</strong></li></ul><p><code>_hadd_/_hsub_</code>函数为水平加减。即向量相邻元素做加减，而不是向量间做加减。</p><p>而在水平方向上做加减法的意思如下图：</p><p><img src="https://www.codeproject.com/KB/cpp/874396/Fig1.jpg" alt></p><h3 id="乘除法"><a href="#乘除法" class="headerlink" title="乘除法"></a>乘除法</h3><div class="table-container"><table><thead><tr><th>数据类型</th><th>描述</th></tr></thead><tbody><tr><td>_mm256_mul_ps/pd</td><td>对两个float类型的向量进行相乘</td></tr><tr><td>(2)_mm256_mul_epi32 (2)_mm256_mul_epu32</td><td>将包含32位整数的向量的最低四个元素相乘</td></tr><tr><td>(2)_mm256_mullo_epi16/32</td><td>Multiply integers and store low halves</td></tr><tr><td>(2)_mm256_mulhi_epi16 (2)_mm256_mulhi_epu16</td><td>Multiply integers and store high halves</td></tr><tr><td>(2)_mm256_mulhrs_epi16</td><td>Multiply 16-bit elements to form 32-bit elements</td></tr><tr><td>_mm256_div_ps/pd</td><td>对两个float类型的向量进行想除</td></tr></tbody></table></div><p><img src="https://img-blog.csdnimg.cn/20190701164948547.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p1c3Rfc29ydA==,size_16,color_FFFFFF,t_70" alt></p><p><img src="https://img-blog.csdnimg.cn/2019070116512981.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p1c3Rfc29ydA==,size_16,color_FFFFFF,t_70" alt></p><h3 id="复合运算"><a href="#复合运算" class="headerlink" title="复合运算"></a>复合运算</h3><div class="table-container"><table><thead><tr><th>数据类型</th><th>描述</th></tr></thead><tbody><tr><td>(2)_mm_fmadd_ps/pd/ (2)_mm256_fmadd_ps/pd</td><td>将两个向量相乘，再将积加上第三个。(res=a*b+c)</td></tr><tr><td>(2)_mm_fmsub_ps/pd/ (2)_mm256_fmsub_ps/pd</td><td>将两个向量相乘，然后从乘积中减去一个向量。(res=a*b-c)</td></tr><tr><td>(2)_mm_fmadd_ss/sd</td><td>将向量中最低的元素相乘并相加（res[0]=a[0]*b[0]+c[0])</td></tr><tr><td>(2)_mm_fmsub_ss/sd</td><td>将向量中最低的元素相乘并相减（res[0]=a[0]*b[0]-c[0])</td></tr><tr><td>(2)_mm_fnmadd_ps/pd (2)_mm256_fnmadd_ps/pd</td><td>将两个向量相乘，并将负积加到第三个。(res = -(a * b) + c)</td></tr><tr><td>(2)_mm_fnmsub_ps/pd/ (2)_mm256_fnmsub_ps/pd</td><td>将两个向量相乘，并将负积加到第三个 (res = -(a * b) - c)</td></tr><tr><td>(2)_mm_fnmadd_ss/sd</td><td>将两个向量的低位相乘，并将负积加到第三个向量的低位。(res[0] = -(a[0] * b[0]) + c[0])</td></tr><tr><td>(2)_mm_fnmsub_ss/sd</td><td>将最低的元素相乘，并从求反的积中减去第三个向量的最低元素。(res[0] = -(a[0] * b[0]) - c[0])</td></tr><tr><td>(2)_mm_fmaddsub_ps/pd/ (2)_mm256_fmaddsub_ps/pd</td><td>将两个矢量相乘，然后从乘积中交替加上和减去（res=a*b+/-c)</td></tr><tr><td>(2)_mm_fmsubadd_ps/pd/ (2)_mmf256_fmsubadd_ps/pd</td><td>将两个向量相乘，然后从乘积中交替地进行减法和加法（res=a*b-/+c）（奇数次方，偶数次方）</td></tr></tbody></table></div><h2 id="unpack、permute、shuffle、blend"><a href="#unpack、permute、shuffle、blend" class="headerlink" title="unpack、permute、shuffle、blend"></a>unpack、permute、shuffle、blend</h2><h3 id="unpack"><a href="#unpack" class="headerlink" title="unpack"></a>unpack</h3><p><img src="https://www.officedaytime.com/tips/simdimg/unpack.png" style="zoom:150%;"></p><h3 id="permute"><a href="#permute" class="headerlink" title="permute"></a>permute</h3><div class="table-container"><table><thead><tr><th>数据类型</th><th>描述</th></tr></thead><tbody><tr><td>_mm_permute_ps/pd _mm256_permute_ps/pd</td><td>根据8位控制值从输入向量中选择元素</td></tr><tr><td>(2)_mm256_permute4x64_pd/ (2)_mm256_permute4x64_epi64</td><td>根据8位控制值从输入向量中选择64位元素</td></tr><tr><td>_mm256_permute2f128_ps/pd</td><td>基于8位控制值从两个输入向量中选择128位块</td></tr><tr><td>_mm256_permute2f128_si256</td><td>基于8位控制值从两个输入向量中选择128位块</td></tr><tr><td>_mm_permutevar_ps/pd _mm256_permutevar_ps/pd</td><td>根据整数向量中的位从输入向量中选择元素</td></tr><tr><td>(2)_mm256_permutevar8x32_ps (2)_mm256_permutevar8x32_epi32</td><td>使用整数向量中的索引选择32位元素（浮点和整数）</td></tr></tbody></table></div><p><img src="https://www.officedaytime.com/tips/simdimg/shuffle.png" style="zoom:150%;"></p><p><img src="https://img-blog.csdnimg.cn/20190701173134557.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p1c3Rfc29ydA==,size_16,color_FFFFFF,t_70" alt></p><h3 id="shuffle"><a href="#shuffle" class="headerlink" title="shuffle"></a>shuffle</h3><div class="table-container"><table><thead><tr><th>数据类型</th><th>描述</th></tr></thead><tbody><tr><td>_mm256_shuffle_ps/pd</td><td>根据8位值选择浮点元素</td></tr><tr><td>_mm256_shuffle_epi8/ _mm256_shuffle_epi32</td><td>根据8位值选择整数元素</td></tr><tr><td>(2)_mm256_shufflelo_epi16/ (2)_mm256_shufflehi_epi16</td><td>基于8位控制值从两个输入向量中选择128位块</td></tr></tbody></table></div><p>对于_mm256_shuffle_pd，只使用控制值的高4位。如果输入向量包含int或float，则使用所有控制位。对于_mm256_shuffle_ps，前两对位从第一个矢量中选择元素，第二对位从第二个矢量中选择元素。</p><p><img src="https://www.officedaytime.com/tips/simdimg/shuffle.png" style="zoom:150%;"></p><p><img src="https://img-blog.csdnimg.cn/20190701173738368.png" alt></p><h3 id="blend"><a href="#blend" class="headerlink" title="blend"></a>blend</h3><p><img src="https://www.officedaytime.com/tips/simdimg/blend.png" style="zoom:150%;"></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/" target="_blank" rel="noopener">https://software.intel.com/sites/landingpage/IntrinsicsGuide/</a></p><p><a href="https://software.intel.com/en-us/articles/introduction-to-intel-advanced-vector-extensions/" target="_blank" rel="noopener">https://software.intel.com/en-us/articles/introduction-to-intel-advanced-vector-extensions/</a></p><p><a href="https://www.codeproject.com/Articles/874396/Crunching-Numbers-with-AVX-and-AVX" target="_blank" rel="noopener">https://www.codeproject.com/Articles/874396/Crunching-Numbers-with-AVX-and-AVX</a></p><p><a href="https://blog.triplez.cn/avx-avx2-learning-notes/#Shuffling" target="_blank" rel="noopener">https://blog.triplez.cn/avx-avx2-learning-notes/#Shuffling</a></p><p><a href="https://github.com/Triple-Z/AVX-AVX2-Example-Code" target="_blank" rel="noopener">https://github.com/Triple-Z/AVX-AVX2-Example-Code</a></p><p><a href="https://blog.csdn.net/just_sort/article/details/94393506" target="_blank" rel="noopener">https://blog.csdn.net/just_sort/article/details/94393506</a></p><p><a href="https://www.jianshu.com/p/64ef4d304e17" target="_blank" rel="noopener">https://www.jianshu.com/p/64ef4d304e17</a></p><p><a href="https://www.officedaytime.com/tips/simd.html" target="_blank" rel="noopener">https://www.officedaytime.com/tips/simd.html</a></p><p><a href="https://github.com/microsoft/SPTAG/blob/master/AnnService/inc/Core/Common/DistanceUtils.h" target="_blank" rel="noopener">https://github.com/microsoft/SPTAG/blob/master/AnnService/inc/Core/Common/DistanceUtils.h</a></p><p>CPU指令集介绍<br><a href="https://blog.csdn.net/gengshenghong/article/details/7006817" target="_blank" rel="noopener">https://blog.csdn.net/gengshenghong/article/details/7006817</a></p><p>在C/C++代码中使用SSE等指令集的指令(1)介绍<br><a href="https://blog.csdn.net/gengshenghong/article/details/7007100" target="_blank" rel="noopener">https://blog.csdn.net/gengshenghong/article/details/7007100</a><br>在C/C++代码中使用SSE等指令集的指令(2)参考手册<br><a href="https://blog.csdn.net/gengshenghong/article/details/7008682" target="_blank" rel="noopener">https://blog.csdn.net/gengshenghong/article/details/7008682</a><br>在C/C++代码中使用SSE等指令集的指令(3)SSE指令集基础<br><a href="https://blog.csdn.net/gengshenghong/article/details/7008704" target="_blank" rel="noopener">https://blog.csdn.net/gengshenghong/article/details/7008704</a><br>在C/C++代码中使用SSE等指令集的指令(4)SSE指令集Intrinsic函数使用<br><a href="https://blog.csdn.net/gengshenghong/article/details/7010615" target="_blank" rel="noopener">https://blog.csdn.net/gengshenghong/article/details/7010615</a><br>在C/C++代码中使用SSE等指令集的指令(5)SSE进行加法运算简单的性能测试<br><a href="https://blog.csdn.net/gengshenghong/article/details/7011373" target="_blank" rel="noopener">https://blog.csdn.net/gengshenghong/article/details/7011373</a></p><p>Writing C++ Wrappers for SIMD Intrinsics (1-5)<br><a href="https://johanmabille.github.io/blog/2014/10/09/writing-c-plus-plus-wrappers-for-simd-intrinsics-1/" target="_blank" rel="noopener">https://johanmabille.github.io/blog/2014/10/09/writing-c-plus-plus-wrappers-for-simd-intrinsics-1/</a><br><a href="https://johanmabille.github.io/blog/2014/10/10/writing-c-plus-plus-wrappers-for-simd-intrinsics-2/" target="_blank" rel="noopener">https://johanmabille.github.io/blog/2014/10/10/writing-c-plus-plus-wrappers-for-simd-intrinsics-2/</a><br><a href="https://johanmabille.github.io/blog/2014/10/10/writing-c-plus-plus-wrappers-for-simd-intrinsics-3/" target="_blank" rel="noopener">https://johanmabille.github.io/blog/2014/10/10/writing-c-plus-plus-wrappers-for-simd-intrinsics-3/</a><br><a href="https://johanmabille.github.io/blog/2014/10/13/writing-c-plus-plus-wrappers-for-simd-intrinsics-4/" target="_blank" rel="noopener">https://johanmabille.github.io/blog/2014/10/13/writing-c-plus-plus-wrappers-for-simd-intrinsics-4/</a><br><a href="https://johanmabille.github.io/blog/2014/10/25/writing-c-plus-plus-wrappers-for-simd-intrinsics-5/" target="_blank" rel="noopener">https://johanmabille.github.io/blog/2014/10/25/writing-c-plus-plus-wrappers-for-simd-intrinsics-5/</a><br>Performance Considerations About SIMD Wrappers<br><a href="https://johanmabille.github.io/blog/2014/11/20/performance-considerations-about-simd-wrappers/" target="_blank" rel="noopener">https://johanmabille.github.io/blog/2014/11/20/performance-considerations-about-simd-wrappers/</a><br>Aligned Memory Allocator<br><a href="https://johanmabille.github.io/blog/2014/12/06/aligned-memory-allocator/" target="_blank" rel="noopener">https://johanmabille.github.io/blog/2014/12/06/aligned-memory-allocator/</a></p><p>Ubuntu SSE指令集 编程实例—-复数乘法与共轭乘法</p><p><a href="https://blog.csdn.net/jxwxg/article/details/53091376" target="_blank" rel="noopener">https://blog.csdn.net/jxwxg/article/details/53091376</a></p><p>AVX2整数向量运算</p><p><a href="https://blog.csdn.net/tigerisland45/article/details/54671536" target="_blank" rel="noopener">https://blog.csdn.net/tigerisland45/article/details/54671536</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;AVX-AVX2-SSE-SSE2指令集&quot;&gt;&lt;a href=&quot;#AVX-AVX2-SSE-SSE2指令集&quot; class=&quot;headerlink&quot; title=&quot;AVX/AVX2/SSE/SSE2指令集&quot;&gt;&lt;/a&gt;AVX/AVX2/SSE/SSE2指令集&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Delaunay三角剖分</title>
    <link href="https://loopvoid.github.io/2019/11/28/Delaunay%E4%B8%89%E8%A7%92%E5%89%96%E5%88%86/"/>
    <id>https://loopvoid.github.io/2019/11/28/Delaunay三角剖分/</id>
    <published>2019-11-28T04:04:41.000Z</published>
    <updated>2019-11-28T04:18:54.207Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Delaunay-Triangle"><a href="#Delaunay-Triangle" class="headerlink" title="Delaunay Triangle"></a>Delaunay Triangle</h1><p>Delaunay三角剖分特点：</p><blockquote><p><strong>最小角最大</strong>：在不出现奇异性的情况下,Delaunay三角剖分最小角之和均大于任何非 Delaunay剖分所形成三角形最小角之和 ,三角形的最小内角之和最大 ,从而使得划分的三角形不会出现某个内角过小的情况 ,比较有利于有限元的后续计算。<br><strong>空外接圆</strong>：Delaunay三角剖分中任意三角形的外接圆内不包括其他结点。因此 ,在各种二维三角剖分中 ,只有 Delaunay三角剖分才同时满足全局和局部最优。</p></blockquote><p>Delaunay三角剖分优点：</p><blockquote><p>1.<strong>最接近</strong>：以最近的三点组成三角形，且三角形各边皆不相交。<br>2.<strong>唯一性</strong>：不论从何处区域开始构建，最终结果唯一。<br>3.<strong>最优解</strong>：任意两个相邻三角形形成的凸四边形的对角线若可以互换,那么两个三角形六个内角中最小的角度不会变大。<br>4.<strong>最规则</strong>：若将三角网中的每个三角形的最小角进行升序排列，则Delaunay三角网的排列得到的数值最大。<br>5.<strong>区域性</strong>：新增、删除、移动某一个顶点时只会影响临近的三角形。<br>6.具有<strong>凸多边形的外壳</strong>：三角网最外层的边界形成一个凸多边形的外壳。</p></blockquote><h1 id="Voronoi图"><a href="#Voronoi图" class="headerlink" title="Voronoi图"></a>Voronoi图</h1><p>离散点集P的Delaunay三角剖分和离散点集P的Voronoi图为<a href="https://en.wikipedia.org/wiki/Dual_graph" target="_blank" rel="noopener">对偶图</a>的关系。</p><p>Delaunay三角形的外心是Voronoi图的顶点。 </p><blockquote><p>对偶图：设G是平面图，在图G的每个面中指定一个新节点，对两个面公共的边，指定一条新边与其<strong>相交</strong>。由这些新结点和新边组成的图为G的对偶图。</p></blockquote><p>图中的蓝色虚线的图是红色实线的对偶图：</p><p><img src="//loopvoid.github.io/2019/11/28/Delaunay三角剖分/1280px-Duals_graphs.svg.png" alt="1280px-Duals_graphs.svg.png" style="zoom: 25%;"></p><p>Delaunay三角形和其外接圆与圆心：</p><p><img src="//loopvoid.github.io/2019/11/28/Delaunay三角剖分/337px-Delaunay_circumcircles_centers.svg.png" alt="337px-Delaunay_circumcircles_centers.svg" style="zoom: 67%;"></p><p>连接外接圆圆心生成Voronoi图：</p><p><img src="//loopvoid.github.io/2019/11/28/Delaunay三角剖分/441px-Delaunay_Voronoi.svg.png" alt="441px-Delaunay_Voronoi.svg" style="zoom:50%;"></p><h1 id="Delaunay三角剖分算法"><a href="#Delaunay三角剖分算法" class="headerlink" title="Delaunay三角剖分算法"></a>Delaunay三角剖分算法</h1><p>Delaunay三角剖分常见算法：翻边算法、分割归并法、逐点插入算法、三角网增长法。本文从常见的逐点插入的Bowyer-Watson算法来理解。</p><p>在<a href="http://paulbourke.net/papers/triangulate/" target="_blank" rel="noopener">《Triangulate》</a>里对该方法进行了分析，给出了伪代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">subroutine triangulate</span><br><span class="line">input : vertex list</span><br><span class="line">output : triangle list</span><br><span class="line">   initialize the triangle list</span><br><span class="line">   determine the supertriangle</span><br><span class="line">   add supertriangle vertices to the end of the vertex list</span><br><span class="line">   add the supertriangle to the triangle list</span><br><span class="line">   for each sample point in the vertex list</span><br><span class="line">      initialize the edge buffer</span><br><span class="line">      for each triangle currently in the triangle list</span><br><span class="line">         calculate the triangle circumcircle center and radius</span><br><span class="line">         if the point lies in the triangle circumcircle then</span><br><span class="line">            add the three triangle edges to the edge buffer</span><br><span class="line">            remove the triangle from the triangle list</span><br><span class="line">         endif</span><br><span class="line">      endfor</span><br><span class="line">      delete all doubly specified edges from the edge buffer</span><br><span class="line">         this leaves the edges of the enclosing polygon only</span><br><span class="line">      add to the triangle list all triangles formed between the point </span><br><span class="line">         and the edges of the enclosing polygon</span><br><span class="line">   endfor</span><br><span class="line">   remove any triangles from the triangle list that use the supertriangle vertices</span><br><span class="line">   remove the supertriangle vertices from the vertex list</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>因该算法效率不高，因此有网上给的优化后的伪代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">input: 顶点列表(vertices)　　　　　　　　　　　　　　　　　　　　  　//vertices为外部生成的随机或乱序顶点列表</span><br><span class="line">output:已确定的三角形列表(triangles)</span><br><span class="line">　　　　初始化顶点列表</span><br><span class="line">　　　　创建索引列表(indices = new Array(vertices.length))　　　　//indices数组中的值为0,1,2,3,......,vertices.length-1</span><br><span class="line">　　　　基于vertices中的顶点x坐标对indices进行sort　　  　　　　　  //sort后的indices值顺序为顶点坐标x从小到大排序（也可对y坐标，本例中针对x坐标）</span><br><span class="line">　　　　确定超级三角形</span><br><span class="line">　　　　将超级三角形保存至未确定三角形列表（temp triangles）</span><br><span class="line">　　　　将超级三角形push到triangles列表</span><br><span class="line">　　　　遍历基于indices顺序的vertices中每一个点　　　　　　　　　  　//基于indices后，则顶点则是由x从小到大出现</span><br><span class="line">　　　　　　初始化边缓存数组（edge buffer）</span><br><span class="line">　　　　　　遍历temp triangles中的每一个三角形</span><br><span class="line">　　　　　　　　计算该三角形的圆心和半径</span><br><span class="line">　　　　　　　　如果该点在外接圆的右侧</span><br><span class="line">　　　　　　　　　　则该三角形为Delaunay三角形，保存到triangles</span><br><span class="line">　　　　　　　　　　并在temp里去除掉</span><br><span class="line">　　　　　　　　　　跳过</span><br><span class="line">　　　　　　　　如果该点在外接圆外（即也不是外接圆右侧）</span><br><span class="line">　　　　　　　　　　则该三角形为不确定        　　　　　　　　　     //后面会在问题中讨论</span><br><span class="line">　　　　　　　　　　跳过</span><br><span class="line">　　　　　　　　如果该点在外接圆内</span><br><span class="line">　　　　　　　　　　则该三角形不为Delaunay三角形</span><br><span class="line">　　　　　　　　　　将三边保存至edge buffer</span><br><span class="line">　　　　　　　　　　在temp中去除掉该三角形</span><br><span class="line">　　　　　　对edge buffer进行去重</span><br><span class="line">　　　　　　将edge buffer中的边与当前的点进行组合成若干三角形并保存至temp triangles中</span><br><span class="line">　　　　将triangles与temp triangles进行合并</span><br><span class="line">　　　　除去与超级三角形有关的三角形</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h1 id="Bowyer-Watson算法"><a href="#Bowyer-Watson算法" class="headerlink" title="Bowyer-Watson算法"></a>Bowyer-Watson算法</h1><p>基本思想:</p><blockquote><p>1.构造一个超级三角形，包含所有的散点，存入三角形链表<br>2.将点集中的离散点依次插入，在三角形链表中找出外接圆包含插入点的三角形（称为该点的影响三角形），删除影响三角形的<strong>公共边</strong>，将插入点同影响三角形的全部顶点连接起来，完成一个点在Delaunay三角形链表中的插入。<br>3.根据优化准则对局部新形成的三角形优化。将形成的三角形放入Delaunay三角形链表。<br>4.循环执行步骤2，直到所有离散点插入完毕。</p></blockquote><p>图示:(来自<a href="[https://baike.baidu.com/item/Delaunay%E4%B8%89%E8%A7%92%E5%89%96%E5%88%86%E7%AE%97%E6%B3%95](https://baike.baidu.com/item/Delaunay三角剖分算法">百度百科</a>))</p><p><img src="//loopvoid.github.io/2019/11/28/Delaunay三角剖分/d009b3de9c82d1582789d194800a19d8bc3e4288.jpg" alt="d009b3de9c82d1582789d194800a19d8bc3e4288.jpg"></p><p>借助三个点理解一遍。</p><p><img src="//loopvoid.github.io/2019/11/28/Delaunay三角剖分/Snipaste_2019-11-28_09-57-39.png" alt="Snipaste_2019-11-28_09-57-39.png"></p><p>根据离散点的最大分布得到一个随机超级三角形(即该三角形包含了整个离散点集P)，并将超级三角形放入temp triangles中</p><p><img src="//loopvoid.github.io/2019/11/28/Delaunay三角剖分/Snipaste_2019-11-28_10-01-38.png" alt="Snipaste_2019-11-28_10-01-38.png" style="zoom:75%;"></p><p>接下来对temp triangle中的三角形遍历画外接圆，这时先对左边第一个点a进行判断，其在圆内所以该三角形不为Delaunay三角形，将其三边保存至edge buffer中，temp triangles中删除该三角形</p><p><img src="//loopvoid.github.io/2019/11/28/Delaunay三角剖分/Snipaste_2019-11-28_10-03-32.png" alt="Snipaste_2019-11-28_10-03-32.png" style="zoom:75%;"></p><p>将a点与edge buffer中的每一个边相连，组成三个三角形，存入temp triangles中</p><p><img src="//loopvoid.github.io/2019/11/28/Delaunay三角剖分/Snipaste_2019-11-28_10-05-40.png" alt="Snipaste_2019-11-28_10-05-40.png" style="zoom:75%;"></p><p>再将重复对temp triangles的遍历并画外接圆，这时使用的是b点来进行判断</p><ul><li>b点在三角形1外接圆右侧，则表示左侧三角形为Delaunay三角形，将该三角形保存至triangles中</li><li>b点在三角形2外接圆外侧，为不确定三角形，跳过（后面处理），但并不在temp triangles中删除</li><li>b点在三角形3外接圆内侧，则这时向清空后的edge buffer加入该三角形的三条边，并用b点与edge buffer中的三角边进行组合，组合成了三个三角形并加入到temp triangles中</li></ul><p>这时，temp buffer 中有六条边，triangles中有两个三角形，temp triangles中有1个三角形</p><p>对temp buffer中的六条边进行去重，得到五条边，将该点与这五条边组合成五个三角形并加入到temp triangles 中，这时temp triangles中有6个三角形</p><p><img src="//loopvoid.github.io/2019/11/28/Delaunay三角剖分/Snipaste_2019-11-28_10-13-35.png" alt="Snipaste_2019-11-28_10-13-35.png" style="zoom: 67%;"></p><p>由于三个点已经遍历结束，到了不会再对第三个点形成的三角形做外接圆，这时则将triangles与temp triangles合并，合并后的数组表示包含已经确定的Delaunay三角形和剩下的三角形</p><p>这时除去合并后数组中的和超级三角形三个点有关的所有三角形，即进行数组坐标的限定，则得到了最后的结果：</p><p><img src="//loopvoid.github.io/2019/11/28/Delaunay三角剖分/Snipaste_2019-11-28_10-18-12.png" alt="Snipaste_2019-11-28_10-18-12.png"></p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><p><a href="https://github.com/loopvoid/delaunay" target="_blank" rel="noopener">Delaunay-Cpp</a></p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="http://www.cs.cmu.edu/~quake/triangle.html" target="_blank" rel="noopener">http://www.cs.cmu.edu/~quake/triangle.html</a><br><a href="https://people.sc.fsu.edu/~jburkardt/c_src/triangle/triangle.html" target="_blank" rel="noopener">https://people.sc.fsu.edu/~jburkardt/c_src/triangle/triangle.html</a><br><a href="https://www.cnblogs.com/zhiyishou/p/4430017.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhiyishou/p/4430017.html</a><br><a href="https://en.wikipedia.org/wiki/Delaunay_triangulation" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Delaunay_triangulation</a><br><a href="http://local.wasp.uwa.edu.au/~pbourke/papers/triangulate/index.html" target="_blank" rel="noopener">http://local.wasp.uwa.edu.au/~pbourke/papers/triangulate/index.html</a><br><a href="http://local.wasp.uwa.edu.au/~pbourke/papers/triangulate/cpp.zip" target="_blank" rel="noopener">http://local.wasp.uwa.edu.au/~pbourke/papers/triangulate/cpp.zip</a><br><a href="https://github.com/obviousjim/ofxDelaunay" target="_blank" rel="noopener">https://github.com/obviousjim/ofxDelaunay</a><br><a href="https://github.com/delfrrr/delaunator-cpp/blob/master/include/delaunator.hpp" target="_blank" rel="noopener">https://github.com/delfrrr/delaunator-cpp/blob/master/include/delaunator.hpp</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Delaunay-Triangle&quot;&gt;&lt;a href=&quot;#Delaunay-Triangle&quot; class=&quot;headerlink&quot; title=&quot;Delaunay Triangle&quot;&gt;&lt;/a&gt;Delaunay Triangle&lt;/h1&gt;&lt;p&gt;Delaunay三角
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="https://loopvoid.github.io/2019/11/17/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://loopvoid.github.io/2019/11/17/正则表达式/</id>
    <published>2019-11-17T08:28:14.000Z</published>
    <updated>2019-11-17T11:13:48.119Z</updated>
    
    <content type="html"><![CDATA[<h1 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h1><ul><li>将JS正则可视化的工具：<a href="https://regexper.com/" target="_blank" rel="noopener">regexper.com</a></li><li>在线练习：<a href="https://regex101.com/" target="_blank" rel="noopener">regex101.com</a></li><li>正则教程：<a href="https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md" target="_blank" rel="noopener">Learn Regex the easy way</a></li></ul><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="1-元字符"><a href="#1-元字符" class="headerlink" title="1.元字符"></a>1.元字符</h2><div class="table-container"><table><thead><tr><th>元字符</th><th>说明</th></tr></thead><tbody><tr><td>.</td><td>匹配除换行符以外的任意字符</td></tr><tr><td>\w</td><td>匹配<strong>字母、数字、下划线、汉字</strong></td></tr><tr><td>\s</td><td>匹配任意的<strong>空白符</strong></td></tr><tr><td>\d</td><td>匹配<strong>数字</strong></td></tr><tr><td>\b</td><td>匹配单词的<strong>开始</strong>或<strong>结束</strong></td></tr><tr><td>[]</td><td>匹配方括号内的任意字符</td></tr><tr><td>[\^]</td><td>匹配除了方括号里的任意字符集</td></tr><tr><td>(xyz)</td><td>匹配与xyz完全相等的字符串</td></tr><tr><td>^</td><td>匹配字符串的<strong>开始</strong></td></tr><tr><td>$</td><td>匹配字符串的<strong>结束</strong></td></tr></tbody></table></div><p>根据元字符，可以写一些简单的正则：</p><p>1.匹配所有ab开头的字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\bab  或者  ^ab</span><br></pre></td></tr></table></figure><p>2.匹配9位数字的QQ号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^\d\d\d\d\d\d\d\d\d$</span><br></pre></td></tr></table></figure><p>3.匹配1开头的7位数字的电话号码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^1\d\d\d\d\d\d$</span><br></pre></td></tr></table></figure><p>4.匹配<code>The car parked in the garage.</code>中的<code>The</code>和<code>the</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">正则：</span><br><span class="line">[Th]he</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">[The] car parked in [the] garage.</span><br></pre></td></tr></table></figure><p>5.匹配<code>The car parked in the garage.</code>中不是car的其他结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">正则:</span><br><span class="line">[^c]ar</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">The car [par]ked in the [gar]age.</span><br></pre></td></tr></table></figure><h2 id="2-重复限定符"><a href="#2-重复限定符" class="headerlink" title="2.重复限定符"></a>2.重复限定符</h2><p>用元字符能写不少正则表达式，但是向上面的一串<code>\d</code>还不够简洁。<br>为了处理重复的问题，正则提供了重复限定符号：</p><div class="table-container"><table><thead><tr><th>语法</th><th>说明</th></tr></thead><tbody><tr><td>*</td><td>重复<strong>0次</strong>或<strong>多次</strong></td></tr><tr><td>+</td><td>重复<strong>1次</strong>或<strong>多次</strong></td></tr><tr><td>？</td><td>重复<strong>0次</strong>或<strong>1次</strong></td></tr><tr><td>{n}</td><td>重复<strong>n次</strong></td></tr><tr><td>{n,}</td><td>重复<strong>n次</strong>或<strong>更多次</strong></td></tr><tr><td>{n,m}</td><td>重复<strong>n到m次</strong></td></tr></tbody></table></div><p>有了这些限定符之后，就能对元字符进行改造：</p><p>1.匹配9位数字的QQ号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^\d&#123;8&#125;$</span><br></pre></td></tr></table></figure><p>2.匹配1开头的7位数字的电话号码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^1\d&#123;6&#125;$</span><br></pre></td></tr></table></figure><p>3.匹配14~18位的银行卡号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^\d&#123;14,18&#125;$</span><br></pre></td></tr></table></figure><p>4.匹配以a开头的，0个或多个b结尾的字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^ab*$</span><br></pre></td></tr></table></figure><h2 id="3-分组"><a href="#3-分组" class="headerlink" title="3.分组"></a>3.分组</h2><p>从上面例4中看到，*限定符是作用在与他左边最近的一个字符，那么如果我想要ab同时被*限定那怎么办呢？</p><blockquote><p>正则表达式中用小括号()来做分组，也就是括号中的内容作为一个整体。</p></blockquote><p>因此当我们要匹配多个ab时，我们可以这样</p><p>如：匹配字符串中包含0到多个ab开头：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^(ab)*</span><br></pre></td></tr></table></figure><h2 id="4-转义"><a href="#4-转义" class="headerlink" title="4.转义"></a>4.转义</h2><p>正则提供了转义的方式，也就是要把这些元字符、限定符或者关键字转义成普通的字符，需要在要转义的字符前面加个斜杠，也就是\即可。如将分组所使用的括号转义为匹配对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^(\(ab\))*</span><br></pre></td></tr></table></figure><h2 id="5-条件或"><a href="#5-条件或" class="headerlink" title="5.条件或"></a>5.条件或</h2><p>国内手机号码它们都有属于自己的号段，比如联通有130/131/132/155/156/185/186/145/176等号段，假如匹配一个联通的号码就要用到一些并列的条件，也就是“或”。</p><blockquote><p>正则用符号 | 来表示或，也叫做分支条件，当满足正则里的分支条件的任何一种条件时，都会当成是匹配成功。</p></blockquote><p>那么我们就可以用或条件来处理这个问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^(130|131|132|155|156|185|186|145|176)\d&#123;8&#125;$</span><br></pre></td></tr></table></figure><h2 id="6-区间"><a href="#6-区间" class="headerlink" title="6.区间"></a>6.区间</h2><blockquote><p>正则提供一个元字符中括号 [] 来表示区间条件。</p></blockquote><p>1.限定0到9 可以写成[0-9]</p><p>2.限定A-Z 写成[A-Z]</p><p>3.限定某些数字 [165]</p><p>那上面的正则我们还改成这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^((13[0-2])|(15[56])|(18[5-6])|145|176)\d&#123;8&#125;$</span><br></pre></td></tr></table></figure><h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><h2 id="1-零宽断言"><a href="#1-零宽断言" class="headerlink" title="1.零宽断言"></a>1.零宽断言</h2><p>1.<strong>断言</strong>：俗话的断言就是“我断定什么什么”，而正则中的断言，就是说正则可以指明在指定的内容的前面或后面会出现满足指定规则的内容，意思正则也可以像人类那样断定什么什么，比如”ss1aa2bb3”,正则可以用断言找出aa2前面有bb3，也可以找出aa2后面有ss1.<br>2.<strong>零宽</strong>：就是没有宽度，在正则中，断言只是匹配位置，不占字符，也就是说，匹配结果里是不会返回断言本身。</p><div class="table-container"><table><thead><tr><th>符号</th><th>描述</th><th>解释</th></tr></thead><tbody><tr><td>?=pattern</td><td>正先行断言-存在</td><td>匹配pattern<strong>前面</strong>的内容</td></tr><tr><td>?&lt;=pattern</td><td>正后发断言-存在</td><td>匹配pattern<strong>后面</strong>的内容</td></tr><tr><td>?!pattern</td><td>负先行断言-排除</td><td>匹配<strong>非</strong>pattern<strong>前面</strong>的内容</td></tr><tr><td>?&lt;!pattern</td><td>负后发断言-排除</td><td>匹配<strong>非</strong>pattern<strong>后面</strong>的内容</td></tr></tbody></table></div><blockquote><p>正先行断言-存在:    “(T|t)he(?=\sfat)” =&gt; <strong>The</strong> fat cat sat on the mat.</p><p>正后发断言-存在:    “(?&lt;=(T|t)he\s)(fat|mat)” =&gt; The <strong>fat</strong> cat sat on the <strong>mat</strong>.  </p><p>负先行断言-排除:    “(T|t)he(?!\sfat)” =&gt; The fat cat sat on <strong>the</strong> mat.</p><p>负后发断言-排除:      “(?&lt;!(T|t)he\s)(cat)” =&gt; The cat sat on <strong>cat</strong>.</p></blockquote><p>例子：假设我们要用爬虫抓取csdn里的文章阅读量。通过查看源代码可以看到文章阅读量这个内容是这样的结构</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"read-count"</span>&gt;</span>阅读数：641<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中也就‘641’这个是变量，也就是说不同文章不同的值，当我们拿到这个字符串时，需要获得这里边的‘641’有很多种办法，但如果正则应该怎么匹配呢？</p><p><strong>1).正向先行断言(正前瞻)</strong>:</p><ul><li>语法：<strong>(?=pattern)</strong></li><li>作用：匹配pattern表达式<strong>前面</strong>的内容，<strong>不返回本身</strong></li></ul><p>要取到阅读量，在正则表达式中就意味着要能匹配到<code>&lt;/span&gt;</code>前面的数字内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">内容：</span><br><span class="line">&lt;span class=&quot;read-count&quot;&gt;阅读数：641&lt;/span&gt;</span><br><span class="line"></span><br><span class="line">正则：</span><br><span class="line">.+(?=&lt;/span&gt;)</span><br><span class="line"></span><br><span class="line">匹配结果：</span><br><span class="line">&lt;span class=&quot;read-count&quot;&gt;阅读数：641</span><br></pre></td></tr></table></figure><p>我们要的只是前面的数字呀，那也简单咯，匹配数字 \d,那可以改成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">内容：</span><br><span class="line">&lt;span class=&quot;read-count&quot;&gt;阅读数：641&lt;/span&gt;</span><br><span class="line"></span><br><span class="line">正则：</span><br><span class="line">\d+(?=&lt;/span&gt;)</span><br><span class="line"></span><br><span class="line">匹配结果：</span><br><span class="line">641</span><br></pre></td></tr></table></figure><p><strong>2).正向后行断言(正后顾)</strong>:</p><ul><li>语法：<strong>(?&lt;=pattern)</strong></li><li>作用：匹配pattern表达式<strong>后面</strong>的内容，<strong>不返回本身</strong></li></ul><p><strong>先行</strong>是匹配<strong>前面</strong>的内容，那<strong>后行</strong>就是匹配<strong>后面</strong>的内容。<br>上面的栗子，也可以用后行断言来处理:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">内容：</span><br><span class="line">&lt;span class=&quot;read-count&quot;&gt;阅读数：641&lt;/span&gt;</span><br><span class="line"></span><br><span class="line">正则：</span><br><span class="line">(?&lt;=&lt;span class=&quot;read-count&quot;&gt;阅读数：)\d+</span><br><span class="line"></span><br><span class="line">匹配结果：</span><br><span class="line">641</span><br></pre></td></tr></table></figure><p><strong>3).负向先行断言(负前瞻)</strong>：</p><ul><li>语法：<strong>(?!pattern)</strong></li><li>作用：匹配<strong>非</strong>pattern表达式<strong>前面</strong>的内容，<strong>不返回本身</strong>，即匹配<strong>结果不包含pattern</strong>表达式</li></ul><p>例如对<code>regex represents regular expression</code>，要想匹配除<strong>re</strong>gex和<strong>re</strong>gular之外的re:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">内容：</span><br><span class="line">regex represents regular expression</span><br><span class="line"></span><br><span class="line">正则：</span><br><span class="line">re(?!g)</span><br><span class="line"></span><br><span class="line">匹配结果：</span><br><span class="line">regex [re]p[re]sents regular exp[re]ssion</span><br></pre></td></tr></table></figure><h2 id="2-捕获和非捕获"><a href="#2-捕获和非捕获" class="headerlink" title="2.捕获和非捕获"></a>2.捕获和非捕获</h2><p>单纯说到捕获，他的意思是匹配表达式，但捕获通常和分组联系在一起，也就是“捕获组”</p><blockquote><p>捕获组：匹配子表达式的内容，把匹配结果保存到内存中中数字编号或显示命名的组里，以深度优先进行编号，之后可以通过序号或名称来使用这些匹配结果。</p></blockquote><p>而根据命名方式的不同，又可以分为两种组：</p><p><strong>1).数字编号捕获组：</strong></p><ul><li>语法：<strong>(exp)</strong></li><li>解释：从表达式左侧开始，每出现一个左括号和它对应的右括号之间的内容为一个分组，在分组中，第0组为整个表达式，第一组开始为分组。</li></ul><p>比如固定电话的：<strong>020-85653333</strong><br>他的正则表达式为：<strong>(0\d{2})-(\d{8})</strong><br>按照左括号的顺序，这个表达式有如下分组：</p><div class="table-container"><table><thead><tr><th>序号</th><th>编号</th><th>分组</th><th>内容</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>(0\d{2})-(\d{8})</td><td>020-85653333</td></tr><tr><td>1</td><td>1</td><td>(0\d{2})</td><td>020</td></tr><tr><td>2</td><td>2</td><td>(\d{8})</td><td>85653333</td></tr></tbody></table></div><p><strong>2).命名编号捕获组：</strong></p><ul><li>语法：<strong>(?\<name\>exp)</name\></strong></li><li>解释：分组的命名由表达式中的name指定</li></ul><p>比如区号也可以这样写:<strong>(?\<quhao\>\0\d{2})-(?\<haoma\>\d{8})</haoma\></quhao\></strong></p><p>按照左括号的顺序，这个表达式有如下分组：</p><div class="table-container"><table><thead><tr><th>序号</th><th>编号</th><th>分组</th><th>内容</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>(0\d{2})-(\d{8})</td><td>020-85653333</td></tr><tr><td>1</td><td>quhao</td><td>(0\d{2})</td><td>020</td></tr><tr><td>2</td><td>haoma</td><td>(\d{8})</td><td>85653333</td></tr></tbody></table></div><p><strong>3).非捕获组</strong>：</p><ul><li>语法：<strong>(?:exp)</strong></li><li>解释：和捕获组刚好相反，它用来标识那些不需要捕获的分组，通俗讲，就是可以根据需要去保存你的分组。</li></ul><p>比如上面的正则表达式，程序不需要用到第一个分组，那就可以这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(?:\0\d&#123;2&#125;)-(\d&#123;8&#125;)</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>序号</th><th>编号</th><th>分组</th><th>内容</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>(0\d{2})-(\d{8})</td><td>020-85653333</td></tr><tr><td>1</td><td>1</td><td>(\d{8})</td><td>85653333</td></tr></tbody></table></div><h2 id="3-反向引用"><a href="#3-反向引用" class="headerlink" title="3.反向引用"></a>3.反向引用</h2><p><strong>捕获会返回一个捕获组，这个分组是保存在内存中，不仅可以在正则表达式外部通过程序进行引用，也可以在正则表达式内部进行引用，这种引用方式就是反向引用</strong></p><p>根据捕获组的命名规则，反向引用可分为：</p><p>1).数字编号组反向引用：<code>\k</code>或<code>\number</code></p><p>2).命名编号组反向引用：<code>\k</code>或<code>\name</code></p><p>例：</p><p>比如要查找一串字母<code>aabbbbgbddesddfiid</code>里成对的字母</p><p>思路：</p><ul><li>a. 匹配到一个字母</li><li>b. 匹配下一个字母，检查是否和上一个字母一样</li><li>c. 若一样，匹配成功，否则失败</li></ul><p>这里的思路2中匹配下一个字母时，需要用到上一个字母，那怎么记住上一个字母呢？这下捕获就有用处啦，我们可以利用捕获把上一个匹配成功的内容用来作为本次匹配的条件.</p><p>首先匹配一个字母：<code>\w</code></p><p>需要将匹配的第一个字母做成分组才能捕获，因此：<code>(\w)</code></p><p>然后用这个捕获组作为条件，则：<code>(\w)\1</code></p><p><strong>在默认情况下都是以数字来命名，而且数字命名的顺序是从1开始的，\1表示第一个捕获组，也就是(\w)</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">内容：</span><br><span class="line">aabbbbgbddesddfiid</span><br><span class="line"></span><br><span class="line">正则：</span><br><span class="line">\(w)\1</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">aa</span><br><span class="line">bb</span><br><span class="line">bb</span><br><span class="line">dd</span><br><span class="line">dd</span><br><span class="line">ii</span><br></pre></td></tr></table></figure><h2 id="4-替换"><a href="#4-替换" class="headerlink" title="4.替换"></a>4.替换</h2><p>有了引用那么我们可以根据捕获组进行直接对应内容的替换。</p><p>例如想要将</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.Anne</span><br><span class="line">2.John</span><br></pre></td></tr></table></figure><p>每行的编号替换成带引号的编号，即<code>&quot;1&quot;，&quot;2&quot;</code>这样替换就很方便了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">内容：</span><br><span class="line">1.Anne</span><br><span class="line">2.John</span><br><span class="line"></span><br><span class="line">正则：</span><br><span class="line"> - 查找: ^\d</span><br><span class="line"> - 替换: &quot;$1&quot;</span><br><span class="line"></span><br><span class="line">结果:</span><br><span class="line">&quot;1&quot;.Anne</span><br><span class="line">&quot;2&quot;.John</span><br></pre></td></tr></table></figure><h2 id="5-贪婪和非贪婪"><a href="#5-贪婪和非贪婪" class="headerlink" title="5.贪婪和非贪婪"></a>5.贪婪和非贪婪</h2><p><strong>1).贪婪</strong></p><ul><li>贪婪匹配：当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符，这匹配方式叫做贪婪匹配。</li><li>特性：一次性读入整个字符串进行匹配，每当不匹配就舍弃最右边一个字符，继续匹配，依次匹配和舍弃（这种匹配-舍弃的方式也叫做回溯），直到匹配成功或者把整个字符串舍弃完为止，因此它是一种最大化的数据返回，能多不会少。</li></ul><p>前面的重复限定符就是贪婪量词，比如表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\d&#123;<span class="number">3</span>,<span class="number">6</span>&#125;</span><br></pre></td></tr></table></figure><p>用来匹配3到6位数字，在这种情况下，它是一种贪婪模式的匹配，也就是假如字符串里有6个个数字可以匹配，那它就是全部匹配到。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">内容：</span><br><span class="line">61762828 176 2991 871</span><br><span class="line"></span><br><span class="line">正则：</span><br><span class="line">\d&#123;3,6&#125;</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">617628</span><br><span class="line">176</span><br><span class="line">2991</span><br><span class="line">871</span><br></pre></td></tr></table></figure><p>由结果可见：本来字符串中的“61762828”这一段，其实只需要出现3个（617）就已经匹配成功了的，但是他并不满足，而是匹配到了最大能匹配的字符，也就是6个。</p><p>多个贪婪量词凑在一起，那他们是如何支配自己的匹配权的呢？</p><blockquote><p>多个贪婪在一起时，如果字符串能满足他们各自最大程度的匹配时，就互不干扰，但如果不能满足时，会根据深度优先原则，也就是从左到右的每一个贪婪量词，优先最大数量的满足，剩余再分配下一个量词匹配。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">内容：</span><br><span class="line">61762828 176 2991 87321</span><br><span class="line"></span><br><span class="line">正则：</span><br><span class="line">(\d&#123;1,2&#125;)(\d&#123;3,4&#125;)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">617628</span><br><span class="line">2991</span><br><span class="line">87321</span><br></pre></td></tr></table></figure><p>“617628” 是前面的\d{1,2}匹配出了61，后面\d{3,4}匹配出了7628<br>“2991”是前面的\d{1,2}匹配出了29，后面\d{3,4}匹配出了91<br>“97321”是前面的\d{1,2}匹配出了97，后面\d{3,4}匹配出了321</p><p><strong>2).懒惰(非贪婪)</strong></p><ul><li>懒惰匹配：当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能少的字符，这匹配方式叫做懒惰匹配。</li><li>特性：从左到右，从字符串的最左边开始匹配，每次试图不读入字符匹配，匹配成功，则完成匹配，否则读入一个字符再匹配，依此循环（读入字符、匹配）直到匹配成功或者把字符串的字符匹配完为止。</li><li>懒惰量词是在贪婪量词后面加个<code>?</code></li></ul><div class="table-container"><table><thead><tr><th>代码</th><th>说明</th></tr></thead><tbody><tr><td>*?</td><td>重复任意次数，但尽可能少重复</td></tr><tr><td>+?</td><td>重复1次或更多次，但是尽可能少重复</td></tr><tr><td>??</td><td>重复0次或1次，但是尽可能少重复</td></tr><tr><td>{n,m}?</td><td>重复n到m次，但是尽可能少重复</td></tr><tr><td>{n,}?</td><td>重复n次以上，但是尽可能少重复</td></tr></tbody></table></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">内容：</span><br><span class="line">61762828 176 2991 87321</span><br><span class="line"></span><br><span class="line">正则：</span><br><span class="line">(\d&#123;1,2&#125;?)(\d&#123;3,4&#125;)</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">61762</span><br><span class="line">2991</span><br><span class="line">87321</span><br></pre></td></tr></table></figure><p>“61762” 是前面的懒惰匹配\d{1,2}?匹配出了6，后面贪婪匹配\d{3,4}匹配出了1762<br>“2991”是前面的懒惰匹配\d{1,2}?匹配出了2，后面贪婪匹配\d{3,4}匹配出了991<br>“87321”是前面的\d{1,2}匹配出了8，后面\d{3,4}匹配出了7321</p><h2 id="6-反义"><a href="#6-反义" class="headerlink" title="6.反义"></a>6.反义</h2><p>若不想匹配某些内容，就可以使用反义元字符，反义元字符很大一部分就是元字符大写：</p><div class="table-container"><table><thead><tr><th>元字符</th><th>解释</th></tr></thead><tbody><tr><td>\W</td><td>匹配任意<strong>不是</strong>字母、数字、下划线、汉字的字符</td></tr><tr><td>\S</td><td>匹配任意<strong>不是</strong>空白符的字符</td></tr><tr><td>\D</td><td>匹配任意<strong>非</strong>数字的字符</td></tr><tr><td>\B</td><td>匹配不是单词开头或结束的位置</td></tr><tr><td><sup><a href="#fn_x" id="reffn_x">x</a></sup></td><td>匹配除了x<strong>以外</strong>的任意字符</td></tr><tr><td><sup><a href="#fn_aeiou" id="reffn_aeiou">aeiou</a></sup></td><td>匹配除了aeiou这几个字母以外的任意字符</td></tr></tbody></table></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;推荐&quot;&gt;&lt;a href=&quot;#推荐&quot; class=&quot;headerlink&quot; title=&quot;推荐&quot;&gt;&lt;/a&gt;推荐&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;将JS正则可视化的工具：&lt;a href=&quot;https://regexper.com/&quot; target=&quot;_blank&quot; rel=
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>最小二乘的曲线曲面拟合</title>
    <link href="https://loopvoid.github.io/2019/10/21/%E7%A7%BB%E5%8A%A8%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E7%9A%84%E6%9B%B2%E7%BA%BF%E6%9B%B2%E9%9D%A2%E6%8B%9F%E5%90%88/"/>
    <id>https://loopvoid.github.io/2019/10/21/移动最小二乘的曲线曲面拟合/</id>
    <published>2019-10-21T14:58:30.000Z</published>
    <updated>2019-11-09T07:41:24.882Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LS-Approximation-Least-squares"><a href="#LS-Approximation-Least-squares" class="headerlink" title="LS Approximation(Least-squares)"></a>LS Approximation(Least-squares)</h1><p><strong>Question.</strong>给定N个点$x_i\in\mathbb{R}^d,where\ i\in[1…N]$.希望得到$f(x)$能近似出点$x_i$处的$f_i$</p><p>值。误差函数为$J_{LS}=\sum_i||f(\mathbb{x}_i)-f_i||^2$。那么得到最小化问题：</p><script type="math/tex; mode=display">min_{f_x\in\prod_m^d}\sum_i||f(\mathbb{x}_i)-f_i||^2\tag 1</script><p>$f$ 取自$\prod_m^d$,d维空间上为total degree为m的多项式空间，则可以写作：</p><script type="math/tex; mode=display">f(x)=b(x)^Tc=b(x)\cdot c \tag 2</script><p>其中：$\mathbb{b}(x)=[b_1(x),…,b_k(x)]^T$是多项式的基向量，$\mathbb{c}=[c_1,…,c_k]^T$是需要最小化求解的未知系数向量。</p><p>多项式的基：</p><ul><li>$(m=2,d=2)，\mathbb{b(x)}=[1,x,y,x^2,xy,y^2]^T$</li><li>$\mathbb{R^3}(m=1,d=3)$的线性拟合，$\mathbb{b(x)}=[1,x,y,z]^T$</li><li>任意维度常数拟合，$\mathbb{b(x)}=[1]$</li></ul><p><strong>Solution.</strong>误差函数$J_{LS}$的偏导为0.$\bigtriangledown J_{LS}=0,\bigtriangledown=[\partial/\partial_{c_1},…,\partial/\partial_{c_k}]$ </p><p>因此，可以得到一个线性方程组(<strong>LSE</strong>)：</p><script type="math/tex; mode=display">\begin{align}\partial J_{LS}/\partial c_1=0 &: \sum_i2b_1(\mathbb{x_i})[\mathbb{b(x_i)}^T\mathbb{c}-f_i]=0\\\\\partial J_{LS}/\partial c_2=0 &: \sum_i2b_2(\mathbb{x_i})[\mathbb{b(x_i)}^T\mathbb{c}-f_i]=0\\\\&\ \vdots\\\\\partial J_{LS}/\partial c_k=0 &: \sum_i2b_k(\mathbb{x_i})[\mathbb{b(x_i)}^T\mathbb{c}-f_i]=0\\\\\end{align}</script><p>可以向量表示为：</p><script type="math/tex; mode=display">2\sum_i\mathbb{[b(x_i)b(x_i)}^T\mathbb{c}-\mathbb{b(x_i)}f_i]=0\\\\\Rightarrow \\\\c=[\sum_ib(x_i)b(x_i)^T]^{-1}\sum_ib(x_i)f_i</script><p><strong>Example.</strong></p><p>在$\mathbb{R}^2$拟合一个二元二次多项式，i.e. $d=2,m=2$，那么有$\mathbb{b(x)}=[1,x,y,x^2,xy,y^2]^T$，那么线性方程组为：</p><script type="math/tex; mode=display">\begin{bmatrix}1 & x_i & y_i & x_i^2 & x_iy_i & y_i^2 \\x_i & x_i^2 & x_iy_i & x_i^3 & x_i^2y_i & x_iy_i^2\\y_i & x_iy_i & y_i^2 & x_i^2y_i & x_iy_i^2 & y_i^3\\x_i^2 & x_i^3 & x_i^2y_i & x_i^4 & x_i^3y_i & x_i^2y_i^2\\x_iy_i & x_i^2y_i & x_iy_i^2 & x_i^3y_i & x_i^2y_i^2 & x_iy_i^3\\y_i^2 & x_iy_i^2 & y_i^3 & x_i^2y_i^2 & x_iy_i^3 & y_i^4\end{bmatrix}\begin{bmatrix}c_1\\c_2\\c_3\\c_4\\c_5\\c_6\end{bmatrix}=\sum_i\begin{bmatrix}1\\x_i\\y_i\\x_i^2\\x_iy_i\\y_i^2\end{bmatrix}f_i</script><p>考虑一组二维平面上的点$P_i={(1,1),(1,-1),(-1,1),(-1,-1),(0,0),(1,0),(-1,0),(0,1),(0,-1)}$有两组对应的函数值$f_i^1={1.0, -0.5, 1.0, 1.0, -1.0, 0.0, 0.0, 0.0, 0.0}$和$f_i^2={1.0, -1.0, 0.0, 0.0, 1.0, 0.0, -1.0, -1.0, 1.0}$。</p><p>图1为该数据的拟合：</p><p><img src="//loopvoid.github.io/2019/10/21/移动最小二乘的曲线曲面拟合/fig1.png" alt="fig1"></p><p>图1. 二元二次多相似局部拟合：第一行为2组9个数据点，第二行是LS拟合函数。对应的参数向量$[c_1,…,c_6]^T$分别左为$[.0.834,.0.25,0.75,0.25,0.375,0.75]^T$，右为$[0.334,0.167,0.0,.0.5,0.5,0.0]^T$.</p><hr><h1 id="WLS-Approximation-Weighted-Least-Squates"><a href="#WLS-Approximation-Weighted-Least-Squates" class="headerlink" title="WLS Approximation(Weighted Least Squates)"></a>WLS Approximation(Weighted Least Squates)</h1><p>在<strong>WLS</strong>方法中使用误差函数$J_{WLS}=\sum_i\theta(||\mathbb{\bar x-x_i}||)||f(\mathbb{x_i})-f_i||^2$，$\bar x \in \mathbb{R}^d$为固定点。因此需要最小化：</p><script type="math/tex; mode=display">min_{f_x\in\prod_m^d}\sum_i\theta(||\mathbb{\bar x-x_i}||)||f(\mathbb{x}_i)-f_i||^2\tag 1</script><p>其中：权重$\theta(d)$由数据点$\mathbb{x_i}$到$\mathbb{\bar x}$之间的欧氏距离表示。</p><p>未知系数也与上述权重有关，则：</p><script type="math/tex; mode=display">f_{\mathbb{\bar x}}(\mathbb{x})=\mathbb{b(x)^Tc(\bar x)}=\mathbb{b(x)\cdot c(\bar x)},||x-\bar x||<h\\\\b(x)=[b_1(x),...,b_k(x)]^T \\\\Gaussian:\theta (d)=e^{-\frac{d^2}{h^2}}\\\\Wendland:\theta (d)=(1-\frac{d}{h})^4(4\frac{d}{h}+1)\\\\c(\bar x)=[\sum_i\theta (d_i)b(x_i)b(x_i)^T]^{-1}\sum_i\theta (d_i)b(x_i)f_i\\\\</script><h1 id="MLS-Approximation-Moving-least-squares"><a href="#MLS-Approximation-Moving-least-squares" class="headerlink" title="MLS Approximation(Moving least squares)"></a>MLS Approximation(Moving least squares)</h1><p>与<strong>WLS</strong>很类似，不同点：</p><blockquote><p>n <strong>move</strong> this point ($\bar x$) over the entire parameter domain, where a weighted least squares fit is computed and evaluated for each point individually.</p></blockquote><p>因此：</p><script type="math/tex; mode=display">f(x)=f_x(x),min_{f_x\in\prod_m^d}\sum_i\theta(||x-x_i||)||f_x(x_i)-f_i||^2\\\\f_{\bar x}(x)=b(x)\cdot c(\bar x)\\\\c(\bar x)=[\sum_i\theta (d_i)b(x_i)b(x_i)^T]^{-1}\sum_i\theta (d_i)b(x_i)f_i</script><hr><h2 id="拟合函数的建立"><a href="#拟合函数的建立" class="headerlink" title="拟合函数的建立"></a>拟合函数的建立</h2><p>在拟合区域的局部子域上，拟合函数</p><script type="math/tex; mode=display">f(x)=\sum_{i=1}^m\alpha_{i}(x)p_i(x)=p^T(x)\alpha(x)\tag{1}</script><p>其中：</p><p>$\alpha(x)=[\alpha_1(x),\alpha_2(x),…,\alpha_m(x)]^T$为待求系数，它是坐标x的函数</p><p>$p(x)=[p_1(x),p_2(x),…,p_m(x)]^T$称为基函数，它是一个$k$阶完备的多项式</p><p>$m$是基函数的项数</p><p>对于二维问题：</p><p>线性基：$p(x)=[1,x,y]^T，m=3$</p><p>二次基：$p(x)=[1,x,y,x^2,xy,y^2]^T，m=6$</p><p>考虑加权离散$L_2$范式(向量$\mathbf{x}=[x_1,x_2,…,x_n]$的$L_2$范式$||\mathbf{x}||_2=(\sum_{i=1}^nx_i^2)^{1/2}$)</p><script type="math/tex; mode=display">J=\sum_{i=1}^nw(x-x_i)[f(x)-y_i]^2 \\\\ =\sum_{i=1}^nw(x-x_i)[p^T(x_i)\alpha(x)-y_i]^2 \tag{3}</script><p>其中：</p><p>$n$是影响区域内节点的数目</p><p>$f(x)$是拟合函数</p><p>$y_i$是$x=x_i$处的节点值，$y_i=y(x_i)$</p><p>$w(x-x_i)$是节点$x_i$的权函数</p><p>为确定系数$\alpha(x)$，$J$应取极小值。对$\alpha$求导：</p><script type="math/tex; mode=display">\frac{\partial J}{\partial \alpha}= A(x)\alpha(x)-B(x)y=0\tag{4}</script><script type="math/tex; mode=display">\alpha(x)= A^{-1}(x)B(x)y\tag{5}</script><p>其中：</p><script type="math/tex; mode=display">A(x)= \sum_{i=1}^nw(x-x_i)p(x_i)p^T(x_i)\tag{6} \\\\或者(线性二维曲线)： \\\\A(x)= \sum_{i=1}^np^T(x_i)w(x-x_i)p(x_i) \\\\= \begin{bmatrix}\sum_{i=1}^nw(x-x_i) & \sum_{i=1}^nx_iw(x-x_i)\\ \sum_{i=1}^nx_iw(x-x_i) & \sum_{i=1}^nx_i^2w(x-x_i)\end{bmatrix}</script><script type="math/tex; mode=display">B(x)= [w(x-x_1)p(x_1),w(x-x_2)p(x_2),...,w(x-x_n)p(x_n)]\tag{7}</script><script type="math/tex; mode=display">y^T= [y_1,y_2,...,y_n]\tag{8}</script><p>把式<strong>(5)</strong>代入式<strong>(1)</strong>，就可以得到<strong>MLS</strong>拟合函数：</p><script type="math/tex; mode=display">f(x)=\sum_{i=1}^n\Phi_i^k(x)y_i=O^k(x)y\tag{9}</script><p>其中，$O^k(x)$叫<strong>形函数</strong>，$k$表示基函数的<strong>阶数</strong>：</p><script type="math/tex; mode=display">O^k(x)=[\Phi_1^k,\Phi_2^k,...,\Phi_n^k]=p^T(x)A^{-1}(x)B(x)\tag{10}</script><p>如果$k=0$，则基函数$p(x)={1}$，这时的形函数为Shepard函数：</p><script type="math/tex; mode=display">O_i^{Shepard}(x)=\frac{w(x-x_i)}{\sum_{j=1}^nw(x=x_j)}\tag{11}</script><p>即使基函数$p(x)$为多项式，式<strong>(9)</strong>中的$f(x)$也不再是多项式。</p><p>若基函数$p\in C^r$，权函数$w\in C^s$，则拟合函数$f\in C^{min(r,s)}$。</p><h2 id="权函数"><a href="#权函数" class="headerlink" title="权函数"></a>权函数</h2><p>移动最小二乘中的权函数$w(x-x_i)$，其在$x$的一个子领域内不等于0，在这个子域外全为0，这个子域称为权函数的支持域(即$x$的影响区域)。</p><p>一般选择圆形作为权函数的支持域，其半径记为$s_{max}$</p><p>只有包含在支持域内的数据对$x$的取值有影响</p><p>权函数$w(x-x_i)$应该是<strong>非负</strong>的，并且随着$||x-x_i||_2$的增加单调递减。</p><p>权函数还应该具有一定的光滑性，因为拟合函数会继承权函数的连续性。</p><p>连续性：若权函数$w(x-x_i)$是$C^1$阶连续的，则拟合函数也是$C^1$阶连续的。</p><p>常用的权函数是<strong>样条函数</strong>，记$s=x-x_i，\bar s=\frac{s}{s_{max}}$则三次样条函数如式<strong>(12)</strong>所示：</p><script type="math/tex; mode=display">w(\bar s)=\left\{\begin{matrix}\frac{2}{3}-4\bar s^2 + 4\bar s^3 & (\bar s\le\frac{1}{2})\\ \frac{4}{3}-4\bar s+4\bar s^2-\frac{4}{3}\bar s^3 & (\frac{1}{2}<\bar s \le 1)\\ 0 & (\bar s>1)\end{matrix}\right.\tag{12}</script><p>支持域应该包含足够多的节点，使得式<strong>(6)</strong>中$A(x)$可逆。</p><p>如果式<strong>(1)</strong>使用的是线性基函数，则<strong>曲线拟合</strong>的支持域内应该至少包含不重叠的<strong>2个节点</strong>，<strong>曲面拟合</strong>的支持域内应该至少包含不在同一条直线上的<strong>3个节点</strong></p><h2 id="MLS拟合流程"><a href="#MLS拟合流程" class="headerlink" title="MLS拟合流程"></a>MLS拟合流程</h2><p>基本思想：先讲拟合区域网格化，然后用公式<strong>(9)</strong>求出网格上节点值，最后连接网格节点形成拟合曲线（曲面）。</p><ul><li>将拟合区域网格化；</li><li>对每个网格点x进行循环：<ul><li>确定网格点x的支持域(半径)的大小；</li><li>确定包含在x的影响区域内的节点；</li><li>计算行函数$O^k(x)$；</li><li>计算网格点x处的函数值</li></ul></li><li>结束网格点循环；</li><li>连接网格点形成拟合曲线(曲面)。</li></ul><h2 id="误差分析"><a href="#误差分析" class="headerlink" title="误差分析"></a>误差分析</h2><p>为分析<strong>曲面拟合</strong>误差，定义误差项：</p><script type="math/tex; mode=display">error=\int_U[f^{EXACT}(x,y)-f^{MLS}(x,y)]^2dU\tag{14}</script><p>其中，$f^{EXACT}(x,y)$是精确值，$f^{MLS}(x,y)$是移动最小二乘的计算值。</p><hr><h1 id="Applications"><a href="#Applications" class="headerlink" title="Applications"></a>Applications</h1><p><img src="//loopvoid.github.io/2019/10/21/移动最小二乘的曲线曲面拟合/fit.png" alt="fit.png"></p><blockquote><p>The MLS surface of a point-set with varying density (the<br>density is reduced along the vertical axis from top to bottom). The<br>surface is obtained by applying the projection operation described<br>by Alexa et. al. [2003]. Image courtesy of Marc Alexa.</p></blockquote><hr><h1 id="Coding"><a href="#Coding" class="headerlink" title="Coding"></a>Coding</h1><ul><li><p><a href="https://github.com/loopvoid/mls" target="_blank" rel="noopener">Matlab原理版本</a></p></li><li><p><a href="https://github.com/loopvoid/mls" target="_blank" rel="noopener">C++版本</a></p></li></ul><hr><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="http://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=1&amp;cad=rja&amp;uact=8&amp;ved=2ahUKEwiHrcX4z7zlAhXDAYgKHeS_Cj8QFjAAegQIBBAC&amp;url=http%3A%2F%2Fwww.nealen.de%2Fprojects%2Fmls%2Fasapmls.pdf&amp;usg=AOvVaw0mQQFav7cDFU1l9-OYOf7y" target="_blank" rel="noopener">asapmls</a><br><a href="https://blog.csdn.net/baidu_38127162/article/details/82380914" target="_blank" rel="noopener">https://blog.csdn.net/baidu_38127162/article/details/82380914</a><br><a href="https://blog.csdn.net/liumangmao1314/article/details/54179526" target="_blank" rel="noopener">https://blog.csdn.net/liumangmao1314/article/details/54179526</a><br><a href="https://blog.csdn.net/hjimce/article/details/46550001" target="_blank" rel="noopener">https://blog.csdn.net/hjimce/article/details/46550001</a><br><a href="https://wenku.baidu.com/view/fe7a74976f1aff00bed51eb1.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/fe7a74976f1aff00bed51eb1.html</a><br><a href="https://blog.csdn.net/liumangmao1314/article/details/89421806" target="_blank" rel="noopener">https://blog.csdn.net/liumangmao1314/article/details/89421806</a><br><a href="https://en.wikipedia.org/wiki/Moving_least_squares" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Moving_least_squares</a><br><a href="http://vision.gel.ulaval.ca/~jflalonde/cours/4105/h14/tps/results/project/jingweicao/index.html" target="_blank" rel="noopener">Final Project: Image Deformation Using Moving Least Squares</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;LS-Approximation-Least-squares&quot;&gt;&lt;a href=&quot;#LS-Approximation-Least-squares&quot; class=&quot;headerlink&quot; title=&quot;LS Approximation(Least-squares)&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MTCNN算法与代码理解</title>
    <link href="https://loopvoid.github.io/2019/10/14/MTCNN%E7%AE%97%E6%B3%95%E4%B8%8E%E4%BB%A3%E7%A0%81%E7%90%86%E8%A7%A3/"/>
    <id>https://loopvoid.github.io/2019/10/14/MTCNN算法与代码理解/</id>
    <published>2019-10-14T10:52:28.000Z</published>
    <updated>2019-12-27T08:02:48.649Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>原作主页</strong>：<a href="https://kpzhang93.github.io/MTCNN_face_detection_alignment/index.html" target="_blank" rel="noopener">https://kpzhang93.github.io/MTCNN_face_detection_alignment/index.html</a></p><p><strong>arxiv论文</strong>：<a href="https://arxiv.org/abs/1604.02878" target="_blank" rel="noopener">https://arxiv.org/abs/1604.02878</a></p><p><strong>代码</strong>：<a href="https://github.com/kpzhang93/MTCNN_face_detection_alignment" target="_blank" rel="noopener">官方matlab版</a>、<a href="https://github.com/kpzhang93/MTCNN_face_detection_alignment" target="_blank" rel="noopener">C++ caffe版</a> </p><p><strong>其他框架代码</strong>：<a href="https://github.com/TropComplique/mtcnn-pytorch" target="_blank" rel="noopener">pytorch</a>、<a href="https://github.com/AITTSMD/MTCNN-Tensorflow" target="_blank" rel="noopener">tensorflow</a>、<a href="https://github.com/Seanlinx/mtcnn" target="_blank" rel="noopener">mxnet</a></p><p>MTCNN 《<a href="https://kpzhang93.github.io/MTCNN_face_detection_alignment/paper/spl.pdf" target="_blank" rel="noopener">Joint Face Detection and Alignment using Multi-task Cascaded Convolutional Networks</a>》,采用级联CNN结构，通过多任务学习，同时完成—人脸检测和人脸对齐，输出人脸的BoundingBox和人脸5个关键点（双眼、鼻子、双嘴角）的位置。</p><p>MTCNN在提出时在<a href="http://vis-www.cs.umass.edu/fddb/" target="_blank" rel="noopener">FDDB</a>、<a href="http://mmlab.ie.cuhk.edu.hk/projects/WIDERFace/" target="_blank" rel="noopener">WIDER FACE</a>和AFLW数据集上取得了当时(2016年4月)的<strong>SOTA</strong>速度又快，现在仍被广泛使用作为人脸识别的前端，如InsightFace和facenet。</p><p>论文提到，MTCNN的效果主要来自3个主要原因：</p><blockquote><p>1.精心设计的级联CNN结构（carefully designed cascaded CNNs architecture）</p><p>2.在线难样本挖掘策略（online hard sample mining strategy）</p><p>3.人脸检测与对其联合学习（joint face alignment learning）</p></blockquote><p> <strong>Tips：</strong>个人建议在看这篇文章的时候，对照着<a href="https://github.com/TropComplique/mtcnn-pytorch" target="_blank" rel="noopener">pytorch</a>的实现代码理解，尤其是里面的 <a href="https://github.com/TropComplique/mtcnn-pytorch/blob/master/try_mtcnn_step_by_step.ipynb" target="_blank" rel="noopener">try_mtcnn_step_by_step.ipynb</a>非常有助于理解整个文章的流程。 </p><h1 id="算法流程（概略）"><a href="#算法流程（概略）" class="headerlink" title="算法流程（概略）"></a>算法流程（概略）</h1><p><strong>Inference阶段</strong></p><p><strong>图像金字塔</strong></p><blockquote><p>1、对于给定的输入图像进行scale操作， 得到若干个不同scale的输入图像，这一步的目的是能够针对不同大小人脸进行候选框的检测。</p></blockquote><p><strong>P-Net</strong></p><blockquote><p>2.1、将不同scale的图像输入到P-Net中。</p><p>2.2、 设定阈值，根据face classification的结果，选出可能含有目标框的点 。</p><p>2.3、 将这些在不同尺度下可能是目标框的点映射到原始没有经过scale的图中，得到了很多候选区域。 </p><p>2.4、 使用nms算法对目标框进行筛选，并且根据P-Net中输出的offset（对应bounding box regression）对候选框进行微调，校准。 </p></blockquote><p><strong>R-Net</strong></p><blockquote><p>3、 将上一步得到所有候选框提取出来，并resize到24*24的大小，输入至R-Net中，并根据face classification的值，进一步对候选进行筛选，类似于2-4中的操作，对目标框位置进行筛选校准 </p></blockquote><p><strong>O-Net</strong></p><blockquote><p>4、 类似于第3步的操作，进一步对目标框进行筛选，并得到最终的输出结果，并且根据Facial landmark的输出得到5个landmark。 </p><p>PS: 在P-Net和R-Net中，都没有输出Facial landmark localization，只在最终的O-Net中输出了 。</p></blockquote><h1 id="算法流程（详解）"><a href="#算法流程（详解）" class="headerlink" title="算法流程（详解）"></a>算法流程（详解）</h1><p>MTCNN方法主要为：<strong>图像金字塔+3个级联CNN网络</strong>。</p><p>算法流程图如下所示：</p><p><img src="//loopvoid.github.io/2019/10/14/MTCNN算法与代码理解/pipeline.png" alt="pipeline"></p><h2 id="图像金字塔"><a href="#图像金字塔" class="headerlink" title="图像金字塔"></a>图像金字塔</h2><p><strong>图像金字塔(<a href="https://en.wikipedia.org/wiki/Pyramid_(image_processing" target="_blank" rel="noopener">image pyramid</a>))</strong>：主要是保证了多尺度的人脸数据的训练和检测（其中也有很多的trick）</p><p>Q：请问为什么输入PNET为什么是图片金字塔吗？能简单解释一下吗？ A：我的理解是:train的时候并不是图片金字塔，而是在predict或者说inference时是图片金字塔，因为训练的时候每个样本大小是12×12，而predict时是原图大小可能很大比如1920×1080，在图片中人脸占用像素可能200×200，这样使用训练好的模型去识别就识别不了，这时如果缩小图片使得人脸大概是12×12左右的话，就可以识别了。而由于我们并不知道实际原图中人脸大小是多少，也就不知道图片需要缩小多少倍，所以会按不同的比例缩放多种尺寸，形成图片金字塔，这样总有几种尺寸可以满足要求</p><p>3个阶段的级联的CNN网络作为主要的任务网络分别是<strong>P-Net,R-Net,O-Net</strong>，三个网络级联前一个网络的输出是后一个网络的输入，从而完成对人脸<strong>由粗到细(coarse-to-fine)</strong>的检测。并且可以看到随着<strong>网络层数逐渐加深</strong>，<strong>输入图像的尺寸（感受野）在逐渐变大12→24→48</strong>，<strong>最终输出的特征维数也在增加32→128→256</strong>，意味着利用的信息越来越多。</p><p><img src="//loopvoid.github.io/2019/10/14/MTCNN算法与代码理解/nets.png" alt="nets"></p><p>其中 <code>P-Net：Fast Proposal Network</code>，<code>R-Net：Refinement Network</code>，<code>O-Net：Output Network</code>，<code>MP：max pooling</code>，<code>Conv：convolution</code></p><h2 id="P-Net"><a href="#P-Net" class="headerlink" title="P-Net"></a>P-Net</h2><p>该网络的主要任务是获得人脸区域的<strong>候选窗口</strong>和<strong>边界框的回归向量</strong>。并用该边界框做回归，对候选窗口进行校准，然后通过非极大值抑制（NMS）来合并高度重叠的候选框。该网络是整个网络的起始输入端，是一个<strong>全卷积神经网络(<a href="https://www.dogedoge.com/rd/ewRpxetiNIuimF6YaBgH13FvU2Re6VBxbkb3XYTg8VhOLWAUP62tfXkOt32sV7BJyqqVSYQRgH6eklGRNjca31uN2Kvhjh2%2Bhw6gC9S7Hbg%3D" target="_blank" rel="noopener">FNC</a>)</strong>，前向传播得到的特征图在每个位置是个32维的特征向量，用于判断每个位置处约12×12大小的区域内是否包含人脸，如果包含人脸，则回归出人脸的Bounding Box，进一步获得Bounding Box对应到原图中的区域，通过<strong><a href="http://www.vision.ee.ethz.ch/publications/papers/proceedings/eth_biwi_01126.pdf" target="_blank" rel="noopener">NMS</a></strong>保留分数最高的Bounding box以及移除重叠区域过大的Bounding Box。</p><h3 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h3><p>P-Net的网络结构是一个<strong>全卷积神经网络</strong>的网络结构。</p><blockquote><p>FCN（全卷积神经网络）</p><p>全卷积网络就是去除了传统卷积网络的全连接层，然后对其进行反卷积对最后一个卷积层（或者其他合适的卷积层）的feature map进行上采样，使其恢复到原有图像的尺寸（或者其他），并对反卷积图像的每个像素点都可以进行一个类别的预测，同时保留了原有图像的空间信息。同时，在反卷积对图像进行操作的过程中，也可以通过提取其他卷积层的反卷积结果对最终图像进行预测，合适的选择会使得结果更好、更精细。</p><p><strong>输入(Input)可以是任意大小的图片</strong></p></blockquote><p>输入是一个$12\times 12$大小的图片，所以训练前需要把生成的训练数据(通过生成bounding box，然后把该bounding box 剪切成$12\times 12$大小的图片)，转换成$12\times 12\times 3$的结构。</p><p>1.通过10个$3\times 3\times 3$的卷积核，$2\times 2$的Max Pooling(stride=2)操作，生成10个$5\times 5$的特征图。</p><p>2.通过16个$3\times 3\times 10$的卷积核，生成16个$3\times 3$的特征图。</p><p>3.通过32个$3\times 3\times 16$的卷积核，生成32个$1\times 1$的特征图</p><p>4.针对32个$1\times 1$的特征图</p><ul><li>通过2个$1\times 1\times 32$的卷积核，生成2个$1\times 1$的特征图用于人脸的分类；</li><li>通过4个$1\times 1\times 32$的卷积核，生成4个$1\times 1$的特征图用于回归框判断；</li><li>通过10个$1\times 1\times 32$的卷积核，生成10个$1\times 1$的特征图用于人脸关键点的判断。</li></ul><h3 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h3><p><strong>1、</strong>P-Net 的层数很浅，主要作用是尽可能多的把人脸框都选进来，宁愿错误拿来好多个，也不丢掉一个。 </p><p><strong>2、</strong>P-Net的训练数据主要由4部分组成：其中比例为$pos:part:neg:landmark=1:1:3:2$</p><ul><li><code>pos</code>正label数据(IoU&gt;0.65，面部Landmark特征值为0)</li><li><code>neg</code>负label数据(IoU&lt;0.40，面部Landmark特征值为0，回归框值为0)</li><li><code>part</code>中间数据(0.40&lt;IoU&lt;0.65，面部Landmark特征值为0)</li><li><code>landmark</code>面部Landmark数据（回归框值为0)</li></ul><p><strong>3、</strong>训练数据的由来：</p><p>pos,part,neg是随机和人脸的数据裁剪得到的，裁剪图片与人脸框最大的iou值大于0.65的为pos图像，大于0.4的为part图像，小于0.4的为neg图像，landmark截取的是带有关键点的图像。</p><ul><li><p>pos,part的label含有它们的类别1,-1还有人脸框相对于图像左上角的偏移量，偏移量除以图像大小做了归一化;</p></li><li><p>neg的label只含有类别0;</p></li><li><p>landmark的label含有类别-2和5个关键点的坐标偏移也是进行了归一化的。 </p><p>这四种图像都resize成$12\times 12$作为PNet的输入，通过P-Net得到了是否有人脸的概率[batch,2]，人脸框的偏移量[batch,4]，关键点的偏移量[batch,10]。 </p></li></ul><p><strong>4、</strong>四种不同数据的训练方式：</p><ul><li>对于是否存在人脸的类别损失只通过neg和pos数据来对参数进行更新，具体办法是通过label中的类别值做了一个遮罩来划分数据，只计算neg和pos的损失，不计算其他数据的损失; </li><li>人脸框的损失只计算pos和part数据的; </li><li>关键点的损失只计算landmark的 </li><li><strong>Tips: Online Hard Example Mining(OHEM)</strong>在训练过程中，对每个mini-batch，取loss最大的70%进行反向传播，忽略那些简单的样本。说是模型准确率会有提升，在代码中也都有体现，具体实现可以参考代码。</li></ul><h2 id="R-Net"><a href="#R-Net" class="headerlink" title="R-Net"></a>R-Net</h2><p>该网络的主要任务还是通过边界框回归和NMS来去掉那些false-positive区域。该网络是单纯的卷积神经网络(CNN)，先将P-Net认为可能包含人脸的Bounding Box <strong>双线性插值</strong>到24×24，输入<strong>R-Net</strong>，判断是否包含人脸，如果包含人脸，也回归出Bounding Box，同样经过NMS过滤。只是由于该网络结构和P-Net网络结构有差异，多了一个全连接层，所以会取得更好的抑制false-positive的作用。</p><h2 id="O-Net"><a href="#O-Net" class="headerlink" title="O-Net"></a>O-Net</h2><p>该网络的主要任务是对人脸区域进行了更多的监督，同时输出5个人脸landmark。该网络也是单纯的卷积神经网络(CNN)，该网络比<strong>R-Net</strong>又多了一层卷基层，所以处理的结果会更加精细。作用和<strong>R-Net</strong>层作用一样，并输出5个人脸landmark。</p><h2 id="Face-classification"><a href="#Face-classification" class="headerlink" title="Face classification"></a>Face classification</h2><p>人脸的检测可以看作是一个局部二分类问题（该区域存在/不存在人脸）。</p><p>MTCNN采用的是交叉熵作为loss：</p><script type="math/tex; mode=display">L_i^{det}=-(y_i^{det}log(p_i)+(1-y_i^{det})(1-log(p_i)))</script><p>其中，$p_i$为该网络表示样本$x_i$是人脸的概率，$y_i^{det}\in \{0,1\}$为该区域的真实标签。</p><h2 id="Bounding-box-regression"><a href="#Bounding-box-regression" class="headerlink" title="Bounding box regression"></a>Bounding box regression</h2><p>MTCNN通过每个样本$x_i$的欧氏距离作回归损失：</p><script type="math/tex; mode=display">L_i^{box}=||\hat y_i^{box}-y_i^{box}||_2^2</script><p>其中，$\hat y_i^{box}$为对于第$i$个样本该网络预测得到的回归目标，$y_i^{box}$为第$i$个样本实际的真实的背景坐标。其中$y_i$为(左上角x，左上角y，长，宽)/(left,top,height,width)组成的四元组。</p><p>在训练过程中，$\hat y_i^{box}$和$y_i^{box}$的交并集IoU(<a href="https://loopvoid.github.io/2019/10/13/IoU-Intersection-over-Union/">Intersection-over-Union</a>)比例为：</p><div class="table-container"><table><thead><tr><th>训练样本比例</th><th>负样本：正样本：part样本:Landmark = 3:1:1:2</th></tr></thead><tbody><tr><td>非人脸</td><td>(0，0.3)</td></tr><tr><td>Part人脸</td><td>(0.4，0.65)</td></tr><tr><td>人脸</td><td>(0.65，1.00)</td></tr><tr><td>Landmark</td><td>(0.3，0.4)</td></tr></tbody></table></div><h2 id="Facial-Landmark-Localization"><a href="#Facial-Landmark-Localization" class="headerlink" title="Facial Landmark Localization"></a>Facial Landmark Localization</h2><p>与bounding box regression任务类似人脸特征点定位也是一个回归问题采用同样的欧式距离作为loss：</p><script type="math/tex; mode=display">L_i^{landmark}=||\hat y_i^{landmark}-y_i^{landmark}||_2^2</script><p>其中，$\hat y_i^{landmark}$为对于第$i$个样本该网络预测得到的回归目标，$y_i^{landmark}$为第$i$个样本实际的真实的坐标。人脸特征点包括（left eye, right eye, nose, left mouse corner, right mouse corner），即$y_i^{landmark}\in \mathbb{R}^{10}$.</p><h2 id="Multi-source-training"><a href="#Multi-source-training" class="headerlink" title="Multi-source training"></a>Multi-source training</h2><p>整个训练可以表示为：</p><script type="math/tex; mode=display">min\sum _{i=1}^N\sum _{j\in \{det,box,landmark\}}\alpha _j\beta_i^jL_i^j，\beta_i^j\in\{0,1\}</script><script type="math/tex; mode=display">P-Net,R-Net: (\alpha _{det}=1，\alpha _{box}=0.5，\alpha _{landmark}=0.5)</script><script type="math/tex; mode=display">O-Net：(\alpha_{det}=1，\alpha_{box}=0.5，\alpha_{landmark}=1)</script><p>其中，<strong>N</strong>为训练样本数，$\alpha_j$为任务的重要性，$\beta_j$为样本标签，$L_j$为前面三个任务（face classification、bounding box regression、facial landmark localization）对应的loss函数。</p><p>在<strong>训练阶段</strong>，3个网络都会将关键点位置作为监督信号来引导网络的学习， 但在<strong>预测阶段</strong>，P-Net和R-Net仅做人脸检测，不输出关键点位置（因为这时人脸检测都是不准的），关键点位置仅在O-Net中输出。</p><p><strong>Bounding box</strong>和<strong>关键点</strong>输出均为<strong>归一化后的相对坐标</strong>，Bounding Box是相对待检测区域（R-Net和O-Net是相对输入图像），归一化是相对坐标除以检测区域的宽高，关键点坐标是相对Bounding box的坐标，归一化是相对坐标除以Bounding box的宽高，这里先建立起初步的印象，具体可以参看后面准备训练数据部分和预测部分的代码细节。</p><h1 id="优点-改进"><a href="#优点-改进" class="headerlink" title="优点(改进)"></a>优点(改进)</h1><ul><li>减少卷积核数量（每层内部）</li><li>将$5\times5$的卷积核替换为$3\times3$，并增加网络深度 </li><li>在线难样本挖掘（Online hard sample mining）<ul><li>传统的难样本的处理方法是检测过一次以后，手动检测哪些困难的样本无法被分类，本文采用online hard sample mining的方法。具体就是在每个mini-batch中，取loss最大的70%进行反向传播，忽略那些简单的样本。</li></ul></li><li>人脸检测和对齐联合学习（joint face detecion and alignment）</li></ul><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p><a href="https://github.com/loopvoid/mtcnn" target="_blank" rel="noopener">mtcnn人脸检测</a></p><h1 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h1><p>环境：<br>Intel(R) Core(TM) i7-4790K CPU @ 4.00GHz<br>Logitech HD Pro Webcam c920<br>图像大小：640*640<br>效果：(compressed gif)<br><img src="//loopvoid.github.io/2019/10/14/MTCNN算法与代码理解/mtcnn.gif" alt="mtcnn"></p><hr><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://kpzhang93.github.io/MTCNN_face_detection_alignment/paper/spl.pdf" target="_blank" rel="noopener">Joint Face Detection and Alignment using Multi-task Cascaded Convolutional Networks</a><br><a href="https://www.cnblogs.com/shine-lee/p/10115582.html" target="_blank" rel="noopener">https://www.cnblogs.com/shine-lee/p/10115582.html</a><br><a href="https://zhuanlan.zhihu.com/p/31913064" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/31913064</a><br><a href="https://www.cnblogs.com/shine-lee/p/10115582.html" target="_blank" rel="noopener">https://www.cnblogs.com/shine-lee/p/10115582.html</a><br><a href="https://blog.csdn.net/qq_14845119/article/details/52680940" target="_blank" rel="noopener">https://blog.csdn.net/qq_14845119/article/details/52680940</a><br><a href="http://www.sfinst.com/?p=1683" target="_blank" rel="noopener">http://www.sfinst.com/?p=1683</a><br><a href="https://blog.csdn.net/qq_36782182/article/details/83624357" target="_blank" rel="noopener">https://blog.csdn.net/qq_36782182/article/details/83624357</a></p><p>训练：<br><a href="https://github.com/dlunion/mtcnn/tree/master/train" target="_blank" rel="noopener">https://github.com/dlunion/mtcnn/tree/master/train</a><br><a href="https://www.cnblogs.com/helloworld0604/p/9808795.html" target="_blank" rel="noopener">https://www.cnblogs.com/helloworld0604/p/9808795.html</a><br><a href="https://joshua19881228.github.io/2018-09-11-training-mtcnn/" target="_blank" rel="noopener">https://joshua19881228.github.io/2018-09-11-training-mtcnn/</a><br><a href="https://github.com/dlunion/mtcnn" target="_blank" rel="noopener">https://github.com/dlunion/mtcnn</a><br><a href="https://github.com/BobLiu20/mtcnn_tf" target="_blank" rel="noopener">https://github.com/BobLiu20/mtcnn_tf</a></p><p>实现<br><a href="https://github.com/imistyrain/MTCNN/blob/master/MTCNN-light/src/main.cpp" target="_blank" rel="noopener">https://github.com/imistyrain/MTCNN/blob/master/MTCNN-light/src/main.cpp</a><br><a href="https://github.com/cpuimage/MTCNN" target="_blank" rel="noopener">https://github.com/cpuimage/MTCNN</a><br><a href="https://github.com/AITTSMD/MTCNN-Tensorflow/blob/master/train_models/mtcnn_model.py" target="_blank" rel="noopener">https://github.com/AITTSMD/MTCNN-Tensorflow/blob/master/train_models/mtcnn_model.py</a><br><a href="https://github.com/davidsandberg/facenet/blob/master/src/align/detect_face.py" target="_blank" rel="noopener">https://github.com/davidsandberg/facenet/blob/master/src/align/detect_face.py</a><br><a href="https://github.com/TropComplique/mtcnn-pytorch" target="_blank" rel="noopener">https://github.com/TropComplique/mtcnn-pytorch</a><br><a href="https://github.com/LeslieZhoa/tensorflow-MTCNN" target="_blank" rel="noopener">https://github.com/LeslieZhoa/tensorflow-MTCNN</a><br><a href="https://github.com/imistyrain/MTCNN" target="_blank" rel="noopener">https://github.com/imistyrain/MTCNN</a><br><a href="https://github.com/davidsandberg/facenet" target="_blank" rel="noopener">https://github.com/davidsandberg/facenet</a><br><a href="https://github.com/AlphaQi/MTCNN-light" target="_blank" rel="noopener">https://github.com/AlphaQi/MTCNN-light</a><br><a href="https://github.com/BobLiu20/mtcnn_tf" target="_blank" rel="noopener">https://github.com/BobLiu20/mtcnn_tf</a><br><a href="https://github.com/LucyLu-LX/MTCNN_face_detection_caffe" target="_blank" rel="noopener">https://github.com/LucyLu-LX/MTCNN_face_detection_caffe</a><br><a href="https://github.com/pangyupo/mxnet_mtcnn_face_detection" target="_blank" rel="noopener">https://github.com/pangyupo/mxnet_mtcnn_face_detection</a><br><a href="https://github.com/Longqi-S/ncnn-mtcnn" target="_blank" rel="noopener">https://github.com/Longqi-S/ncnn-mtcnn</a><br><a href="https://github.com/githublet/mtcnn/blob/master/caffemodel2txt/caffemodel2txt.py" target="_blank" rel="noopener">https://github.com/githublet/mtcnn/blob/master/caffemodel2txt/caffemodel2txt.py</a> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;原作主页&lt;/strong&gt;：&lt;a href=&quot;https://kpzhang93.github.io/MTCNN_face_
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>IoU(Intersection over Union)</title>
    <link href="https://loopvoid.github.io/2019/10/13/IoU-Intersection-over-Union/"/>
    <id>https://loopvoid.github.io/2019/10/13/IoU-Intersection-over-Union/</id>
    <published>2019-10-13T14:17:39.000Z</published>
    <updated>2019-10-14T14:26:57.427Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>在目标检测中，我们需要定位出目标的位置，而我们的算法不可能百分百跟人工标注的数据完全匹配，因此需要一种衡量目标定位精度的标准。</p><p>IoU（Intersection over Union）是一种常见的用于衡量目标定位精度的标准，可以理解为重叠度，是一种简单的测量标准，只要是在输出中得出一个预测范围(bounding box)的任务都可以用IoU来进行测量。</p><p><img src="//loopvoid.github.io/2019/10/13/IoU-Intersection-over-Union/1.jpg" alt="1"></p><p>如上图所示，ground-truth和predicted的存在误差，绿色框是人为标记的正确结果，红色框是算法预测出来的结果，IoU要做的就是在这两个结果中测量算法的准确度，它定义了两个bounding box的重叠度 ，如下图所示：</p><p><img src="//loopvoid.github.io/2019/10/13/IoU-Intersection-over-Union/2.png" alt="2"></p><script type="math/tex; mode=display">IoU=\frac{A\bigcap B}{A\bigcup B}=\frac{A\bigcap B}{A+B-A\bigcap B}</script><p>就是矩形框A、B的重叠面积，占$A\bigcup B$的编辑的比例。</p><p><strong>一般来说，IoU&gt;0.5 就可以被认为一个不错的结果，IoU&gt;0.7 结果就非常不错了，可以参见下图</strong></p><p><img src="//loopvoid.github.io/2019/10/13/IoU-Intersection-over-Union/3.png" alt="3"></p><h1 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h1><p>因为IoU的思想很简单，Python实现可以参考[1]：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bb_intersection_over_union</span><span class="params">(boxA, boxB)</span>:</span></span><br><span class="line"><span class="comment"># determine the (x, y)-coordinates of the intersection rectangle</span></span><br><span class="line">xA = max(boxA[<span class="number">0</span>], boxB[<span class="number">0</span>])</span><br><span class="line">yA = max(boxA[<span class="number">1</span>], boxB[<span class="number">1</span>])</span><br><span class="line">xB = min(boxA[<span class="number">2</span>], boxB[<span class="number">2</span>])</span><br><span class="line">yB = min(boxA[<span class="number">3</span>], boxB[<span class="number">3</span>])</span><br><span class="line"> </span><br><span class="line"><span class="comment"># compute the area of intersection rectangle</span></span><br><span class="line">interArea = (xB - xA + <span class="number">1</span>) * (yB - yA + <span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># compute the area of both the prediction and ground-truth</span></span><br><span class="line"><span class="comment"># rectangles</span></span><br><span class="line">boxAArea = (boxA[<span class="number">2</span>] - boxA[<span class="number">0</span>] + <span class="number">1</span>) * (boxA[<span class="number">3</span>] - boxA[<span class="number">1</span>] + <span class="number">1</span>)</span><br><span class="line">boxBArea = (boxB[<span class="number">2</span>] - boxB[<span class="number">0</span>] + <span class="number">1</span>) * (boxB[<span class="number">3</span>] - boxB[<span class="number">1</span>] + <span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># compute the intersection over union by taking the intersection</span></span><br><span class="line"><span class="comment"># area and dividing it by the sum of prediction + ground-truth</span></span><br><span class="line"><span class="comment"># areas - the interesection area</span></span><br><span class="line">iou = interArea / float(boxAArea + boxBArea - interArea)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># return the intersection over union value</span></span><br><span class="line"><span class="keyword">return</span> iou</span><br></pre></td></tr></table></figure><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>[1] <a href="https://www.pyimagesearch.com/2016/11/07/intersection-over-union-iou-for-object-detection" target="_blank" rel="noopener">Intersection over Union (IoU) for object detection</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h1&gt;&lt;p&gt;在目标检测中，我们需要定位出目标的位置，而我们的算法不可能百
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>机器学习的数学基础</title>
    <link href="https://loopvoid.github.io/2019/09/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    <id>https://loopvoid.github.io/2019/09/26/机器学习的数学基础/</id>
    <published>2019-09-26T14:40:13.000Z</published>
    <updated>2019-11-17T11:06:04.959Z</updated>
    
    <content type="html"><![CDATA[<h1 id="机器学习的数学基础"><a href="#机器学习的数学基础" class="headerlink" title="机器学习的数学基础"></a>机器学习的数学基础</h1><h1 id="高等数学"><a href="#高等数学" class="headerlink" title="高等数学"></a>高等数学</h1><h2 id="导数定义："><a href="#导数定义：" class="headerlink" title="导数定义："></a><strong>导数定义：</strong></h2><p>导数和微分的概念</p><p>$f’(x_0)=lim_{\Delta x\to 0}\frac{f(x_0+\Delta x)-f(x_0)}{\Delta x}$</p><p>或者：</p><p>$f’(x_0)=lim_{x\to x_0}\frac{f(x)-f(x_0)}{x-x_0}$</p><h2 id="左右导数导数的几何意义和物理意义"><a href="#左右导数导数的几何意义和物理意义" class="headerlink" title="左右导数导数的几何意义和物理意义"></a><strong>左右导数导数的几何意义和物理意义</strong></h2><p>函数$f(x)$在$x_0$处的左、右导数分别定义为：</p><p>左导数：$f_-‘(x_0)=lim_{\Delta x\to 0^-}\frac{f(x_0+\Delta x)-f(x_0)}{\Delta x}=lim_{x\to x_0^-}\frac{f(x)-f(x_0)}{x-x_0},(x=x_0+\Delta x)$</p><p>右导数：$f_+’(x_0)=lim_{\Delta x\to 0^+}\frac{f(x_0+\Delta x)-f(x_0)}{\Delta x}=lim_{x\to x_0^+}\frac{f(x)-f(x_0)}{x-x_0}$</p><h2 id="函数的可导性与连续性之间的关系"><a href="#函数的可导性与连续性之间的关系" class="headerlink" title="函数的可导性与连续性之间的关系"></a><strong>函数的可导性与连续性之间的关系</strong></h2><p><strong>Th1:</strong> 函数$f(x)$在$x_0$处可微$\Leftrightarrow f(x)$在$x_0$处可导</p><p><strong>Th2:</strong> 若函数在点$x_0$处可导，则$y=f(x)$在点$x_0$处连续，反之则不成立。即函数连续不一定可导。</p><p><strong>Th3:</strong> $f’(x_0)$存在$\Leftrightarrow f’_-(x_0))=f’_+(x_0)$</p><h2 id="平面曲线的切线和法线"><a href="#平面曲线的切线和法线" class="headerlink" title="平面曲线的切线和法线"></a><strong>平面曲线的切线和法线</strong></h2><p>切线方程 : $y-y_0=f’(x_0)(x-x_0)$<br>法线方程：$y-y_0=-\frac{1}{f’(x_0)}(x-x_0),f’(x_0)\ne 0$</p><h2 id="四则运算法则"><a href="#四则运算法则" class="headerlink" title="四则运算法则"></a><strong>四则运算法则</strong></h2><p>设函数$u=u(x)，v=v(x)$]在点$x$可导则<br>(1) $(u\pm v{)}’={u}’\pm {v}’ \ \ \ \ \ d(u\pm v)=du\pm dv$<br>(2)$(uv{)}’=u{v}’+v{u}’$        $d(uv)=udv+vdu$<br>(3) $(\frac{u}{v}{)}’=\frac{v{u}’-u{v}’}{v^2}(v\ne 0) \ \ \ \ \ d(\frac{u}{v})=\frac{vdu-udv}{v^2}$</p><h2 id="基本导数与微分表"><a href="#基本导数与微分表" class="headerlink" title="基本导数与微分表"></a><strong>基本导数与微分表</strong></h2><p>(1) $y=c$（常数）       $y’=0$          $dy=0$</p><p>(2) $y=x^\alpha$($\alpha $为实数)    ${y}’=\alpha x^{\alpha -1}$      $dy=\alpha x^{\alpha -1}dx$</p><p>(3) $y=a^x$      ${y}’=a^x\ln a$         $dy=a^x\ln adx$<br>  特例:   $(e^x)’=e^x       \ \ \ \ \ \ \      d(e^x)=e^xdx$</p><p>(4) $y=\log _ax$   $y’=\frac{1}{x\ln a}$<br>$dy=\frac{1}{x\ln a}dx$<br>特例:$y=\ln x  \   \   \  \  \   \  (\ln x)’=\frac{1}{x}  \ \ \ \ \ \     d(\ln x)=\frac{1}{x}dx$</p><p>(5) $y=\sin x$<br>${y}’=\cos x$        $d(\sin x)=\cos xdx$</p><p>(6) $y=\cos x$<br>${y}’=-\sin x \ \ \ \ \ d(\cos x)=-\sin xdx$</p><p>(7) $y=\tan x$<br>${y}’=\frac{1}{\cos ^2x}={\sec ^2}x \  \ \ \ \  d(\tan x)=\sec ^2xdx$</p><p>(8) $y=\cot x \ \ \ \ \ {y}’=-\frac{1}{\sin ^2x}=-\csc ^2x \ \ \ \ \ d(\cot x)=-\csc ^2xdx$</p><p>(9) $y=\sec x \ \ \ \ \ y’=\sec x\tan x$<br> $d(\sec x)=\sec x\tan xdx$</p><p>(10) $y=\csc x \ \ \ \ \ y’=-\csc x\cot x$<br>$d(\csc x)=-\csc x\cot xdx$</p><p>(11) $y=\arcsin x$<br>${y}’=\frac{1}{\sqrt{1-x^2}}$<br>$d(\arcsin x)=\frac{1}{\sqrt{1-x^2}}dx$</p><p>(12) $y=\arccos x$<br>${y}’=-\frac{1}{\sqrt{1-x^2}}$     $d(\arccos x)=-\frac{1}{\sqrt{1-x^2}}dx$</p><p>(13) $y=\arctan x$<br>$y’=\frac{1}{1+x^2}$     $d(\arctan x)=\frac{1}{1+x^2}dx$</p><p>(14) $y=\operatorname{arc}\cot x$<br>${y}’=-\frac{1}{1+x^2}$<br>$d(\operatorname{arc}\cot x)=-\frac{1}{1+x^2}dx$</p><p>(15) $y=shx$<br>${y}’=chx \ \ \ \ \ d(shx)=chxdx$</p><p>(16) $y=chx$<br>${y}’=shx \ \ \ \ \ d(chx)=shxdx$</p><h2 id="复合函数，反函数，隐函数以及参数方程所确定的函数的微分法"><a href="#复合函数，反函数，隐函数以及参数方程所确定的函数的微分法" class="headerlink" title="复合函数，反函数，隐函数以及参数方程所确定的函数的微分法"></a><strong>复合函数，反函数，隐函数以及参数方程所确定的函数的微分法</strong></h2><p>(1) 反函数的运算法则: 设$y=f(x)$在点$x$的某邻域内单调连续，在点$x$处可导且$f’(x)\ne 0$，则其反函数在点$x$所对应的$y$处可导，并且有$\frac{dy}{dx}=\frac{1}{\frac{dx}{dy}}$<br>(2) 复合函数的运算法则:若$\mu =\varphi (x)$在点$x$可导,而$y=f(\mu )$在对应点$\mu(\mu =\varphi (x))$可导,则复合函数$y=f(\varphi (x))$在点$x$可导,且$y’=f’(\mu )\cdot \varphi ‘(x)$<br>(3) 隐函数导数$\frac{dy}{dx}$的求法一般有三种方法：<br>1)方程两边对$x$求导，要记住$y$是$x$的函数，则$y$的函数是$x$的复合函数.例如$\frac{1}{y}$，$y^2$，$ln y$，$e^y$等均是$x$的复合函数.<br>对$x$求导应按复合函数连锁法则做.<br>2)公式法.由$F(x,y)=0$知 $\frac{dy}{dx}=-\frac{F’_x(x,y)}{F’_y(x,y)}$,其中，$F’_x(x,y)$，<br>$F’_y(x,y)$分别表示$F(x,y)$对$x$和$y$的偏导数<br>3)利用微分形式不变性</p><h2 id="常用高阶导数公式"><a href="#常用高阶导数公式" class="headerlink" title="常用高阶导数公式"></a><strong>常用高阶导数公式</strong></h2><p>（1）$(a^x)^{(n)}=(a^x){\ln }^na\quad (a&gt;{0})\quad \quad (e^x)^{(n)}=e^{x}$<br>（2）$(\sin kx)^{(n)}=k^n\sin (kx+n\cdot \frac{\pi }{2})$<br>（3）$(\cos kx)^{(n)}=k^{n}\cos (kx+n\cdot \frac{\pi }{2})$<br>（4）$(x^m)^{(n)}=m(m-1)\cdots (m-n+1)x^{m-n}$<br>（5）$(\ln x)^n=(-1)^{(n-1)}\frac{(n-1)!}{x^n}$<br>（6）莱布尼兹公式：若$u(x),v(x)$均$n$阶可导，则<br> $(uv)^{(n)}=\sum\limits_{i=0}^nc_n^iu^{(i)}v^{(n-i)}$，其中$u^{(0)}=u$，$v^{(0)}=v$</p><h2 id="微分中值定理，泰勒公式"><a href="#微分中值定理，泰勒公式" class="headerlink" title="微分中值定理，泰勒公式"></a><strong>微分中值定理，泰勒公式</strong></h2><p><strong>Th1:</strong>(费马定理)</p><p>若函数$f(x)$满足条件：<br>(1)函数$f(x)$在$x_0$的某邻域内有定义，并且在此邻域内恒有<br>$f(x)\le f(x_0)$或$f(x)\ge f(x_0)$,</p><p>(2) $f(x)$在$x_0$处可导,则有 $f’(x_0)=0$</p><p><strong>Th2:</strong>(罗尔定理) </p><p>设函数$f(x)$满足条件：<br>(1)在闭区间$[a,b]$上连续；</p><p>(2)在$(a,b)$内可导；</p><p>(3)$f(a)=f(b)$；</p><p>则在$(a,b)$内一存在个$\xi $，使  $f’(\xi )=0$<br><strong>Th3:</strong> (拉格朗日中值定理) </p><p>设函数$f(x)$满足条件：<br>(1)在$[a,b]$上连续；</p><p>(2)在$(a,b)$内可导；</p><p>则在$(a,b)$内一存在个$\xi $，使  $\frac{f(b)-f(a)}{b-a}=f’(\xi )$</p><p><strong>Th4:</strong> (柯西中值定理)</p><p> 设函数$f(x)$，$g(x)$满足条件：<br>(1) 在$[a,b]$上连续；</p><p>(2) 在$(a,b)$内可导且$f’(x)$，$g’(x)$均存在，且$g’(x)\ne 0$</p><p>则在$(a,b)$内存在一个$\xi $，使  $\frac{f(b)-f(a)}{g(b)-g(a)}=\frac{f’(\xi )}{g’(\xi )}$</p><h2 id="洛必达法则"><a href="#洛必达法则" class="headerlink" title="洛必达法则"></a><strong>洛必达法则</strong></h2><p>法则Ⅰ ($\frac{0}{0}$型)<br>设函数$f(x),g(x)$满足条件：<br>$lim_{x\to x_0}f(x)=0,lim_{x\to x_0}g(x)=0$;<br>$f(x),g(x)$在$x_0$的邻域内可导，(在$x_0$处可除外)且$g’(x)\ne 0$;<br>$lim_{x\to x_0}\frac{f’(x)}{g’(x)}$存在(或$\infty $)。<br>则:<br>$lim_{x\to x_0}\frac{f(x)}{g(x)}=lim_{x\to x_0}\frac{f’(x)}{g’(x)}$。<br>法则$I’$ ($\frac{0}{0}$型)设函数$f(x),g(x)$满足条件：<br>$lim_{x\to \infty }f(x)=0,lim_{x\to \infty }g(x)=0$;<br>存在一个$X&gt;0$,当$|x|&gt;X$时,$f(x),g(x)$可导,且${g}’(x)\ne 0$;$lim_{x\to x_0}\frac{f’(x)}{g’(x)}$存在(或$\infty $)。<br>则:<br>$lim_{x\to x_0}\frac{f(x)}{g(x)}=lim_{x\to x_0}\frac{f’(x)}{g’(x)}$</p><p>法则Ⅱ($\frac{\infty }{\infty }$型)<br>设函数$f(x),g(x)$满足条件：<br>$lim_{x\to x_0}f(x)=\infty ,lim_{x\to x_0}g(x)=\infty $;<br>$f(x),g(x)$在$x_0$ 的邻域内可导(在$x_0$处可除外)且$g’(x)\ne 0$;$lim_{x\to x_0}\frac{f’(x)}{g’(x)}$存在(或$\infty $)。则<br>$lim_{x\to x_0}\frac{f(x)}{g(x)}=lim_{x\to x_0}\frac{f’(x)}{g’(x)}.$同理法则${II’}$($\frac{\infty }{\infty }$型)仿法则${I’}$可写出。</p><h2 id="泰勒公式"><a href="#泰勒公式" class="headerlink" title="泰勒公式"></a><strong>泰勒公式</strong></h2><p>设函数$f(x)$在点$x_0$处的某邻域内具有$n+1$阶导数，则对该邻域内异于$x_0$的任意点$x$，在$x_0$与$x$之间至少存在<br>一个$\xi $，使得：<br>$f(x)=f(x_0)+f’(x_0)(x-x_0)+\frac{1}{2!}f’’(x_0)(x-x_0)^2+\cdots +\frac{f^{(n)}(x_0)}{n!}(x-x_0)^n+R_n(x)$ 其中<br> $R_n(x)=\frac{f^{(n+1)}(\xi )}{(n+1)!}(x-x_0)^{n+1}$称为$f(x)$在点$x_0$处的$n$阶泰勒余项。<br>令$x_0=0$，则$n$阶泰勒公式<br>$f(x)=f(0)+f’(0)x+\frac{1}{2!}f’’(0)x^2+\cdots +\frac{f^{(n)}(0)}{n!}x^n+R_n(x) \ \ \ 麦克劳林公式$<br>其中 $R_n(x)=\frac{f^{(n+1)}(\xi )}{(n+1)!}x^{n+1}$，$\xi $在0与$x$之间.</p><p><strong>常用五种函数在${x_0}=0$处的泰勒公式</strong></p><p>(1) $e^x=1+x+\frac{1}{2!}x^2+\cdots +\frac{1}{n!}x^n+\frac{x^{n+1}}{(n+1)!}e^{\xi }$<br>或 $=1+x+\frac{1}{2!}x^2+\cdots +\frac{1}{n!}x^n+o(x^n)$</p><p>(2) $\sin x=x-\frac{1}{3!}x^3+\cdots +\frac{x^n}{n!}\sin \frac{n\pi }{2}+\frac{x^{n+1}}{(n+1)!}\sin (\xi +\frac{n+1}{2}\pi )$<br>或 $=x-\frac{1}{3!}x^3+\cdots +\frac{x^n}{n!}\sin \frac{n\pi }{2}+o(x^n)$</p><p>(3) $\cos x=1-\frac{1}{2!}x^2+\cdots +\frac{x^n}{n!}\cos \frac{n\pi }{2}+\frac{x^{n+1}}{(n+1)!}\cos (\xi +\frac{n+1}{2}\pi )$<br>或 $=1-\frac{1}{2!}x^2+\cdots +\frac{x^n}{n!}\cos \frac{n\pi }{2}+o(x^n)$</p><p>(4) $\ln (1+x)=x-\frac{1}{2}x^2+\frac{1}{3}x^3-\cdots +(-1)^{n-1}\frac{x^n}{n}+\frac{(-1)^nx^{n+1}}{(n+1)(1+\xi )^{n+1}}$<br>或 $=x-\frac{1}{2}x^2+\frac{1}{3}x^3-\cdots +(-1)^{n-1}\frac{x^n}{n}+o(x^n)$</p><p>(5) $(1+x)^m=1+mx+\frac{m(m-1)}{2!}x^2+\cdots +\frac{m(m-1)\cdots (m-n+1)}{n!}x^n+\frac{m(m-1)\cdots (m-n+1)}{(n+1)!}x^{n+1}(1+\xi )^{m-n-1}$<br>或 $(1+x)^m=1+mx+\frac{m(m-1)}{2!}x^2+\cdots $ $+\frac{m(m-1)\cdots (m-n+1)}{n!}x^n+o(x^n)$</p><h2 id="函数单调性的判断"><a href="#函数单调性的判断" class="headerlink" title="函数单调性的判断"></a><strong>函数单调性的判断</strong></h2><p><strong>Th1:</strong>  设函数$f(x)$在$(a,b)$区间内可导，如果对$\forall x\in (a,b)$，都有$f’(x)&gt;0$（或$f’(x)&lt;0$），则函数$f(x)$在$(a,b)$内是单调增加的（或单调减少）</p><p><strong>Th2:</strong> （取极值的必要条件）设函数$f(x)$在$x_0$处可导，且在$x_0$处取极值，则$f’(x_0)=0$。</p><p><strong>Th3:</strong> （取极值的第一充分条件）设函数$f(x)$在$x_0$的某一邻域内可微，且$f’(x_0)=0$（或$f(x)$在$x_0$处连续，但$f’(x_0)$不存在。）<br>(1)若当$x$经过$x_0$时，$f’(x)$由“+”变“-”，则$f(x_0)$为极大值；<br>(2)若当$x$经过$x_0$时，$f’(x)$由“-”变“+”，则$f(x_0)$为极小值；<br>(3)若$f’(x)$经过$x=x_0$的两侧不变号，则$f(x_0)$不是极值。</p><p><strong>Th4:</strong> (取极值的第二充分条件)设$f(x)$在点$x_0$处有$f’’(x)\ne 0$，且$f’(x_0)=0$，则 当$f’’(x_0)<0$时，$f(x_0)$为极大值； 当$f''(x_0)>0$时，$f(x_0)$为极小值。<br>注：如果$f’’(x_0)&lt;0$，此方法失效。</0$时，$f(x_0)$为极大值；></p><h2 id="渐近线的求法"><a href="#渐近线的求法" class="headerlink" title="渐近线的求法"></a><strong>渐近线的求法</strong></h2><p>(1)水平渐近线   若$lim_{x\to +\infty }f(x)=b$，或$lim_{x\to -\infty }f(x)=b$，则</p><p>$y=b$称为函数$y=f(x)$的水平渐近线。</p><p>(2)铅直渐近线   若$lim_{x\to x_0^-}f(x)=\infty $，或$lim_{x\to x_0^+}f(x)=\infty $，则</p><p>$x=x_0$称为$y=f(x)$的铅直渐近线。</p><p>(3)斜渐近线   若$a=lim_{x\to \infty }\frac{f(x)}{x},\quad b=lim_{x\to \infty }[f(x)-ax]$，则<br>$y=ax+b$称为$y=f(x)$的斜渐近线。</p><h2 id="函数凹凸性的判断"><a href="#函数凹凸性的判断" class="headerlink" title="函数凹凸性的判断"></a><strong>函数凹凸性的判断</strong></h2><p><strong>Th1:</strong> (凹凸性的判别定理）若在I上$f’’(x)<0$（或$f''(x)>0$），则$f(x)$在I上是凸的（或凹的）。</0$（或$f''(x)></p><p><strong>Th2:</strong> (拐点的判别定理1)若在$x_0$处$f’’(x)=0$，（或$f’’(x)$不存在），当$x$变动经过$x_0$时，$f’’(x)$变号，则$(x_0,f(x_0))$为拐点。</p><p><strong>Th3:</strong> (拐点的判别定理2)设$f(x)$在$x_0$点的某邻域内有三阶导数，且$f’’(x)=0$，$f’’’(x)\ne 0$，则$(x_0,f(x_0))$为拐点。</p><h2 id="弧微分"><a href="#弧微分" class="headerlink" title="弧微分"></a><strong>弧微分</strong></h2><p>$dS=\sqrt{1+y’^2}dx$</p><h2 id="曲率"><a href="#曲率" class="headerlink" title="曲率"></a><strong>曲率</strong></h2><p>曲线$y=f(x)$在点$(x,y)$处的曲率$k=\frac{|y’’|}{(1+y’^2)^{\tfrac{3}{2}}}$。</p><p>对于参数方程<br>$\left\{\begin{matrix}<br>x=\varphi (t)\\<br>y=\psi (t)<br>\end{matrix}\right.$$k=\frac{|\varphi(t)’\psi (t)’’-\varphi (t)’’\psi (t)’|}{[\varphi ‘^2(t)+\psi ‘^2(t)]^{\frac{3}{2}}}$</p><h2 id="曲率半径"><a href="#曲率半径" class="headerlink" title="曲率半径"></a><strong>曲率半径</strong></h2><p>曲线在点$M$处的曲率$k(k\ne 0)$与曲线在点$M$处的曲率半径$\rho $有如下关系：$\rho =\frac{1}{k}$。</p><h1 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h1><h2 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h2><p><strong>行列式按行（列）展开定理</strong></p><p>(1) 设$A=(a_{ij})_{n\times n}$，则：$a_{i1}A_{j1} +a_{i2}A_{j2} + \cdots + a_{in}A_{jn} = \begin{cases}|A|,i=j\\ 0,i \neq j\end{cases}$</p><p>或$a_{1i}A_{1j} + a_{2i}A_{2j} + \cdots + a_{ni}A_{nj} = \begin{cases}|A|,i=j\\ 0,i \neq j\end{cases}$即 $AA^<em>=A^</em>A = |A|E,$其中：$A^*= \begin{pmatrix} A_{11} &amp; A_{12} &amp; \ldots &amp; A_{1n} \\ A_{21} &amp; A_{22} &amp; \ldots &amp; A_{2n} \\ \ldots &amp; \ldots &amp; \ldots &amp; \ldots \\ A_{n1} &amp; A_{n2} &amp; \ldots &amp; A_{nn} \\ \end{pmatrix} = (A_{ji}) = {(A_{ij})}^{T}$</p><p>$D_{n} = \begin{vmatrix} 1 &amp; 1 &amp; \ldots &amp; 1 \\ x_{1} &amp; x_{2} &amp; \ldots &amp; x_{n} \\ \ldots &amp; \ldots &amp; \ldots &amp; \ldots \\ x_{1}^{n - 1} &amp; x_{2}^{n - 1} &amp; \ldots &amp; x_{n}^{n - 1} \\ \end{vmatrix} = \prod_{1 \leq j &lt; i \leq n}^{}\,(x_{i} - x_{j})$</p><p>(2) 设$A,B$为$n$阶方阵，则$\left| {AB} \right| = \left| A \right|\left| B \right| = \left| B \right|\left| A \right| = \left| {BA} \right|$，但$\left| A \pm B \right| = \left| A \right| \pm \left| B \right|$不一定成立。</p><p>(3) $\left| {kA} \right| = k^{n}\left| A \right|$,$A$为$n$阶方阵。</p><p>(4) 设$A$为$n$阶方阵，$|A^{T}| = |A|;|A^{- 1}| = |A|^{- 1}$（若$A$可逆），$|A^{*}| = |A|^{n - 1}$</p><p>$n \geq 2$</p><p>(5) $\left| \begin{matrix}  &amp; {A\quad O} \\  &amp; {O\quad B} \\ \end{matrix} \right| = \left| \begin{matrix}  &amp; {A\quad C} \\  &amp; {O\quad B} \\ \end{matrix} \right| = \left| \begin{matrix}  &amp; {A\quad O} \\  &amp; {C\quad B} \\ \end{matrix} \right| =| A||B|$<br>，$A,B$为方阵，但$\left| \begin{matrix} {O} &amp; A_{m \times m} \\  B_{n \times n} &amp; { O} \\ \end{matrix} \right| = ({- 1)}^|A||B|$ 。</p><p>(6) 范德蒙行列式$D_{n} = \begin{vmatrix} 1 &amp; 1 &amp; \ldots &amp; 1 \\ x_{1} &amp; x_{2} &amp; \ldots &amp; x_{n} \\ \ldots &amp; \ldots &amp; \ldots &amp; \ldots \\ x_{1}^{n - 1} &amp; x_{2}^{n 1} &amp; \ldots &amp; x_{n}^{n - 1} \\ \end{vmatrix} =  \prod_{1 \leq j &lt; i \leq n}^{}\,(x_{i} - x_{j})$</p><p>设$A$是$n$阶方阵，$\lambda_{i}(i = 1,2\cdots,n)$是$A$的$n$个特征值，则<br>$|A| = \prod_{i = 1}^{n}\lambda_{i}$</p><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><p>矩阵：$m \times n$个数$a_ij$排成$m$行$n$列的表格$\begin{bmatrix}  a_{11}\quad a_{12}\quad\cdots\quad a_{1n} \\ a_{21}\quad a_{22}\quad\cdots\quad a_{2n} \\ \quad\cdots\cdots\cdots\cdots\cdots \\  a_{m1}\quad a_{m2}\quad\cdots\quad a_{mn} \\ \end{bmatrix}$ 称为矩阵，简记为$A$，或者$\left( a_{ij} \right)_{m \times n}$ 。若$m = n$，则称$A$是$n$阶矩阵或$n$阶方阵。</p><p><strong>矩阵的线性运算</strong></p><p><strong>1.矩阵的加法</strong></p><p>设$A = (a_{ij}),B = (b_{ij})$是两个$m \times n$矩阵，则$m \times n$ 矩阵$C = c_{ij} = a_{ij} + b_{ij}$称为矩阵$A$与$B$的和，记为$A + B = C$ 。</p><p><strong>2.矩阵的数乘</strong></p><p>设$A = (a_{ij})$是$m \times n$矩阵，$k$是一个常数，则$m \times n$矩阵$(ka_{ij})$称为数$k$与矩阵$A$的数乘，记为${kA}$。</p><p><strong>3.矩阵的乘法</strong></p><p>设$A = (a_{ij})$是$m \times n$矩阵，$B = (b_{ij})$是$n \times s$矩阵，那么$m \times s$矩阵$C = (c_{ij})$，其中$c_{ij} = a_{i1}b_{1j} + a_{i2}b_{2j} + \cdots + a_{in}b_{nj} = \sum_{k =1}^na_{ik}b_{kj}$称为${AB}$的乘积，记为$C = AB$ 。</p><p><strong>4.</strong> $\mathbf{A}^{\mathbf T}$<strong>、</strong>$\mathbf{A}^{\mathbf -1}$<strong>、</strong>$\mathbf A^{\mathbf \star}$<strong>三者之间的关系</strong></p><p>(1) $(A^T)^T = A,(AB)^T = B^TA^T,(kA)^T = kA^T,{(A \pm B)}^T = A^T \pm B^T$</p><p>(2) $(A^{- 1})^{- 1} = A,(AB)^{- 1} = B^{- 1}A^{- 1},({kA})^{- 1} = \frac{1}{k}A^{- 1},$</p><p>但 ${(A \pm B)}^{- 1} = A^{- 1} \pm B^{- 1}$不一定成立。</p><p>(3) $(A^\star )^\star  = |A|^{n - 2}\ A\ \ (n \geq 3)$，$(AB)^\star  = B^\star A^\star ,$ $({kA})^\star  = k^{n -1}A^\star {\ \ }(n \geq 2)$</p><p>但$(A \pm B)^\star  = A^\star  \pm B^\star $不一定成立。</p><p>(4) $(A^{- 1})^T = (A^T)^{- 1},\ (A^{- 1})^\star  =(AA^\star )^{- 1},(A^\star )^T = (A^T)^\star $</p><p><strong>5.有关</strong>$\mathbf A^{\mathbf \star}$<strong>的结论</strong></p><p>(1) $AA^\star  = A^\star A = |A|E$</p><p>(2) $|A^\star | = |A|^{n -1}\ (n \geq 2),\ \ \ \ {(kA)}^\star  = k^{n -1}A^\star ,\ \ (A^\star )^\star  = |A|^{n - 2}A(n \geq 3)$</p><p>(3) 若$A$可逆，则$A^\star  = |A|A^{-1},(A^\star )^\star  = \frac{1}{|A|}A$(4) 若$A$为$n$阶方阵，则：</p><p>$r(A^*)=\begin{cases}n,\quad r(A)=n\\ 1,\quad r(A)=n-1\\ 0,\quad r(A)&lt;n-1\end{cases}$</p><p><strong>6.有关</strong>$\mathbf{A}^{\mathbf{-1}}$<strong>的结论</strong></p><p>$A$可逆$\Leftrightarrow AB = E; \Leftrightarrow |A| \neq 0; \Leftrightarrow r(A) = n;$</p><p>$\Leftrightarrow A$可以表示为初等矩阵的乘积；$\Leftrightarrow A;\Leftrightarrow Ax = 0$。</p><p><strong>7.有关矩阵秩的结论</strong></p><p>(1) 秩$r(A)$=行秩=列秩；</p><p>(2) $r(A_{m \times n}) \leq \min(m,n);$</p><p>(3) $A \neq 0 \Rightarrow r(A) \geq 1$；</p><p>(4) $r(A \pm B) \leq r(A) + r(B);$</p><p>(5) 初等变换不改变矩阵的秩</p><p>(6) $r(A) + r(B) - n \leq r(AB) \leq \min(r(A),r(B)),$特别若$AB = O$<br>则：$r(A) + r(B) \leq n$</p><p>(7) 若$A^{-1}$存在$\Rightarrow r(AB) = r(B);$ 若$B^{-1}$存在<br>$\Rightarrow r(AB) = r(A);$<br>若$r(A_{m \times n}) = n \Rightarrow r(AB) = r(B);$ 若$r(A_{m \times s}) = n\Rightarrow r(AB) = r(A)$。</p><p>(8) $r(A_{m \times s}) = n \Leftrightarrow Ax = 0$只有零解</p><p><strong>8.分块求逆公式</strong></p><p>$\begin{pmatrix} A &amp; O \\ O &amp; B \\ \end{pmatrix}^{-1} = \begin{pmatrix} A^{-1} &amp; O \\ O &amp; B^{-1} \\ \end{pmatrix}$； $\begin{pmatrix} A &amp; C \\ O &amp; B \\\end{pmatrix}^{-1} = \begin{pmatrix} A^{-1}&amp; - A^{-1}CB^{-1} \\ O &amp; B^{-1} \\ \end{pmatrix}$；</p><p>$\begin{pmatrix} A &amp; O \\ C &amp; B \\ \end{pmatrix}^{-1} = \begin{pmatrix}  A^{-1}&amp;{O} \\   - B^{-1}CA^{-1} &amp; B^{-1} \\\end{pmatrix}$； $\begin{pmatrix} O &amp; A \\ B &amp; O \\ \end{pmatrix}^{-1} =\begin{pmatrix} O &amp; B^{-1} \\ A^{-1} &amp; O \\ \end{pmatrix}$</p><p>这里$A$，$B$均为可逆方阵。</p><h2 id="向量"><a href="#向量" class="headerlink" title="向量"></a>向量</h2><p><strong>1.有关向量组的线性表示</strong></p><p>(1)$\alpha_{1},\alpha_{2},\cdots,\alpha_{s}$线性相关$\Leftrightarrow$至少有一个向量可以用其余向量线性表示。</p><p>(2)$\alpha_{1},\alpha_{2},\cdots,\alpha_{s}$线性无关，$\alpha_{1},\alpha_{2},\cdots,\alpha_{s}$，$\beta$线性相关$\Leftrightarrow \beta$可以由$\alpha_{1},\alpha_{2},\cdots,\alpha_{s}$唯一线性表示。</p><p>(3) $\beta$可以由$\alpha_{1},\alpha_{2},\cdots,\alpha_{s}$线性表示<br>$\Leftrightarrow r(\alpha_{1},\alpha_{2},\cdots,\alpha_{s}) =r(\alpha_{1},\alpha_{2},\cdots,\alpha_{s},\beta)$ 。</p><p><strong>2.有关向量组的线性相关性</strong></p><p>(1)部分相关，整体相关；整体无关，部分无关.</p><p>(2) ① $n$个$n$维向量<br>$\alpha_{1},\alpha_{2}\cdots\alpha_{n}$线性无关$\Leftrightarrow \left|\left\lbrack \alpha_{1}\alpha_{2}\cdots\alpha_{n} \right\rbrack \right| \neq0$， $n$个$n$维向量$\alpha_{1},\alpha_{2}\cdots\alpha_{n}$线性相关<br>$\Leftrightarrow |\lbrack\alpha_{1},\alpha_{2},\cdots,\alpha_{n}\rbrack| = 0$</p><p>② $n + 1$个$n$维向量线性相关。</p><p>③ 若$\alpha_{1},\alpha_{2}\cdots\alpha_{S}$线性无关，则添加分量后仍线性无关；或一组向量线性相关，去掉某些分量后仍线性相关。</p><p><strong>3.有关向量组的线性表示</strong></p><p>(1) $\alpha_{1},\alpha_{2},\cdots,\alpha_{s}$线性相关$\Leftrightarrow$至少有一个向量可以用其余向量线性表示。</p><p>(2) $\alpha_{1},\alpha_{2},\cdots,\alpha_{s}$线性无关，$\alpha_{1},\alpha_{2},\cdots,\alpha_{s}$，$\beta$线性相关$\Leftrightarrow\beta$ 可以由$\alpha_{1},\alpha_{2},\cdots,\alpha_{s}$唯一线性表示。</p><p>(3) $\beta$可以由$\alpha_{1},\alpha_{2},\cdots,\alpha_{s}$线性表示<br>$\Leftrightarrow r(\alpha_{1},\alpha_{2},\cdots,\alpha_{s}) =r(\alpha_{1},\alpha_{2},\cdots,\alpha_{s},\beta)$</p><p><strong>4.向量组的秩与矩阵的秩之间的关系</strong></p><p>设$r(A_{m \times n}) =r$，则$A$的秩$r(A)$与$A$的行列向量组的线性相关性关系为：</p><p>(1) 若$r(A_{m \times n}) = r = m$，则$A$的行向量组线性无关。</p><p>(2) 若$r(A_{m \times n}) = r &lt; m$，则$A$的行向量组线性相关。</p><p>(3) 若$r(A_{m \times n}) = r = n$，则$A$的列向量组线性无关。</p><p>(4) 若$r(A_{m \times n}) = r &lt; n$，则$A$的列向量组线性相关。</p><p><strong>5.</strong>$\mathbf{n}$<strong>维向量空间的基变换公式及过渡矩阵</strong></p><p>若$\alpha_{1},\alpha_{2},\cdots,\alpha_{n}$与$\beta_{1},\beta_{2},\cdots,\beta_{n}$是向量空间$V$的两组基，则基变换公式为：</p><script type="math/tex; mode=display">(\beta_{1},\beta_{2},\cdots,\beta_{n}) = (\alpha_{1},\alpha_{2},\cdots,\alpha_{n})\begin{bmatrix}  c_{11}& c_{12}& \cdots & c_{1n} \\  c_{21}& c_{22}&\cdots & c_{2n} \\ \cdots & \cdots & \cdots & \cdots \\  c_{n1}& c_{n2} & \cdots & c_{nn} \\\end{bmatrix} = (\alpha_{1},\alpha_{2},\cdots,\alpha_{n})C</script><p>其中$C$是可逆矩阵，称为由基$\alpha_{1},\alpha_{2},\cdots,\alpha_{n}$到基$\beta_{1},\beta_{2},\cdots,\beta_{n}$的过渡矩阵。</p><p><strong>6.坐标变换公式</strong></p><p>若向量$\gamma$在基$\alpha_{1},\alpha_{2},\cdots,\alpha_{n}$与基$\beta_{1},\beta_{2},\cdots,\beta_{n}$的坐标分别是<br>$X = {(x_{1},x_{2},\cdots,x_{n})}^{T}$，</p><p>$Y = \left( y_{1},y_{2},\cdots,y_{n} \right)^{T}$ 即： $\gamma =x_{1}\alpha_{1} + x_{2}\alpha_{2} + \cdots + x_{n}\alpha_{n} = y_{1}\beta_{1} +y_{2}\beta_{2} + \cdots + y_{n}\beta_{n}$，则向量坐标变换公式为$X = CY$ 或$Y = C^{- 1}X$，其中$C$是从基$\alpha_{1},\alpha_{2},\cdots,\alpha_{n}$到基$\beta_{1},\beta_{2},\cdots,\beta_{n}$的过渡矩阵。</p><p><strong>7.向量的内积</strong></p><p>$(\alpha,\beta) = a_{1}b_{1} + a_{2}b_{2} + \cdots + a_{n}b_{n} = \alpha^{T}\beta = \beta^{T}\alpha$</p><p><strong>8.Schmidt正交化</strong></p><p>若$\alpha_{1},\alpha_{2},\cdots,\alpha_{s}$线性无关，则可构造$\beta_{1},\beta_{2},\cdots,\beta_{s}$使其两两正交，且$\beta_{i}$仅是$\alpha_{1},\alpha_{2},\cdots,\alpha_{i}$的线性组合$(i= 1,2,\cdots,n)$，再把$\beta_{i}$单位化，记$\gamma_{i} =\frac{\beta_{i}}{\left| \beta_{i}\right|}$，则$\gamma_{1},\gamma_{2},\cdots,\gamma_{i}$是规范正交向量组。其中<br>$\beta_{1} = \alpha_{1}$， $\beta_{2} = \alpha_{2} -\frac{(\alpha_{2},\beta_{1})}{(\beta_{1},\beta_{1})}\beta_{1}$ ， $\beta_{3} =\alpha_{3} - \frac{(\alpha_{3},\beta_{1})}{(\beta_{1},\beta_{1})}\beta_{1} -\frac{(\alpha_{3},\beta_{2})}{(\beta_{2},\beta_{2})}\beta_{2}$ ，</p><p>…………</p><p>$\beta_{s} = \alpha_{s} - \frac{(\alpha_{s},\beta_{1})}{(\beta_{1},\beta_{1})}\beta_{1} - \frac{(\alpha_{s},\beta_{2})}{(\beta_{2},\beta_{2})}\beta_{2} - \cdots - \frac{(\alpha_{s},\beta_{s - 1})}{(\beta_{s - 1},\beta_{s - 1})}\beta_{s - 1}$</p><p><strong>9.正交基及规范正交基</strong></p><p>向量空间一组基中的向量如果两两正交，就称为正交基；若正交基中每个向量都是单位向量，就称其为规范正交基。</p><h2 id="线性方程组"><a href="#线性方程组" class="headerlink" title="线性方程组"></a>线性方程组</h2><p><strong>1．克莱姆法则</strong></p><p>线性方程组$\begin{cases}  a_{11}x_{1} + a_{12}x_{2} + \cdots +a_{1n}x_{n} = b_{1} \\   a_{21}x_{1} + a_{22}x_{2} + \cdots + a_{2n}x_{n} =b_{2} \\   \quad\cdots\cdots\cdots\cdots\cdots\cdots\cdots\cdots\cdots \\ a_{n1}x_{1} + a_{n2}x_{2} + \cdots + a_{nn}x_{n} = b_{n} \\ \end{cases}$，如果系数行列式$D = \left| A \right| \neq 0$，则方程组有唯一解，$x_{1} = \frac{D_{1}}{D},x_{2} = \frac{D_{2}}{D},\cdots,x_{n} =\frac{D_{n}}{D}$，其中$D_{j}$是把$D$中第$j$列元素换成方程组右端的常数列所得的行列式。</p><p><strong>2.</strong> $n$阶矩阵$A$可逆$\Leftrightarrow Ax = 0$只有零解。$\Leftrightarrow\forall b,Ax = b$总有唯一解，一般地，$r(A_{m \times n}) = n \Leftrightarrow Ax= 0$只有零解。</p><p><strong>3.非奇次线性方程组有解的充分必要条件，线性方程组解的性质和解的结构</strong></p><p>(1) 设$A$为$m \times n$矩阵，若$r(A_{m \times n}) = m$，则对$Ax =b$而言必有$r(A) = r(A \vdots b) = m$，从而$Ax = b$有解。</p><p>(2) 设$x_{1},x_{2},\cdots x_{s}$为$Ax = b$的解，则$k_{1}x_{1} + k_{2}x_{2}\cdots + k_{s}x_{s}$当$k_{1} + k_{2} + \cdots + k_{s} = 1$时仍为$Ax =b$的解；但当$k_{1} + k_{2} + \cdots + k_{s} = 0$时，则为$Ax =0$的解。特别$\frac{x_{1} + x_{2}}{2}$为$Ax = b$的解；$2x_{3} - (x_{1} +x_{2})$为$Ax = 0$的解。</p><p>(3) 非齐次线性方程组${Ax} = b$无解$\Leftrightarrow r(A) + 1 =r(\overline{A}) \Leftrightarrow b$不能由$A$的列向量$\alpha_{1},\alpha_{2},\cdots,\alpha_{n}$线性表示。</p><p><strong>4.奇次线性方程组的基础解系和通解，解空间，非奇次线性方程组的通解</strong></p><p>(1) 齐次方程组${Ax} = 0$恒有解(必有零解)。当有非零解时，由于解向量的任意线性组合仍是该齐次方程组的解向量，因此${Ax}= 0$的全体解向量构成一个向量空间，称为该方程组的解空间，解空间的维数是$n - r(A)$，解空间的一组基称为齐次方程组的基础解系。</p><p>(2) $\eta_{1},\eta_{2},\cdots,\eta_{t}$是${Ax} = 0$的基础解系，即：</p><p>1) $\eta_{1},\eta_{2},\cdots,\eta_{t}$是${Ax} = 0$的解；</p><p>2) $\eta_{1},\eta_{2},\cdots,\eta_{t}$线性无关；</p><p>3) ${Ax} = 0$的任一解都可以由$\eta_{1},\eta_{2},\cdots,\eta_{t}$线性表出.<br>$k_{1}\eta_{1} + k_{2}\eta_{2} + \cdots + k_{t}\eta_{t}$是${Ax} = 0$的通解，其中$k_{1},k_{2},\cdots,k_{t}$是任意常数。</p><h2 id="矩阵的特征值和特征向量"><a href="#矩阵的特征值和特征向量" class="headerlink" title="矩阵的特征值和特征向量"></a>矩阵的特征值和特征向量</h2><p><strong>1.矩阵的特征值和特征向量的概念及性质</strong></p><p>(1) 设$\lambda$是$A$的一个特征值，则 ${kA},{aA} + {bE},A^{2},A^{m},f(A),A^{T},A^{- 1},A^{*}$有一个特征值分别为<br>${kλ},{aλ} + b,\lambda^{2},\lambda^{m},f(\lambda),\lambda,\lambda^{- 1},\frac{|A|}{\lambda},$且对应特征向量相同（$A^{T}$ 例外）。</p><p>(2)若$\lambda_{1},\lambda_{2},\cdots,\lambda_{n}$为$A$的$n$个特征值，则$\sum_{i= 1}^{n}\lambda_{i} = \sum_{i = 1}^{n}a_,\prod_{i = 1}^{n}\lambda_{i}= |A|$ ,从而$|A| \neq 0 \Leftrightarrow A$没有特征值。</p><p>(3)设$\lambda_{1},\lambda_{2},\cdots,\lambda_{s}$为$A$的$s$个特征值，对应特征向量为$\alpha_{1},\alpha_{2},\cdots,\alpha_{s}$，</p><p>若: $\alpha = k_{1}\alpha_{1} + k_{2}\alpha_{2} + \cdots + k_{s}\alpha_{s}$ ,</p><p>则: $A^{n}\alpha = k_{1}A^{n}\alpha_{1} + k_{2}A^{n}\alpha_{2} + \cdots +k_{s}A^{n}\alpha_{s} = k_{1}\lambda_{1}^{n}\alpha_{1} +k_{2}\lambda_{2}^{n}\alpha_{2} + \cdots k_{s}\lambda_{s}^{n}\alpha_{s}$ 。</p><p><strong>2.相似变换、相似矩阵的概念及性质</strong></p><p>(1) 若$A \sim B$，则</p><p>1) $A^{T} \sim B^{T},A^{- 1} \sim B^{- 1},,A^{\star} \sim B^{\star}$</p><p>2) $|A| = |B|,\sum_{i = 1}^{n}A_ = \sum_{i =1}^{n}b_,r(A) = r(B)$</p><p>3) $|\lambda E - A| = |\lambda E - B|$，对$\forall\lambda$成立</p><p><strong>3.矩阵可相似对角化的充分必要条件</strong></p><p>(1)设$A$为$n$阶方阵，则$A$可对角化$\Leftrightarrow$对每个$k_{i}$重根特征值$\lambda_{i}$，有$n-r(\lambda_{i}E - A) = k_{i}$</p><p>(2) 设$A$可对角化，则由$P^{- 1}{AP} = \Lambda,$有$A = {PΛ}P^{-1}$，从而$A^{n} = P\Lambda^{n}P^{- 1}$</p><p>(3) 重要结论</p><p>1) 若$A \sim B,C \sim D$，则$\begin{bmatrix}  A &amp; O \\ O &amp; C \\\end{bmatrix} \sim \begin{bmatrix} B &amp; O \\  O &amp; D \\\end{bmatrix}$.</p><p>2) 若$A \sim B$，则$f(A) \sim f(B),\left| f(A) \right| \sim \left| f(B)\right|$，其中$f(A)$为关于$n$阶方阵$A$的多项式。</p><p>3) 若$A$为可对角化矩阵，则其非零特征值的个数(重根重复计算)＝秩($A$)</p><p><strong>4.实对称矩阵的特征值、特征向量及相似对角阵</strong></p><p>(1)相似矩阵：设$A,B$为两个$n$阶方阵，如果存在一个可逆矩阵$P$，使得$B =P^{- 1}{AP}$成立，则称矩阵$A$与$B$相似，记为$A \sim B$。</p><p>(2)相似矩阵的性质：如果$A \sim B$则有：</p><p>1) $A^{T} \sim B^{T}$</p><p>2) $A^{- 1} \sim B^{- 1}$ （若$A$，$B$均可逆）</p><p>3) $A^{k} \sim B^{k}$ （$k$为正整数）</p><p>4) $\left| {λE} - A \right| = \left| {λE} - B \right|$，从而$A,B$<br>有相同的特征值</p><p>5) $\left| A \right| = \left| B \right|$，从而$A,B$同时可逆或者不可逆</p><p>6) 秩$\left( A \right) =$秩$\left( B \right),\left| {λE} - A \right| =\left| {λE} - B \right|$，$A,B$不一定相似</p><h2 id="二次型"><a href="#二次型" class="headerlink" title="二次型"></a>二次型</h2><p><strong>1.</strong>$\mathbf{n}$<strong>个变量</strong>$\mathbf{x}_{\mathbf{1}}\mathbf{,}\mathbf{x}_{\mathbf{2}}\mathbf{,\cdots,}\mathbf{x}_{\mathbf{n}}$<strong>的二次齐次函数</strong></p><p>$f(x_1,x_2,\cdots,x_n) = \sum_{i = 1}^n{\sum_{j =1}^n{a_{ij}x_iy_j}}$，其中$a_ = a_(i,j =1,2,\cdots,n)$，称为$n$元二次型，简称二次型. 若令$x = \ \begin{bmatrix}x_{1} \\ x_{1} \\  \vdots \\ x_{n} \\ \end{bmatrix},A = \begin{bmatrix}  a_{11}&amp; a_{12}&amp; \cdots &amp; a_{1n} \\  a_{21}&amp; a_{22}&amp; \cdots &amp; a_{2n} \\ \cdots &amp;\cdots &amp;\cdots &amp;\cdots \\  a_{n1}&amp; a_{n2} &amp; \cdots &amp; a_{nn} \\\end{bmatrix}$,这二次型$f$可改写成矩阵向量形式$f =x^{T}{Ax}$。其中$A$称为二次型矩阵，因为$a_ =a_(i,j =1,2,\cdots,n)$，所以二次型矩阵均为对称矩阵，且二次型与对称矩阵一一对应，并把矩阵$A$的秩称为二次型的秩。</p><p><strong>2.惯性定理，二次型的标准形和规范形</strong></p><p>(1) 惯性定理</p><p>对于任一二次型，不论选取怎样的合同变换使它化为仅含平方项的标准型，其正负惯性指数与所选变换无关，这就是所谓的惯性定理。</p><p>(2) 标准形</p><p>二次型$f = \left( x_{1},x_{2},\cdots,x_{n} \right) =x^{T}{Ax}$经过合同变换$x = {Cy}$化为$f = x^{T}{Ax} =y^{T}C^{T}{AC}$</p><p>$y = \sum_{i = 1}^{r}{d_{i}y_{i}^{2}}$称为 $f(r \leq n)$的标准形。在一般的数域内，二次型的标准形不是唯一的，与所作的合同变换有关，但系数不为零的平方项的个数由$r(A)$唯一确定。</p><p>(3) 规范形</p><p>任一实二次型$f$都可经过合同变换化为规范形$f = z_{1}^{2} + z_{2}^{2} + \cdots z_{p}^{2} - z_{p + 1}^{2} - \cdots -z_{r}^{2}$，其中$r$为$A$的秩，$p$为正惯性指数，$r -p$为负惯性指数，且规范型唯一。</p><p><strong>3.用正交变换和配方法化二次型为标准形，二次型及其矩阵的正定性</strong></p><p>设$A$正定$\Rightarrow {kA}(k &gt; 0),A^{T},A^{- 1},A^{*}$正定；$|A| &gt;0$,$A$可逆；$a_ &gt; 0$，且$|A_| &gt; 0$</p><p>$A$，$B$正定$\Rightarrow A +B$正定，但${AB}$，${BA}$不一定正定</p><p>$A$正定$\Leftrightarrow f(x) = x^{T}{Ax} &gt; 0,\forall x \neq 0$</p><p>$\Leftrightarrow A$的各阶顺序主子式全大于零</p><p>$\Leftrightarrow A$的所有特征值大于零</p><p>$\Leftrightarrow A$的正惯性指数为$n$</p><p>$\Leftrightarrow$存在可逆阵$P$使$A = P^{T}P$</p><p>$\Leftrightarrow$存在正交矩阵$Q$，使$Q^{T}{AQ} = Q^{- 1}{AQ} =\begin{pmatrix} \lambda_{1} &amp; &amp; \\ \begin{matrix}  &amp; \\  &amp; \\ \end{matrix} &amp;\ddots &amp; \\  &amp; &amp; \lambda_{n} \\ \end{pmatrix},$</p><p>其中$\lambda_{i} &gt; 0,i = 1,2,\cdots,n.$正定$\Rightarrow {kA}(k &gt;0),A^{T},A^{- 1},A^{*}$正定； $|A| &gt; 0,A$可逆；$a_ &gt;0$，且$|A_| &gt; 0$ 。</p><h1 id="概率论和数理统计"><a href="#概率论和数理统计" class="headerlink" title="概率论和数理统计"></a>概率论和数理统计</h1><h2 id="随机事件和概率"><a href="#随机事件和概率" class="headerlink" title="随机事件和概率"></a>随机事件和概率</h2><p><strong>1.事件的关系与运算</strong></p><p>(1) 子事件：$A \subset B$，若$A$发生，则$B$发生。</p><p>(2) 相等事件：$A = B$，即$A \subset B$，且$B \subset A$ 。</p><p>(3) 和事件：$A\bigcup B$（或$A + B$），$A$与$B$中至少有一个发生。</p><p>(4) 差事件：$A - B$，$A$发生但$B$不发生。</p><p>(5) 积事件：$A\bigcap B$（或${AB}$），$A$与$B$同时发生。</p><p>(6) 互斥事件（互不相容）：$A\bigcap B$=$\varnothing$。</p><p>(7) 互逆事件（对立事件）：<br>$A\bigcap B=\varnothing ,A\bigcup B=\Omega ,A=\bar{B},B=\bar{A}$<br><strong>2.运算律</strong><br>(1) 交换律：$A\bigcup B=B\bigcup A,A\bigcap B=B\bigcap A$<br>(2) 结合律：$(A\bigcup B)\bigcup C=A\bigcup (B\bigcup C)$<br>(3) 分配律：$(A\bigcap B)\bigcap C=A\bigcap (B\bigcap C)$<br><strong>3.德$\centerdot $摩根律</strong></p><p>$\overline{A\bigcup B}=\bar{A}\bigcap \bar{B}$                 $\overline{A\bigcap B}=\bar{A}\bigcup \bar{B}$<br><strong>4.完全事件组</strong> </p><p>$A_1A_2\cdots A_n$两两互斥，且和事件为必然事件，即$A_i\bigcap A_j=\varnothing, i\ne j ,\underset{i=1}{\overset{n}{\mathop \bigcup }}\,=\Omega $</p><p><strong>5.概率的基本公式</strong><br>(1)条件概率:<br> $P(B|A)=\frac{P(AB)}{P(A)}$,表示$A$发生的条件下，$B$发生的概率。<br>(2)全概率公式：<br>$P(A)=\sum\limits_{i=1}^{n}{P(A|B_i)P(B_i),B_iB_j}=\varnothing ,i\ne j,\underset{i=1}{\overset{n}{\mathop{\bigcup }}}\,B_i=\Omega $<br>(3) Bayes公式：</p><p>$P(B_j|A)=\frac{P(A|B_j)P(B_j)}{\sum\limits_{i=1}^{n}{P(A|B_i)P(B_i)}},j=1,2,\cdots ,n$<br>注：上述公式中事件$B_i$的个数可为可列个。<br>(4)乘法公式：<br>$P(A_1A_2)=P(A_1)P(A_2|A_1)=P(A_2)P(A_1|A_2)$<br>$P(A_1A_2\cdots A_n)=P(A_1)P(A_2|A_1)P(A_3|A_1A_2)\cdots P(A_n|A_1A_2\cdots A_{n-1})$</p><p><strong>6.事件的独立性</strong><br>(1)$A$与$B$相互独立$\Leftrightarrow P(AB)=P(A)P(B)$<br>(2)$A$，$B$，$C$两两独立<br>$\Leftrightarrow P(AB)=P(A)P(B)$;$P(BC)=P(B)P(C)$ ;$P(AC)=P(A)P(C)$;<br>(3)$A$，$B$，$C$相互独立<br>$\Leftrightarrow P(AB)=P(A)P(B)$;     $P(BC)=P(B)P(C)$ ;<br>$P(AC)=P(A)P(C)$  ;   $P(ABC)=P(A)P(B)P(C)$</p><p><strong>7.独立重复试验</strong> </p><p>将某试验独立重复$n$次，若每次实验中事件A发生的概率为$p$，则$n$次试验中$A$发生$k$次的概率为：<br>$P(X=k)=C_{n}^{k}p^k(1-p)^{n-k}$<br><strong>8.重要公式与结论</strong><br>$(1)P(\bar{A})=1-P(A)$<br>$(2)P(A\bigcup B)=P(A)+P(B)-P(AB)$<br>   $P(A\bigcup B\bigcup C)=P(A)+P(B)+P(C)-P(AB)-P(BC)-P(AC)+P(ABC)$<br>$(3)P(A-B)=P(A)-P(AB)$<br>$(4)P(A\bar{B})=P(A)-P(AB),P(A)=P(AB)+P(A\bar{B}),$<br> $P(A\bigcup B)=P(A)+P(\bar{A}B)=P(AB)+P(A\bar{B})+P(\bar{A}B)$<br>(5)条件概率$P(\centerdot |B)$满足概率的所有性质，<br>例如：. $P(\bar{A}_{1}|B)=1-P(A_1|B)$<br>$P(A_1\bigcup A_2|B)=P(A_1|B)+P(A_2|B)-P(A_1A_2|B)$<br>$P(A_1A_2|B)=P(A_1|B)P(A_2|A_1B)$<br>(6)若$A_1,A_2,\cdots ,A_n$相互独立，则$P(\bigcap\limits_{i=1}^{n}{A_i})=\prod\limits_{i=1}^{n}{P(A_i)},$<br> $P(\bigcup\limits_{i=1}^{n}{A_i})=\prod\limits_{i=1}^{n}{(1-P(A_i))}$<br>(7)互斥、互逆与独立性之间的关系：<br>$A$与$B$互逆$\Rightarrow$ $A$与$B$互斥，但反之不成立，$A$与$B$互斥（或互逆）且均非零概率事件$\Rightarrow $$A$与$B$不独立.<br>(8)若$A_1,A_2,\cdots ,A_m,B_1,B_2,\cdots ,B_n$相互独立，则$f(A_1,A_2,\cdots ,A_m)$与$g(B_1,B_2,\cdots ,B_n)$也相互独立，其中$f(\centerdot ),g(\centerdot )$分别表示对相应事件做任意事件运算后所得的事件，另外，概率为1（或0）的事件与任何事件相互独立.</p><h2 id="随机变量及其概率分布"><a href="#随机变量及其概率分布" class="headerlink" title="随机变量及其概率分布"></a>随机变量及其概率分布</h2><p><strong>1.随机变量及概率分布</strong></p><p>取值带有随机性的变量，严格地说是定义在样本空间上，取值于实数的函数称为随机变量，概率分布通常指分布函数或分布律</p><p><strong>2.分布函数的概念与性质</strong></p><p>定义： $F(x) = P(X \leq x), - \infty &lt; x &lt; + \infty$</p><p>性质：(1)$0 \leq F(x) \leq 1$ </p><p>(2) $F(x)$单调不减</p><p>(3) 右连续$F(x + 0) = F(x)$ </p><p>(4) $F( - \infty) = 0,F( + \infty) = 1$</p><p><strong>3.离散型随机变量的概率分布</strong></p><p>$P(X = x_{i}) = p_{i},i = 1,2,\cdots,n,\cdots\quad\quad p_{i} \geq 0,\sum_{i =1}^{\infty}p_{i} = 1$</p><p><strong>4.连续型随机变量的概率密度</strong></p><p>概率密度$f(x)$;非负可积，且:</p><p>(1)$f(x) \geq 0,$ </p><p>(2)$\int_{- \infty}^{+\infty}{f(x){dx} = 1}$ </p><p>(3)$x$为$f(x)$的连续点，则:</p><p>$f(x) = F’(x)$分布函数$F(x) = \int_{- \infty}^{x}{f(t){dt}}$</p><p><strong>5.常见分布</strong></p><p>(1) 0-1分布:$P(X = k) = p^{k}(1 - p)^{1 - k},k = 0,1$</p><p>(2) 二项分布:$B(n,p)$： $P(X = k) = C_n^kp^k(1 - p)^{n - k},k =0,1,\cdots,n$</p><p>(3) <strong>Poisson</strong>分布:$p(\lambda)$： $P(X = k) = \frac{\lambda^{k}}{k!}e^{-\lambda},\lambda &gt; 0,k = 0,1,2\cdots$</p><p>(4) 均匀分布$U(a,b)$：$f(x) = \{ \begin{matrix}  &amp; \frac{1}{b - a},a &lt; x&lt; b \\  &amp; 0, \\ \end{matrix} $</p><p>(5) 正态分布:$N(\mu,\sigma^{2}):$ $\varphi(x) =\frac{1}{\sqrt{2\pi}\sigma}e^{- \frac{(x - \mu)^2}{2\sigma^2},\sigma &gt; 0,\infty &lt; x &lt; + \infty$</p><p>(6)指数分布:$E(\lambda):f(x) =\{ \begin{matrix}  &amp; \lambda e^{-{λx}},x &gt; 0,\lambda &gt; 0 \\  &amp; 0, \\ \end{matrix} $</p><p>(7)几何分布:$G(p):P(X = k) = (1-p)^{k - 1}p,0 &lt; p &lt; 1,k = 1,2,\cdots.$</p><p>(8)超几何分布: $H(N,M,n):P(X = k) = \frac{C_{M}^{k}C_{N - M}^{n -k}}{C_{N}^{n}},k =0,1,\cdots,min(n,M)$</p><p><strong>6.随机变量函数的概率分布</strong></p><p>(1)离散型：$P(X = x_{1}) = p_{i},Y = g(X)$</p><p>则: $P(Y = y_{j}) = \sum_{g(x_{i}) = y_{i}}^{}{P(X = x_{i})}$</p><p>(2)连续型：$X\tilde{\ }f_{X}(x),Y = g(x)$</p><p>则:$F_{y}(y) = P(Y \leq y) = P(g(X) \leq y) = \int_{g(x) \leq y}^{}{f_{x}(x)dx}$， $f_{Y}(y) = F’_{Y}(y)$</p><p><strong>7.重要公式与结论</strong></p><p>(1) $X\sim N(0,1) \Rightarrow \varphi(0) = \frac{1}{\sqrt{2\pi}},\Phi(0) =\frac{1}{2},$ $\Phi( - a) = P(X \leq - a) = 1 - \Phi(a)$</p><p>(2) $X\sim N\left( \mu,\sigma^{2} \right) \Rightarrow \frac{X -\mu}{\sigma}\sim N\left( 0,1 \right),P(X \leq a) = \Phi(\frac{a -\mu}{\sigma})$</p><p>(3) $X\sim E(\lambda) \Rightarrow P(X &gt; s + t|X &gt; s) = P(X &gt; t)$</p><p>(4) $X\sim G(p) \Rightarrow P(X = m + k|X &gt; m) = P(X = k)$</p><p>(5) 离散型随机变量的分布函数为阶梯间断函数；连续型随机变量的分布函数为连续函数，但不一定为处处可导函数。</p><p>(6) 存在既非离散也非连续型随机变量。</p><h2 id="多维随机变量及其分布"><a href="#多维随机变量及其分布" class="headerlink" title="多维随机变量及其分布"></a>多维随机变量及其分布</h2><p><strong>1.二维随机变量及其联合分布</strong></p><p>由两个随机变量构成的随机向量$(X,Y)$， 联合分布为$F(x,y) = P(X \leq x,Y \leq y)$</p><p><strong>2.二维离散型随机变量的分布</strong></p><p>(1) 联合概率分布律 $P\{ X = x_{i},Y = y_{j}\} = p_{ij};i,j =1,2,\cdots$</p><p>(2) 边缘分布律 $p_{i \cdot} = \sum_{j = 1}^{\infty}p_{ij},i =1,2,\cdots$ $p_{\cdot j} = \sum_{i}^{\infty}p_{ij},j = 1,2,\cdots$</p><p>(3) 条件分布律 $P\{ X = x_{i}|Y = y_{j}\} = \frac{p_{ij}}{p_{\cdot j}}$<br>$P\{ Y = y_{j}|X = x_{i}\} = \frac{p_{ij}}{p_{i \cdot}}$</p><p><strong>3. 二维连续性随机变量的密度</strong></p><p>(1) 联合概率密度$f(x,y):$</p><p>1) $f(x,y) \geq 0$ </p><p>2) $\int_{- \infty}^{+ \infty}{\int_{- \infty}^{+ \infty}{f(x,y)dxdy}} = 1$</p><p>(2) 分布函数：$F(x,y) = \int_{- \infty}^{x}{\int_{- \infty}^{y}{f(u,v)dudv}}$</p><p>(3) 边缘概率密度： $f_{X}\left( x \right) = \int_{- \infty}^{+ \infty}{f\left( x,y \right){dy}}$ $f_{Y}(y) = \int_{- \infty}^{+ \infty}{f(x,y)dx}$</p><p>(4) 条件概率密度：$f_{X|Y}\left( x \middle| y \right) = \frac{f\left( x,y \right)}{f_{Y}\left( y \right)}$ $f_{Y|X}(y|x) = \frac{f(x,y)}{f_{X}(x)}$</p><p><strong>4.常见二维随机变量的联合分布</strong></p><p>(1) 二维均匀分布：$(x,y) \sim U(D)$ ,$f(x,y) = \begin{cases} \frac{1}{S(D)},(x,y) \in D \\   0,其他  \end{cases}$</p><p>(2) 二维正态分布：$(X,Y)\sim N(\mu_{1},\mu_{2},\sigma_{1}^{2},\sigma_{2}^{2},\rho)$,$(X,Y)\sim N(\mu_{1},\mu_{2},\sigma_{1}^{2},\sigma_{2}^{2},\rho)$</p><p>$f(x,y) = \frac{1}{2\pi\sigma_{1}\sigma_{2}\sqrt{1 - \rho^{2}}}.\exp\left\{ \frac{- 1}{2(1 - \rho^{2})}\lbrack\frac{(x - \mu_{1})^{2}}{\sigma_{1}^{2}} - 2\rho\frac{(x - \mu_{1})(y - \mu_{2})}{\sigma_{1}\sigma_{2}} + \frac{(y - \mu_{2})^{2}}{\sigma_{2}^{2}}\rbrack \right\}$</p><p><strong>5.随机变量的独立性和相关性</strong></p><p>$X$和$Y$的相互独立:$\Leftrightarrow F\left( x,y \right) = F_{X}\left( x \right)F_{Y}\left( y \right)$:</p><p>$\Leftrightarrow p_{ij} = p_{i \cdot} \cdot p_{\cdot j}$（离散型）<br>$\Leftrightarrow f\left( x,y \right) = f_{X}\left( x \right)f_{Y}\left( y \right)$（连续型）</p><p>$X$和$Y$的相关性：</p><p>相关系数$\rho_{XY} = 0$时，称$X$和$Y$不相关，<br>否则称$X$和$Y$相关</p><p><strong>6.两个随机变量简单函数的概率分布</strong></p><p>离散型： $P\left( X = x_{i},Y = y_{i} \right) = p_{ij},Z = g\left( X,Y \right)$ 则：</p><p>$P(Z = z_{k}) = P\left\{ g\left( X,Y \right) = z_{k} \right\} = \sum_{g\left( x_{i},y_{i} \right) = z_{k}}^{}{P\left( X = x_{i},Y = y_{j} \right)}$</p><p>连续型： $\left( X,Y \right) \sim f\left( x,y \right),Z = g\left( X,Y \right)$<br>则：</p><p>$F_{z}\left( z \right) = P\left\{ g\left( X,Y \right) \leq z \right\} = \iint_{g(x,y) \leq z}^{}{f(x,y)dxdy}$，$f_{z}(z) = F’_{z}(z)$</p><p><strong>7.重要公式与结论</strong></p><p>(1) 边缘密度公式： $f_{X}(x) = \int_{- \infty}^{+ \infty}{f(x,y)dy,}$<br>$f_{Y}(y) = \int_{- \infty}^{+ \infty}{f(x,y)dx}$</p><p>(2) $P\left\{ \left( X,Y \right) \in D \right\} = \iint_{D}^{}{f\left( x,y \right){dxdy}}$</p><p>(3) 若$(X,Y)$服从二维正态分布$N(\mu_{1},\mu_{2},\sigma_{1}^{2},\sigma_{2}^{2},\rho)$<br>则有：</p><p>1) $X\sim N\left( \mu_{1},\sigma_{1}^{2} \right),Y\sim N(\mu_{2},\sigma_{2}^{2}).$</p><p>2) $X$与$Y$相互独立$\Leftrightarrow \rho = 0$，即$X$与$Y$不相关。</p><p>3) $C_{1}X + C_{2}Y\sim N(C_{1}\mu_{1} + C_{2}\mu_{2},C_{1}^{2}\sigma_{1}^{2} + C_{2}^{2}\sigma_{2}^{2} + 2C_{1}C_{2}\sigma_{1}\sigma_{2}\rho)$</p><p>4) ${\ X}$关于$Y=y$的条件分布为： $N(\mu_{1} + \rho\frac{\sigma_{1}}{\sigma_{2}}(y - \mu_{2}),\sigma_{1}^{2}(1 - \rho^{2}))$</p><p>5) $Y$关于$X = x$的条件分布为： $N(\mu_{2} + \rho\frac{\sigma_{2}}{\sigma_{1}}(x - \mu_{1}),\sigma_{2}^{2}(1 - \rho^{2}))$</p><p>(4) 若$X$与$Y$独立，且分别服从$N(\mu_{1},\sigma_{1}^{2}),N(\mu_{1},\sigma_{2}^{2}),$<br>则：$\left( X,Y \right)\sim N(\mu_{1},\mu_{2},\sigma_{1}^{2},\sigma_{2}^{2},0),$</p><p>$C_{1}X + C_{2}Y\tilde{\ }N(C_{1}\mu_{1} + C_{2}\mu_{2},C_{1}^{2}\sigma_{1}^{2} C_{2}^{2}\sigma_{2}^{2}).$</p><p>(5) 若$X$与$Y$相互独立，$f\left( x \right)$和$g\left( x \right)$为连续函数， 则$f\left( X \right)$和$g(Y)$也相互独立。</p><h2 id="随机变量的数字特征"><a href="#随机变量的数字特征" class="headerlink" title="随机变量的数字特征"></a>随机变量的数字特征</h2><p><strong>1.数学期望</strong></p><p>离散型：$P\left\{ X = x_{i} \right\} = p_{i},E(X) = \sum_{i}^{}{x_{i}p_{i}}$；</p><p>连续型： $X\sim f(x),E(X) = \int_{- \infty}^{+ \infty}{xf(x)dx}$</p><p>性质：</p><p>(1) $E(C) = C,E\lbrack E(X)\rbrack = E(X)$</p><p>(2) $E(C_{1}X + C_{2}Y) = C_{1}E(X) + C_{2}E(Y)$</p><p>(3) 若$X$和$Y$独立，则$E(XY) = E(X)E(Y)$ </p><p>(4)$\left\lbrack E(XY) \right\rbrack^{2} \leq E(X^{2})E(Y^{2})$</p><p><strong>2.方差</strong>：$D(X) = E\left\lbrack X - E(X) \right\rbrack^{2} = E(X^{2}) - \left\lbrack E(X) \right\rbrack^{2}$</p><p><strong>3.标准差</strong>：$\sqrt{D(X)}$，</p><p><strong>4.离散型：</strong>$D(X) = \sum_{i}^{}{\left\lbrack x_{i} - E(X) \right\rbrack^{2}p_{i}}$</p><p><strong>5.连续型：</strong>$D(X) = {\int_{- \infty}^{+ \infty}\left\lbrack x - E(X) \right\rbrack}^{2}f(x)dx$</p><p>性质：</p><p>(1)$\ D(C) = 0,D\lbrack E(X)\rbrack = 0,D\lbrack D(X)\rbrack = 0$</p><p>(2) $X$与$Y$相互独立，则$D(X \pm Y) = D(X) + D(Y)$</p><p>(3)$\ D\left( C_{1}X + C_{2} \right) = C_{1}^{2}D\left( X \right)$</p><p>(4) 一般有 $D(X \pm Y) = D(X) + D(Y) \pm 2Cov(X,Y) = D(X) + D(Y) \pm 2\rho\sqrt{D(X)}\sqrt{D(Y)}$</p><p>(5)$\ D\left( X \right) &lt; E\left( X - C \right)^{2},C \neq E\left( X \right)$</p><p>(6)$\ D(X) = 0 \Leftrightarrow P\left\{ X = C \right\} = 1$</p><p><strong>6.随机变量函数的数学期望</strong></p><p>(1) 对于函数$Y = g(x)$</p><p>$X$为离散型：$P\{ X = x_{i}\} = p_{i},E(Y) = \sum_{i}^{}{g(x_{i})p_{i}}$；</p><p>$X$为连续型：$X\sim f(x),E(Y) = \int_{- \infty}^{+ \infty}{g(x)f(x)dx}$</p><p>(2) $Z = g(X,Y)$;$\left( X,Y \right)\sim P\{ X = x_{i},Y = y_{j}\} = p_{ij}$; $E(Z) = \sum_{i}^{}{\sum_{j}^{}{g(x_{i},y_{j})p_{ij}}}$ $\left( X,Y \right)\sim f(x,y)$;$E(Z) = \int_{- \infty}^{+ \infty}{\int_{- \infty}^{+ \infty}{g(x,y)f(x,y)dxdy}}$</p><p><strong>7.协方差</strong> </p><p>$Cov(X,Y) = E\left\lbrack (X - E(X)(Y - E(Y)) \right\rbrack$</p><p><strong>8.相关系数</strong></p><p> $\rho_{XY} = \frac{Cov(X,Y)}{\sqrt{D(X)}\sqrt{D(Y)}}$,$k$阶原点矩 $E(X^{k})$;<br>$k$阶中心矩 $E\left\{ {\lbrack X - E(X)\rbrack}^{k} \right\}$</p><p>性质：</p><p>(1)$\ Cov(X,Y) = Cov(Y,X)$</p><p>(2)$\ Cov(aX,bY) = abCov(Y,X)$</p><p>(3)$\ Cov(X_{1} + X_{2},Y) = Cov(X_{1},Y) + Cov(X_{2},Y)$</p><p>(4)$\ \left| \rho\left( X,Y \right) \right| \leq 1$</p><p>(5) $\ \rho\left( X,Y \right) = 1 \Leftrightarrow P\left( Y = aX + b \right) = 1$ ，其中$a &gt; 0$</p><p>$\rho\left( X,Y \right) = - 1 \Leftrightarrow P\left( Y = aX + b \right) = 1$<br>，其中$a &lt; 0$</p><p><strong>9.重要公式与结论</strong></p><p>(1)$\ D(X) = E(X^{2}) - E^{2}(X)$</p><p>(2)$\ Cov(X,Y) = E(XY) - E(X)E(Y)$</p><p>(3) $\left| \rho\left( X,Y \right) \right| \leq 1,$且 $\rho\left( X,Y \right) = 1 \Leftrightarrow P\left( Y = aX + b \right) = 1$，其中$a &gt; 0$</p><p>$\rho\left( X,Y \right) = - 1 \Leftrightarrow P\left( Y = aX + b \right) = 1$，其中$a &lt; 0$</p><p>(4) 下面5个条件互为充要条件：</p><p>$\rho(X,Y) = 0$ $\Leftrightarrow Cov(X,Y) = 0$ $\Leftrightarrow E(X,Y) = E(X)E(Y)$ $\Leftrightarrow D(X + Y) = D(X) + D(Y)$ $\Leftrightarrow  D(X - Y) = D(X) + D(Y)$</p><p>注：$X$与$Y$独立为上述5个条件中任何一个成立的充分条件，但非必要条件。</p><h2 id="数理统计的基本概念"><a href="#数理统计的基本概念" class="headerlink" title="数理统计的基本概念"></a>数理统计的基本概念</h2><p><strong>1.基本概念</strong></p><p>总体：研究对象的全体，它是一个随机变量，用$X$表示。</p><p>个体：组成总体的每个基本元素。</p><p>简单随机样本：来自总体$X$的$n$个相互独立且与总体同分布的随机变量$X_{1},X_{2}\cdots,X_{n}$，称为容量为$n$的简单随机样本，简称样本。</p><p>统计量：设$X_{1},X_{2}\cdots,X_{n},$是来自总体$X$的一个样本，$g(X_{1},X_{2}\cdots,X_{n})$）是样本的连续函数，且$g()$中不含任何未知参数，则称$g(X_{1},X_{2}\cdots,X_{n})$为统计量。</p><p>样本均值：$\overline{X} = \frac{1}{n}\sum_{i = 1}^{n}X_{i}$</p><p>样本方差：$S^{2} = \frac{1}{n - 1}\sum_{i = 1}^{n}{(X_{i} - \overline{X})}^{2}$</p><p>样本矩：样本$k$阶原点矩：$A_{k} = \frac{1}{n}\sum_{i = 1}^{n}X_{i}^{k},k = 1,2,\cdots$</p><p>样本$k$阶中心矩：$B_{k} = \frac{1}{n}\sum_{i = 1}^{n}{(X_{i} - \overline{X})}^{k},k = 1,2,\cdots$</p><p><strong>2.分布</strong></p><p>$\chi^{2}$分布：$\chi^{2} = X_{1}^{2} + X_{2}^{2} + \cdots + X_{n}^{2}\sim\chi^{2}(n)$，其中$X_{1},X_{2}\cdots,X_{n},$相互独立，且同服从$N(0,1)$</p><p>$t$分布：$T = \frac{X}{\sqrt{Y/n}}\sim t(n)$ ，其中$X\sim N\left( 0,1 \right),Y\sim\chi^{2}(n),$且$X$，$Y$ 相互独立。</p><p>$F$分布：$F = \frac{X/n_{1}}{Y/n_{2}}\sim F(n_{1},n_{2})$，其中$X\sim\chi^{2}\left( n_{1} \right),Y\sim\chi^{2}(n_{2}),$且$X$，$Y$相互独立。</p><p>分位数：若$P(X \leq x_{\alpha}) = \alpha,$则称$x_{\alpha}$为$X$的$\alpha$分位数</p><p><strong>3.正态总体的常用样本分布</strong></p><p>(1) 设$X_{1},X_{2}\cdots,X_{n}$为来自正态总体$N(\mu,\sigma^{2})$的样本，</p><p>$\overline{X} = \frac{1}{n}\sum_{i = 1}^{n}X_{i},S^{2} = \frac{1}{n - 1}\sum_{i = 1}^{n}{(X_{i} - \overline{X})^{2},}$则：</p><p>1) $\overline{X}\sim N\left( \mu,\frac{\sigma^{2}}{n} \right){\ \ }$或者$\frac{\overline{X} - \mu}{\frac{\sigma}{\sqrt{n}}}\sim N(0,1)$</p><p>2) $\frac{(n - 1)S^{2}}{\sigma^{2}} = \frac{1}{\sigma^{2}}\sum_{i = 1}^{n}{(X_{i} - \overline{X})^{2}\sim\chi^{2}(n - 1)}$</p><p>3) $\frac{1}{\sigma^{2}}\sum_{i = 1}^{n}{(X_{i} - \mu)^{2}\sim\chi^{2}(n)}$</p><p>4)${\ \ }\frac{\overline{X} - \mu}{S/\sqrt{n}}\sim t(n - 1)$</p><p><strong>4.重要公式与结论</strong></p><p>(1) 对于$\chi^{2}\sim\chi^{2}(n)$，有$E(\chi^{2}(n)) = n,D(\chi^{2}(n)) = 2n;$</p><p>(2) 对于$T\sim t(n)$，有$E(T) = 0,D(T) = \frac{n}{n - 2}(n &gt; 2)$；</p><p>(3) 对于$F\tilde{\ }F(m,n)$，有 $\frac{1}{F}\sim F(n,m),F_{a/2}(m,n) = \frac{1}{F_{1 - a/2}(n,m)};$</p><p>(4) 对于任意总体$X$，有 $E(\overline{X}) = E(X),E(S^{2}) = D(X),D(\overline{X}) = \frac{D(X)}{n}$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;机器学习的数学基础&quot;&gt;&lt;a href=&quot;#机器学习的数学基础&quot; class=&quot;headerlink&quot; title=&quot;机器学习的数学基础&quot;&gt;&lt;/a&gt;机器学习的数学基础&lt;/h1&gt;&lt;h1 id=&quot;高等数学&quot;&gt;&lt;a href=&quot;#高等数学&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="机器学习" scheme="https://loopvoid.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>BP神经网络原理和简明理解</title>
    <link href="https://loopvoid.github.io/2019/09/14/BP%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E5%92%8C%E7%AE%80%E6%98%8E%E7%90%86%E8%A7%A3/"/>
    <id>https://loopvoid.github.io/2019/09/14/BP神经网络原理和简明理解/</id>
    <published>2019-09-14T02:48:09.000Z</published>
    <updated>2019-09-28T15:06:26.817Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单个神经元结构"><a href="#单个神经元结构" class="headerlink" title="单个神经元结构"></a>单个神经元结构</h1><p><img src="//loopvoid.github.io/2019/09/14/BP神经网络原理和简明理解/bp1.jpg" alt="bp1"></p><ul><li><p>输入：$x_1,x_2,…,x_n$</p></li><li><p>输出：$y$</p></li><li><p>输入和输出的关系(函数)：$y = (x_1\ast w_1+x_2\ast w_2+…+x_n\ast w_n+)+b = \sum_{i=1}^n x_i\ast w_i+b$，其中$w_i$是权重</p></li><li><p>将输入用矩阵表示：$X = [x_1,x_2,…,x_n]^T,X为一个n行1列的矩阵$</p></li><li><p>将权重用矩阵表示：$W=[w_1,x_2,…,w_n]$</p></li><li><p>那么输出可以表示为：$y=[w_1.w_2,…,w_n] \cdot [x_1,_2,…,x_n]^T+b=WX+b$</p></li></ul><h1 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h1><p>激活函数是一类复杂的问题，为便于理解这里有几条重要的特性：</p><ul><li><strong>非线性</strong>：即导数不是常数，不然求导之后退化为直线。对于一些画一条直线仍然无法分开的问题，非线性可以把直线掰弯，自从变弯以后，就能包罗万象了。</li><li><strong>几乎处处可导</strong>：数学上，处处可导为后面的后向传播算法（BP算法）提供了核心条件。</li><li><strong>输出范围有限</strong>：一般是限定在[0,1]，有限的输出范围使得神经元对于一些比较大的输入也会比较稳定。</li><li><strong>非饱和性</strong>：饱和就是指，当输入比较大的时候，输出几乎没变化了，那么会导致梯度消失！梯度消失带来的负面影响就是会限制了神经网络表达能力。<strong>sigmoid</strong>，<strong>tanh</strong>函数都是软饱和的，<strong>阶跃函数</strong>是硬饱和。<strong>软</strong>是指输入趋于无穷大的时候输出无限接近上线，<strong>硬</strong>是指像阶跃函数那样，输入非0输出就已经始终都是上限值。关于数学表示<strong><a href="https://www.cnblogs.com/rgvb178/p/6055213.html" target="_blank" rel="noopener">传送门</a></strong>里面有详细写到。如果激活函数是饱和的，带来的缺陷就是系统迭代更新变慢，系统收敛就慢，当然这是可以有办法弥补的，一种方法是使用交叉熵函数作为损失函数。<strong>ReLU</strong>是非饱和的，效果挺不错。</li><li><strong>单调性</strong>：即导数符号不变。导出要么一直大于0，要么一直小于0，不要上蹿下跳。导数符号不变，让神经网络训练容易收敛。</li></ul><p>这里用到<strong>Sigmoid</strong>函数方便理解：</p><p>Sigmoid函数：<script type="math/tex">y = \frac{1}{e^{(-x)}+1}</script></p><p><img src="//loopvoid.github.io/2019/09/14/BP神经网络原理和简明理解/bp2.jpg" alt="bp2"></p><p>S函数的导数：</p><script type="math/tex; mode=display">\begin{aligned}&y'= (\frac{1}{e^{-x}+1})' \\\\ &=(\frac{u}{v})',这里u=1,v=e^{-x}+1 \\\\ &=\frac{u'v-uv'}{v^2} \\\\ &=\frac{1'\ast (e^{-x}+1)-1\ast (e^{-x}+1)'}{(e^{-x}+1)^2} \\\\ &=\frac{e^{-x}}{(e^{-x}+1)^2} \\\\ &=\frac{1}{1+e^{-x}}\ast \frac{1+e^{-x}-1}{1+e^{-x}} \\\\ &=\frac{1}{1+e^{-x}}\ast (1-\frac{1}{1+e^{-x}}), 令y=\frac{1}{e^{-x}+1} \\\\ &=y\ast (1-y)\end{aligned}</script><p>S函数的导数的图像：</p><p><img src="//loopvoid.github.io/2019/09/14/BP神经网络原理和简明理解/bp3.jpg" alt="bp3"></p><h1 id="传播过程"><a href="#传播过程" class="headerlink" title="传播过程"></a>传播过程</h1><p>下面是一个典型的三层神经网络结构，第一层是输入层，第二层是隐藏层，第三层是输出层。</p><p><img src="//loopvoid.github.io/2019/09/14/BP神经网络原理和简明理解/bp4.jpg" alt="bp4"></p><ul><li><strong>正向传播</strong>：输入$i_1,i_2$数据，然后一层一层传播下去，知道输出层输出结果。</li><li><strong>反向传播</strong>：输入、期望的输出为已知。在开始时，权重$w$,偏置$b$初始化为随机值，按网络计算后观察结果。根据结果的<strong>误差</strong>(也叫损失)，调整权重$w$,偏置$b$，这时就完成了一次反向传播。</li><li>当完成了一次正反向传播，也就完成了一次神经网络的训练迭代，反复迭代，误差越来越小，直至训练完成。</li></ul><h1 id="BP算法推导和数值计算"><a href="#BP算法推导和数值计算" class="headerlink" title="BP算法推导和数值计算"></a>BP算法推导和数值计算</h1><h2 id="初始化参数"><a href="#初始化参数" class="headerlink" title="初始化参数"></a>初始化参数</h2><ul><li>输入：$i_1=0.1,i_2=0.2$</li><li>输出：$O_1=0.01,O_2=0.99,(训练时的输出期望值)$</li><li>权重：$ \begin{aligned} &amp;w_1=0.1,w_2=0.2,w_3=0.3,w_4=0.4 \\\\ &amp;w_5=0.5,w_6=0.6,w_7=0.7,w_8=0.8 \\\\ &amp;(这些权重是随机初始化的，通过多次迭代训练调整直到训练完成)\end{aligned} $</li><li>偏置：$b_1=0.55,b_2=0.56,b_3=0.66,b_4=0.67 \\\\ (同随机初始化)$</li></ul><h2 id="正向传播"><a href="#正向传播" class="headerlink" title="正向传播"></a>正向传播</h2><ul><li>输入层—&gt;隐藏层：<ul><li>计算<strong>隐藏层</strong>神经元$h_1$的输入加权和：<script type="math/tex">\begin{aligned} IN_{h1}&=w_1\ast i_1+w_2\ast i_2+1\ast b_1 \\\\ &=0.1\ast 0.1+0.2\ast 0.2+1\ast 0.55 \\\\ &=0.6\end{aligned}</script></li><li>计算<strong>隐藏层</strong>神经元$h_1$的输出，要通过激活函数Sigmoid处理：<script type="math/tex">OUT_{h1}=\frac{1}{e^{-IN_{h1}}+1} \\ =\frac{1}{e^{-0.6}+1} \\ =0.6456563062</script></li><li>同理计算出<strong>隐藏层</strong>神经元$h_2$的输出：<script type="math/tex">OUT_{h2}=0.6592603884</script></li></ul></li><li>隐藏层—&gt;输出层：<ul><li>计算<strong>输出层</strong>神经元$O_1$的<strong>输入</strong>加权和：<script type="math/tex">\begin{aligned}IN_{O_1}&=w_5\ast OUT_{h_1}+w_6\ast OUT_{h_2}+1\ast b_3 \\\\ &=0.5\ast 0.6456563062+0.6\ast 0.6592603884+1\ast 0.66 \\\\ &=1.3783843861\end{aligned}</script></li><li>计算<strong>输出层</strong>神经元$O_1$的输出：<script type="math/tex">OUT_{O_1}=\frac{1}{e^{-IN_{O_1}}+1} \\ =\frac{1}{e^{-1.3783843861}}\\ =0.7987314002</script></li><li>同理计算出<strong>输出层</strong>神经元$O_2$的输出：<script type="math/tex">OUT_{O_2}=0.8374488853</script></li></ul></li></ul><p>正向传播结束，可以看到输出层输出的结果：$[0.7987314002,0.8374488853]$，但是训练数据的期望输出是$[0.01,0.99]$，相差太大，这时就需要利用反向传播，更新权重$w$，然后重新计算输出。</p><h2 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h2><h3 id="计算输出误差："><a href="#计算输出误差：" class="headerlink" title="计算输出误差："></a>计算输出误差：</h3><ul><li>误差计算：<script type="math/tex">\begin{aligned} E_{total}&=\sum_{i=1}^2E_{OUT_{O_i}} \\\\ &=E_{OUT_{O_1}} + E_{OUT_{O_2}} \\\\ &=\frac{1}{2}(expected_{OUT_{O_1}}-OUT_{O_1})^2+\frac{1}{2}(expected_{OUT_{O_2}}-OUT_{O_2})^2 \\\\ &=\frac{1}{2}\ast (O_1-OUT_{O_1})^2+\frac{1}{2}\ast (O_2-OUT_{O_2})^2 \\\\ &=\frac{1}{2}\ast (0.01-0.7987314002)^2+\frac{1}{2}\ast (0.99-0.8374488853)^2 \\\\ &=0.0116359213+0.3110486109 \\\\ &=0.3226845322 \\\\ &其中：E_{OUT_{O_1}}=0.0116359213,E_{OUT_{O_2}}= 0.3110486109 \end{aligned}</script></li><li>PS:这里使用这个简单的误差计算便于理解，实际上其效果有待提高。如果激活函数是饱和的，带来的缺陷就是系统迭代更新变慢，系统收敛就慢，当然这是可以有办法弥补的，一种方法是使用<strong>交叉熵函数</strong>作为损失函数。<a href="https://blog.csdn.net/lanchunhui/article/details/50086025" target="_blank" rel="noopener">这里</a>有更详细的介绍。</li><li>交叉熵损失函数：<script type="math/tex">E_{total}=\frac{1}{m}\sum_{i=1}^m(O_i\cdot log OUT_{O_i}+(1-O_i)\cdot log(1-OUT_{O_i}))</script></li><li>对输出求偏导：<script type="math/tex">\frac{\partial E_{total}}{\partial OUT_{O_i}}=\frac{1}{m}\sum_{i=1}^m(\frac{O_i}{OUT_{O_i}}-\frac{1-O_i}{1-OUT_{O_i}})</script><h3 id="隐藏层—-gt-输出层的权重的更新："><a href="#隐藏层—-gt-输出层的权重的更新：" class="headerlink" title="隐藏层—&gt;输出层的权重的更新："></a>隐藏层—&gt;输出层的权重的更新：</h3></li><li>链式求导法则(详细可参考<a href="https://loopvoid.github.io/2018/10/15/自动微分法/">这篇文章</a>：<script type="math/tex">假设y是u的函数，而u是x的函数：y=f(u),u=g(x) \\ 那么对应的复合函数就是：y=f(g(x)) \\ 那么y对x的导数则有：\frac{dy}{dx}=\frac{dy}{du}\cdot \frac{du}{dx}</script></li><li><p>以权重$w_5$举例计算：权重$w$的大小能直接影响输出，$w$不合适会使输出有误差。要知道某个$w$对误差影响的程度，可以用<strong>误差对该$w$的变化率</strong>来表达。如果$w$的很少的变化，会导致误差增大很多，说明这个$w$对误差影响的程度就更大，也就是说，误差对该$w$的变化率越高。而误差对$w$的变化率就是误差对$w$的偏导。如图，总误差的大小首先受输出层神经元$O_1$的输出影响，继续反推，$O_1$的输出受它自己的输入的影响，而它自己的输入会受到$w_5$的影响。<img src="//loopvoid.github.io/2019/09/14/BP神经网络原理和简明理解/bp5.jpg" alt="bp5"></p></li><li><p>那么根据链式法则有：<script type="math/tex">\begin{aligned} \frac{\partial E_{total}}{\partial w_5}&=\frac{\partial E_{total}}{\partial OUT_{O_1}}\frac{\partial OUT_{O_1}}{\partial IN_{O_1}}\frac{\partial IN_{O_1}}{\partial w_5}\end{aligned}</script></p></li><li>第一部分： <script type="math/tex">\begin{aligned}  \because E_{total}&=\frac{1}{2}(O_1-OUT_{O_1})^2+\frac{1}{2}(O_2-OUT_{O_2})^2 \\\\  \therefore \frac{\partial E_{total}}{\partial OUT_{O_1}}&=\frac{\partial (\frac{1}{2}(O_1-OUT_{O_1})^2+\frac{1}{2}(O_2-OUT_{O_2})^2)}{\partial OUT_{O_1}} \\\\ &  =2\ast \frac{1}{2}(O_1-OUT_{O_1})^{2-1}\ast (0-1)+0 \\\\ &  =-(O_1-OUT_{O_1}) \\\\ &  =-(0.01-0.7987314002) \\\\ &  =0.7887314002 \end{aligned}</script></li><li>第二部分：<script type="math/tex">\begin{aligned}\because OUT_{O_1}&=\frac{1}{e^{-IN_{O_1}}+1} \\\\ \therefore \frac{\partial OUT_{O_1}}{\partial IN_{O_1}}&=\frac{\partial (\frac{1}{e^{-IN_{O_1}}+1})}{\partial IN_{O_1}} \\\\ & =OUT_{O_1}(1-OUT_{O_1}) \\\\ &=0.7987314002*(1-0.7987314002) \\\\ &=0.1607595505 \end{aligned}</script></li><li>第三部分：<script type="math/tex">\begin{aligned} \because IN_{O_1}&=w_5\ast OUT_{h_1}+w_6\ast OUT_{h_2}+1\ast b_3 \\\\  \therefore \frac{\partial IN_{O_1}}{\partial w_5}&=\frac{\partial (w_5\ast OUT_{h_1}+w_6\ast OUT_{H}+1\ast b_3)}{\partial w_5} \\\\ &=1\ast w_5^{(1-1)}\ast OUT_{h_1}+0+0 \\\\ &=OUT_{h_1} \\\\ &=0.6456563062\end{aligned}</script></li><li>所以：<script type="math/tex">\begin{aligned}\frac{\partial E_{total}}{\partial w_5}&=\frac{\partial E_{total}}{\partial OUT_{O_1}}\frac{\partial OUT_{O_1}}{\partial IN_{O_1}}\frac{\partial IN_{O_1}}{\partial w_5} \\\\ &=0.7887314002\ast 0.1607595505\ast 0.6456563062\\\\ &=0.0818667051\end{aligned}</script></li><li>归纳如下：<script type="math/tex">\begin{aligned}\frac{\partial E_{total}}{\partial w_5}&=\frac{\partial E_{total}}{\partial OUT_{O_1}}\frac{\partial OUT_{O_1}}{\partial IN_{O_1}}\frac{\partial IN_{O_1}}{\partial w_5} \\\\ &=-(O_1-OUT_{O_1})\cdot OUT_{O_1}\cdot (1-OUT_{O_1})\cdot OUT_{h_1}\\\\ &=\sigma_{O_1}\cdot OUT_{h_1} \\\\ & 其中，\sigma_{O_1}=-(O_1-OUT_{O_1})\cdot OUT_{O_1}\cdot (1-OUT_{O_1})\end{aligned}</script><h3 id="隐藏层—-gt-输出层的偏置的更新："><a href="#隐藏层—-gt-输出层的偏置的更新：" class="headerlink" title="隐藏层—&gt;输出层的偏置的更新："></a>隐藏层—&gt;输出层的偏置的更新：</h3></li><li>同理<strong>输出层</strong>偏置b更新如下：<script type="math/tex">\begin{aligned} IN_{O_1}&=w_5\ast OUT_{h_1}+w_6\ast OUT_{h_2}+1\ast b_3 \\\\ \frac{\partial IN_{O_1}}{\partial b_3}&=\frac{w_5\ast OUT_{h_1}+w_6\ast OUT_{h_2}+1\ast b_3}{\partial b_3} \\\\ &=0+0+b_3^{(1-1)} \\\\&=1  \end{aligned}</script> </li><li>所以：<script type="math/tex">\begin{aligned}\frac{\partial E_{total}}{\partial b_3}&=\frac{\partial E_{total}}{\partial OUT_{O_1}}\frac{\partial OUT_{O_1}}{\partial IN_{O_1}}\frac{\partial IN_{O_1}}{\partial b_3} \\\\ &=0.7887314002\ast 0.1607595505\ast 1\\\\ &=0.1267961053\end{aligned}</script></li><li>归纳如下：   <script type="math/tex">\begin{aligned} \frac{\partial E_{total}}{\partial b_3}&=\frac{\partial E_{total}}{\partial OUT_{O_1}}\frac{\partial OUT_{O_1}}{\partial IN_{O_1}}\frac{\partial IN_{O_1}}{\partial b_3}\\\\ &=-(O_1-OUT_{O_1})\cdot OUT_{O_1}\cdot (1-OUT_{O_1})\cdot 1\\\\ &=\sigma_{O_1}\\\\ &其中,\sigma_{O_1}=-(O_1-OUT_{O_1})\cdot OUT_{O_1}\cdot (1-OUT_{O_1})  \end{aligned}</script></li></ul><h3 id="更新-w-5-的值："><a href="#更新-w-5-的值：" class="headerlink" title="更新$w_5$的值："></a>更新$w_5$的值：</h3><ul><li>暂时设定学习率为<strong>0.5</strong>，学习率不宜过大也不宜过小，<a href="https://blog.csdn.net/qq_41204464/article/details/83660728" target="_blank" rel="noopener">这篇文章</a>学习率有更为详细的介绍，更新$w_5$：<script type="math/tex">\begin{aligned}w_5^+&=w_5-\alpha \cdot \frac{\partial E_{total}}{\partial w_5} \\\\ &=0.5-0.5\ast 0.0818667051\\\\ &=0.45906664745\end{aligned}</script></li><li>同理可以计算出其他$w_n$的值</li><li>归纳输出层$w$的更新公式：<script type="math/tex">\begin{aligned}w_O^+&=w_o-\alpha \cdot (-OUT_O\cdot (1-OUT_O)\cdot (O-OUT_O)\cdot OUT_h)\\\\ &=w_O+\alpha \cdot (O-OUT_O)\cdot OUT_O\cdot (1-OUT_O)\cdot OUT_h\end{aligned}</script></li></ul><h3 id="更新-b-3-的值："><a href="#更新-b-3-的值：" class="headerlink" title="更新$b_3$的值："></a>更新$b_3$的值：</h3><ul><li>更新偏置b：<script type="math/tex">\begin{aligned}b_3^+&=b_{O_3}-\alpha \cdot \frac{\partial E_{total}}{\partial b_{O_3}} \\\\ &=0.66-0.5\cdot 0.1267961053\\\\ &=0.596601947 \end{aligned}</script></li><li>归纳如下：<script type="math/tex">\begin{aligned}b_O^+&=b_O-\alpha \cdot(-OUT_O\cdot(1-OUT_O)\cdot(O_OUT_O))\\\\ &=b_O+\alpha \cdot (O-OUT_O)\cdot OUT_O\cdot(1-OUT_O)\end{aligned}</script></li></ul><h3 id="输入层—-gt-隐藏层的权值更新："><a href="#输入层—-gt-隐藏层的权值更新：" class="headerlink" title="输入层—&gt;隐藏层的权值更新："></a>输入层—&gt;隐藏层的权值更新：</h3><ul><li>以权重$w_1$举例计算：在求$w_5$的更新，误差反向传递路径输出层—&gt;隐层，即$OUT_{O_1}-&gt;IN_{O_1}-&gt;w_5$，总误差只有一条路径能传回来。但是求$w_1$时，误差反向传递路径是隐藏层—&gt;输入层，但是隐藏层的神经元是有2条的，所以总误差沿着2个路径回来，也就是说，计算偏导时，要分开来算。<img src="//loopvoid.github.io/2019/09/14/BP神经网络原理和简明理解/bp6.jpg" alt="bp6"></li></ul><h3 id="计算总误差对-w-1-的偏导："><a href="#计算总误差对-w-1-的偏导：" class="headerlink" title="计算总误差对$w_1$的偏导："></a>计算总误差对$w_1$的偏导：</h3><script type="math/tex; mode=display">\begin{aligned}\frac{\partial E_{total}}{\partial w_1}&=\frac{\partial E_{total}}{\partial OUT_{h_1}}\cdot \frac{\partial OUT_{h_1}}{\partial IN_{h_1}}\cdot \frac{\partial IN_{h_1}}{\partial w_1} \\\\ &=(\frac{\partial E_{O_1}}{\partial OUT_{h_1}}+\frac{\partial E_{O_2}}{\partial OUT_{h_1}})\cdot \frac{\partial OUT_{h_1}}{\partial IN_{h_1}}\cdot \frac{\partial IN_{h_1}}{\partial w_1}\end{aligned}</script><ul><li>计算$E_{O_1}对OUT_{h_1}$的偏导：<script type="math/tex">\begin{aligned}\frac{\partial E_{total}}{\partial OUT_{h_1}} &= \frac{\partial E_{O_1}}{\partial OUT_{h_1}}+\frac{\partial E_{O_2}}{\partial OUT_{h_1}}\\\\ \frac{\partial E_{O_1}}{\partial OUT_{h_1}}&=\frac{\partial E_{O_1}}{\partial IN_{O_1}}\cdot\frac{\partial IN_{O_1}}{\partial OUT_{h_1}} \\\\ (左边)\frac{\partial E_{O_1}}{\partial IN_{O_1}}&=\frac{\partial E_{O_1}}{\partial OUT_{O_1}}\cdot\frac{\partial OUT_{O_1}}{\partial IN_{O_1}}\\\\ &=\frac{\frac{1}{2}(O_1-OUT_{O_1})^2}{\partial OUT_{O_1}}\cdot \frac{\partial OUT_{O_1}}{\partial IN_{O_1}}\\\\ &=-(O_1-OUT_{O_1})\cdot \frac{\partial OUT_{O_1}}{\partial IN_{O_1}}\\\\ &=0.7987314002\ast 0.1607595505\\\\ &=0.1284037009\\\\IN_{O_1}&=w_5\ast OUT_{h_1}+w_6\ast OUT_{h_2}+1\ast b_3\\\\ (右边)\frac{\partial IN_{O_1}}{\partial OUT_{h_1}}&=\frac{\partial (w_5\ast OUT_{h_1}+w_6\ast OUT_{h_2}+1\ast b_3)}{\partial OUT_{h_1}}\\\\ &=w_5\ast OUT_{h_1}^{(1-1)}+0+0\\\ &=w_5=0.5 \\\\ \frac{\partial E_{O_1}}{\partial OUT_{h_1}} &=\frac{\partial E_{O_1}}{\partial IN_{O_1}}\cdot \frac{\partial IN_{O_1}}{\partial OUT_{h_1}}\\\\ &=0.1284037009\ast 0.5=0.06420185045\end{aligned}</script></li><li>j计算$E_{O_2}对OUT_{h_1}$的偏导：<script type="math/tex">\begin{aligned}\frac{\partial E_{O_2}}{\partial OUT_{h_1}}&=\frac{\partial E_{O_2}}{\partial IN_{O_2}}\cdot\frac{\partial IN_{O_2}}{\partial OUT_{h_1}}\\\\ &=-(O_2-OUT_{O_2})\cdot \frac{\partial OUT_{O_2}}{\partial IN_{O_2}}\cdot \frac{\partial IN_{O_2}}{\partial OUT_{h_1}}\\\\ &=-(O_2-OUT_{O_2})\cdot OUT_{O_2}(1-OUT_{O_2})\cdot w_7\\\\ &=-(0.99-0.8374488853)\ast 0.8374488853\ast (1-0.8374488853)\ast 0.7=-0.0145365614\end{aligned}</script></li><li>则$E_{total}对OUT_{h_1}$的偏导为：<script type="math/tex">\begin{aligned}\frac{\partial E_{total}}{\partial OUT_{h_1}} &= \frac{\partial E_{O_1}}{\partial OUT_{h_1}}+\frac{\partial E_{O_2}}{\partial OUT_{h_1}}\\\\ &=0.06420185045+(-0.0145365614)=0.04966528905\end{aligned}</script></li><li>计算$OUT_{h_1}$对$IN_{h_1}$的偏导：<script type="math/tex">\begin{aligned}\because OUT_{h_1}&=\frac{1}{e^{-IN_{h_1}}+1} \\\\ \therefore \frac{\partial OUT_{h_1}}{\partial IN_{h_1}}&= \frac{\partial (\frac{1}{e^{-IN_{h_1}}+1})}{\partial IN_{h_1}} \\\\ &=OUT(1-OUT_{h_1})\\\\ &=0.6456563062\ast (1-0.6456563062)=0.2298942405 \end{aligned}</script></li><li>计算$IN_{h_1}对w_1$的偏导：<script type="math/tex">\begin{aligned}\frac{\partial IN_{h_1}}{\partial w_1}&=\frac{\partial(w_1\ast i_1+w_2\ast i_2+1\ast b)}{\partial w_1}\\\\ &=w_1^{(1-1)}\ast i_1+0+0=i_1=0.1\end{aligned}</script></li><li>三者相乘计算$E_{total}$对$w_1$的偏导：<script type="math/tex">\begin{aligned}\frac{\partial E_{total}}{\partial w_1}&=\frac{\partial E_{total}}{\partial OUT_{h_1}}\cdot \frac{\partial OUT_{h_1}}{\partial IN_{h_1}}\cdot \frac{\partial IN_{h_1}}{\partial w_1}\\\\ &=0.04966528905\ast 0.2298942405\ast 0.1=0.0011362635\end{aligned}</script></li><li>归纳：<script type="math/tex">\begin{aligned}\frac{\partial E_{total}}{\partial w_1}&=\frac{\partial E_{total}}{\partial OUT_{h_1}}\cdot \frac{\partial OUT_{h_1}}{\partial IN_{h_1}}\cdot \frac{\partial IN_{h_1}}{\partial w_1}\\\\ &=(\frac{\partial E_{O_1}}{\partial OUT_{h_1}}+\frac{\partial E_{O_2}}{\partial OUT_{h_1}})\cdot \frac{\partial OUT_{h_1}}{\partial IN_{h_1}}\cdot \frac{\partial IN_{h_1}}{\partial w_1}\\\\ &=(\sum_{n=1}^2\frac{\partial E_{O_n}}{\partial OUT_{O_n}}\cdot\frac{\partial OUT_{O_n}}{\partial IN_{O_n}}\cdot \frac{\partial IN_{O_n}}{\partial OUT_{h_n}})\cdot \frac{\partial OUT_{h_1}}{\partial IN_{h_1}}\cdot \frac{\partial IN_{h_1}}{\partial w_1}\\\\ &=(\sum_{n=1}^2\sigma_{O_n}w_{O_n})\cdot OUT_{h_n}(1-OUT_{h_n})\cdot i_1\\\\ &=\sigma_{h_1}\cdot i_1\\\\&其中，\sigma_{h_1}=(\sum_{n=1}^2\sigma_{O_n}w_{O_n})\cdot OUT_{h_1}(1-OUT_{h_1})\\\\&\sigma_{O_i}看作输出层的误差，误差和w相乘，相当于通过w传播了过来；如果是深层网络，隐藏层数量>1，那么公式中的\sigma_{O_n}写为\sigma_{h_n}，w_O写成w_h\end{aligned}</script></li><li>现在更新$w_1$的值：<script type="math/tex">\begin{aligned}w_1^+&=w_1-\alpha\cdot \frac{\partial E_{total}}{\partial w_1}\\\\ &=0.1-0.1\ast 0.0011362635=0.0998863737\end{aligned}</script></li><li>归纳隐藏层$w$更新的公式：<script type="math/tex">\begin{aligned}w_h^+&=w_h-\alpha\cdot \frac{\partial E_{total}}{\partial w}\\\\ &=w_h+\alpha\cdot (-\sum_{n=1}^2\sigma_{O_n}w_{O_n})\cdot OUT_{h_n}(1-OUT_{h_n})\cdot i_1\end{aligned}</script><h3 id="计算隐藏层偏置b的更新："><a href="#计算隐藏层偏置b的更新：" class="headerlink" title="计算隐藏层偏置b的更新："></a>计算隐藏层偏置b的更新：</h3></li></ul><script type="math/tex; mode=display">\begin{aligned}\frac{\partial E_{total}}{\partial b_h}&=(\sum_h\sigma_hw_h)\cdot OUT_h(1-OUT_h)\\\\ b_h^+&=b_h-\alpha\cdot \frac{\partial E_{total}}{\partial b_n}\\\\ &=w_h+\alpha\cdot (\sum_h\sigma_hw_h)\cdot OUT_h(1-OUT_h)\end{aligned}</script><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> h5py</span><br><span class="line"><span class="keyword">import</span> sklearn.datasets</span><br><span class="line"><span class="keyword">import</span> sklearn.linear_model</span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line"><span class="keyword">import</span> matplotlib.font_manager <span class="keyword">as</span> fm</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">np.random.seed(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">font = fm.FontProperties(fname=<span class="string">'/System/Library/Fonts/STHeiti Light.ttc'</span>)</span><br><span class="line">matplotlib.rcParams[<span class="string">'figure.figsize'</span>] = (<span class="number">10.0</span>, <span class="number">8.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(input_sum)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    函数：</span></span><br><span class="line"><span class="string">        激活函数Sigmoid</span></span><br><span class="line"><span class="string">    输入：</span></span><br><span class="line"><span class="string">        input_sum: 输入，即神经元的加权和</span></span><br><span class="line"><span class="string">    返回：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        output: 激活后的输出</span></span><br><span class="line"><span class="string">        input_sum: 把输入缓存起来返回</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    output = <span class="number">1.0</span>/(<span class="number">1</span>+np.exp(-input_sum))</span><br><span class="line">    <span class="keyword">return</span> output, input_sum</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid_back_propagation</span><span class="params">(derror_wrt_output, input_sum)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    函数：</span></span><br><span class="line"><span class="string">        误差关于神经元输入的偏导: dE／dIn = dE/dOut * dOut/dIn  参照式（5.6）</span></span><br><span class="line"><span class="string">        其中： dOut/dIn 就是激活函数的导数 dy=y(1 - y)，见式（5.9）</span></span><br><span class="line"><span class="string">              dE/dOut 误差对神经元输出的偏导，见式（5.8）</span></span><br><span class="line"><span class="string">    输入：</span></span><br><span class="line"><span class="string">        derror_wrt_output：误差关于神经元输出的偏导: dE/dyⱼ = 1/2(d(expect_to_output - output)**2/doutput) = -(expect_to_output - output)</span></span><br><span class="line"><span class="string">        input_sum: 输入加权和</span></span><br><span class="line"><span class="string">    返回：</span></span><br><span class="line"><span class="string">        derror_wrt_dinputs: 误差关于输入的偏导，见式（5.13）</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    output = <span class="number">1.0</span>/(<span class="number">1</span> + np.exp(- input_sum))</span><br><span class="line">    doutput_wrt_dinput = output * (<span class="number">1</span> - output)</span><br><span class="line">    derror_wrt_dinput =  derror_wrt_output * doutput_wrt_dinput</span><br><span class="line">    <span class="keyword">return</span> derror_wrt_dinput</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">relu</span><span class="params">(input_sum)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        函数：</span></span><br><span class="line"><span class="string">            激活函数ReLU</span></span><br><span class="line"><span class="string">        输入：</span></span><br><span class="line"><span class="string">            input_sum: 输入，即神经元的加权和</span></span><br><span class="line"><span class="string">        返回：</span></span><br><span class="line"><span class="string">            outputs: 激活后的输出</span></span><br><span class="line"><span class="string">            input_sum: 把输入缓存起来返回</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    output = np.maximum(<span class="number">0</span>, input_sum)</span><br><span class="line">    <span class="keyword">return</span> output, input_sum</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">relu_back_propagation</span><span class="params">(derror_wrt_output, input_sum)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        函数：</span></span><br><span class="line"><span class="string">            误差关于神经元输入的偏导: dE／dIn = dE/dOut * dOut/dIn</span></span><br><span class="line"><span class="string">            其中： dOut/dIn 就是激活函数的导数</span></span><br><span class="line"><span class="string">                  dE/dOut 误差对神经元输出的偏导</span></span><br><span class="line"><span class="string">        输入：</span></span><br><span class="line"><span class="string">            derror_wrt_output：误差关于神经元输出的偏导</span></span><br><span class="line"><span class="string">            input_sum: 输入加权和</span></span><br><span class="line"><span class="string">        返回：</span></span><br><span class="line"><span class="string">            derror_wrt_dinputs: 误差关于输入的偏导</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    derror_wrt_dinputs = np.array(derror_wrt_output, copy=<span class="literal">True</span>)</span><br><span class="line">    derror_wrt_dinputs[input_sum &lt;= <span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> derror_wrt_dinputs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tanh</span><span class="params">(input_sum)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    函数：</span></span><br><span class="line"><span class="string">        激活函数 tanh</span></span><br><span class="line"><span class="string">    输入：</span></span><br><span class="line"><span class="string">        input_sum: 输入，即神经元的加权和</span></span><br><span class="line"><span class="string">    返回：</span></span><br><span class="line"><span class="string">        output: 激活后的输出</span></span><br><span class="line"><span class="string">        input_sum: 把输入缓存起来返回</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    output = np.tanh(input_sum)</span><br><span class="line">    <span class="keyword">return</span> output, input_sum</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tanh_back_propagation</span><span class="params">(derror_wrt_output, input_sum)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    函数：</span></span><br><span class="line"><span class="string">        误差关于神经元输入的偏导: dE／dIn = dE/dOut * dOut/dIn</span></span><br><span class="line"><span class="string">        其中： dOut/dIn 就是激活函数的导数 tanh'(x) = 1 - x²</span></span><br><span class="line"><span class="string">              dE/dOut 误差对神经元输出的偏导</span></span><br><span class="line"><span class="string">    输入：</span></span><br><span class="line"><span class="string">        derror_wrt_output：误差关于神经元输出的偏导: dE/dyⱼ = 1/2(d(expect_to_output - output)**2/doutput) = -(expect_to_output - output)</span></span><br><span class="line"><span class="string">        input_sum: 输入加权和</span></span><br><span class="line"><span class="string">    返回：</span></span><br><span class="line"><span class="string">        derror_wrt_dinputs: 误差关于输入的偏导</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    output = np.tanh(input_sum)</span><br><span class="line">    doutput_wrt_dinput = <span class="number">1</span> - np.power(output, <span class="number">2</span>)</span><br><span class="line">    derror_wrt_dinput =  derror_wrt_output * doutput_wrt_dinput</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> derror_wrt_dinput</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">activated</span><span class="params">(activation_choose, input)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"""把正向激活包装一下"""</span></span><br><span class="line">    <span class="keyword">if</span> activation_choose == <span class="string">"sigmoid"</span>:</span><br><span class="line">        <span class="keyword">return</span> sigmoid(input)</span><br><span class="line">    <span class="keyword">elif</span> activation_choose == <span class="string">"relu"</span>:</span><br><span class="line">        <span class="keyword">return</span> relu(input)</span><br><span class="line">    <span class="keyword">elif</span> activation_choose == <span class="string">"tanh"</span>:</span><br><span class="line">        <span class="keyword">return</span> tanh(input)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sigmoid(input)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">activated_back_propagation</span><span class="params">(activation_choose, derror_wrt_output, output)</span>:</span></span><br><span class="line">    <span class="string">"""包装反向激活传播"""</span></span><br><span class="line">    <span class="keyword">if</span> activation_choose == <span class="string">"sigmoid"</span>:</span><br><span class="line">        <span class="keyword">return</span> sigmoid_back_propagation(derror_wrt_output, output)</span><br><span class="line">    <span class="keyword">elif</span> activation_choose == <span class="string">"relu"</span>:</span><br><span class="line">        <span class="keyword">return</span> relu_back_propagation(derror_wrt_output, output)</span><br><span class="line">    <span class="keyword">elif</span> activation_choose == <span class="string">"tanh"</span>:</span><br><span class="line">        <span class="keyword">return</span> tanh_back_propagation(derror_wrt_output, output)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sigmoid_back_propagation(derror_wrt_output, output)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NeuralNetwork</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, layers_strcuture, print_cost = False)</span>:</span></span><br><span class="line">        self.layers_strcuture = layers_strcuture</span><br><span class="line">        self.layers_num = len(layers_strcuture)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 除掉输入层的网络层数，因为其他层才是真正的神经元层</span></span><br><span class="line">        self.param_layers_num = self.layers_num - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        self.learning_rate = <span class="number">0.0618</span></span><br><span class="line">        self.num_iterations = <span class="number">2000</span></span><br><span class="line">        self.x = <span class="literal">None</span></span><br><span class="line">        self.y = <span class="literal">None</span></span><br><span class="line">        self.w = dict()</span><br><span class="line">        self.b = dict()</span><br><span class="line">        self.costs = []</span><br><span class="line">        self.print_cost = print_cost</span><br><span class="line"></span><br><span class="line">        self.init_w_and_b()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_learning_rate</span><span class="params">(self, learning_rate)</span>:</span></span><br><span class="line">        <span class="string">"""设置学习率"""</span></span><br><span class="line">        self.learning_rate = learning_rate</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_num_iterations</span><span class="params">(self, num_iterations)</span>:</span></span><br><span class="line">        <span class="string">"""设置迭代次数"""</span></span><br><span class="line">        self.num_iterations = num_iterations</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_xy</span><span class="params">(self, input, expected_output)</span>:</span></span><br><span class="line">        <span class="string">"""设置神经网络的输入和期望的输出"""</span></span><br><span class="line">        self.x = input</span><br><span class="line">        self.y = expected_output</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init_w_and_b</span><span class="params">(self)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        函数:</span></span><br><span class="line"><span class="string">            初始化神经网络所有参数</span></span><br><span class="line"><span class="string">        输入:</span></span><br><span class="line"><span class="string">            layers_strcuture: 神经网络的结构，例如[2,4,3,1]，4层结构:</span></span><br><span class="line"><span class="string">                第0层输入层接收2个数据，第1层隐藏层4个神经元，第2层隐藏层3个神经元，第3层输出层1个神经元</span></span><br><span class="line"><span class="string">        返回: 神经网络各层参数的索引表，用来定位权值 wᵢ  和偏置 bᵢ，i为网络层编号</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        np.random.seed(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 当前神经元层的权值为 n_i x n_(i-1)的矩阵，i为网络层编号，n为下标i代表的网络层的节点个数</span></span><br><span class="line">        <span class="comment"># 例如[2,4,3,1]，4层结构：第0层输入层为2，那么第1层隐藏层神经元个数为4</span></span><br><span class="line">        <span class="comment"># 那么第1层的权值w是一个 4x2 的矩阵，如：</span></span><br><span class="line">        <span class="comment">#    w1 = array([ [-0.96927756, -0.59273074],</span></span><br><span class="line">        <span class="comment">#                 [ 0.58227367,  0.45993021],</span></span><br><span class="line">        <span class="comment">#                 [-0.02270222,  0.13577601],</span></span><br><span class="line">        <span class="comment">#                 [-0.07912066, -1.49802751] ])</span></span><br><span class="line">        <span class="comment"># 当前层的偏置一般给0就行，偏置是个1xnᵢ的矩阵，nᵢ为第i层的节点个数，例如第1层为4个节点，那么：</span></span><br><span class="line">        <span class="comment">#    b1 = array([ 0.,  0.,  0.,  0.])</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> range(<span class="number">1</span>, self.layers_num):</span><br><span class="line">            self.w[<span class="string">"w"</span> + str(l)] = np.random.randn(self.layers_strcuture[l], self.layers_strcuture[l<span class="number">-1</span>])/np.sqrt(self.layers_strcuture[l<span class="number">-1</span>])</span><br><span class="line">            self.b[<span class="string">"b"</span> + str(l)] = np.zeros((self.layers_strcuture[l], <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> self.w, self.b</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">layer_activation_forward</span><span class="params">(self, x, w, b, activation_choose)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        函数：</span></span><br><span class="line"><span class="string">            网络层的正向传播</span></span><br><span class="line"><span class="string">        输入：</span></span><br><span class="line"><span class="string">            x: 当前网络层输入（即上一层的输出），一般是所有训练数据，即输入矩阵</span></span><br><span class="line"><span class="string">            w: 当前网络层的权值矩阵</span></span><br><span class="line"><span class="string">            b: 当前网络层的偏置矩阵</span></span><br><span class="line"><span class="string">            activation_choose: 选择激活函数 "sigmoid", "relu", "tanh"</span></span><br><span class="line"><span class="string">        返回:</span></span><br><span class="line"><span class="string">            output: 网络层的激活输出</span></span><br><span class="line"><span class="string">            cache: 缓存该网络层的信息，供后续使用： (x, w, b, input_sum) -&gt; cache</span></span><br><span class="line"><span class="string">     """</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 对输入求加权和，见式（5.1）</span></span><br><span class="line">        input_sum = np.dot(w, x) + b</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 对输入加权和进行激活输出</span></span><br><span class="line">        output, _ = activated(activation_choose, input_sum)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> output, (x, w, b, input_sum)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward_propagation</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        函数:</span></span><br><span class="line"><span class="string">            神经网络的正向传播</span></span><br><span class="line"><span class="string">        输入:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        返回:</span></span><br><span class="line"><span class="string">            output: 正向传播完成后的输出层的输出</span></span><br><span class="line"><span class="string">            caches: 正向传播过程中缓存每一个网络层的信息： (x, w, b, input_sum),... -&gt; caches</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        caches = []</span><br><span class="line"></span><br><span class="line">        <span class="comment">#作为输入层，输出 = 输入</span></span><br><span class="line">        output_prev = x</span><br><span class="line"></span><br><span class="line">        <span class="comment">#第0层为输入层，只负责观察到输入的数据，并不需要处理，正向传播从第1层开始，一直到输出层输出为止</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># range(1, n) =&gt; [1, 2, ..., n-1]</span></span><br><span class="line">        L = self.param_layers_num</span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> range(<span class="number">1</span>, L):</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 当前网络层的输入来自前一层的输出</span></span><br><span class="line">            input_cur = output_prev</span><br><span class="line">            output_prev, cache = self.layer_activation_forward(input_cur, self.w[<span class="string">"w"</span>+ str(l)], self.b[<span class="string">"b"</span> + str(l)], <span class="string">"tanh"</span>)</span><br><span class="line">            caches.append(cache)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        output, cache = self.layer_activation_forward(output_prev, self.w[<span class="string">"w"</span> + str(L)], self.b[<span class="string">"b"</span> + str(L)], <span class="string">"sigmoid"</span>)</span><br><span class="line">        caches.append(cache)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> output, caches</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_caches</span><span class="params">(self, caches)</span>:</span></span><br><span class="line">        <span class="string">"""显示网络层的缓存参数信息"""</span></span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> cache <span class="keyword">in</span> caches:</span><br><span class="line">            print(<span class="string">"%dtd Layer"</span> % i)</span><br><span class="line">            print(<span class="string">" input: %s"</span> % cache[<span class="number">0</span>])</span><br><span class="line">            print(<span class="string">" w: %s"</span> % cache[<span class="number">1</span>])</span><br><span class="line">            print(<span class="string">" b: %s"</span> % cache[<span class="number">2</span>])</span><br><span class="line">            print(<span class="string">" input_sum: %s"</span> % cache[<span class="number">3</span>])</span><br><span class="line">            print(<span class="string">"----------"</span>)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute_error</span><span class="params">(self, output)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        函数:</span></span><br><span class="line"><span class="string">            计算档次迭代的输出总误差</span></span><br><span class="line"><span class="string">        输入:</span></span><br><span class="line"><span class="string">        返回:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        m = self.y.shape[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算误差，见式(5.5): E = Σ1/2(期望输出-实际输出)²</span></span><br><span class="line">        <span class="comment">#error = np.sum(0.5 * (self.y - output) ** 2) / m</span></span><br><span class="line">        <span class="comment"># 交叉熵作为误差函数</span></span><br><span class="line"></span><br><span class="line">        error =  -np.sum(np.multiply(np.log(output),self.y) + np.multiply(np.log(<span class="number">1</span> - output), <span class="number">1</span> - self.y)) / m</span><br><span class="line">        error = np.squeeze(error)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> error</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">layer_activation_backward</span><span class="params">(self, derror_wrt_output, cache, activation_choose)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">            函数:</span></span><br><span class="line"><span class="string">                网络层的反向传播</span></span><br><span class="line"><span class="string">            输入:</span></span><br><span class="line"><span class="string">                derror_wrt_output: 误差关于输出的偏导</span></span><br><span class="line"><span class="string">                cache: 网络层的缓存信息 (x, w, b, input_sum)</span></span><br><span class="line"><span class="string">                activation_choose: 选择激活函数 "sigmoid", "relu", "tanh"</span></span><br><span class="line"><span class="string">            返回: 梯度信息，即</span></span><br><span class="line"><span class="string">                derror_wrt_output_prev: 反向传播到上一层的误差关于输出的梯度</span></span><br><span class="line"><span class="string">                derror_wrt_dw: 误差关于权值的梯度</span></span><br><span class="line"><span class="string">                derror_wrt_db: 误差关于偏置的梯度</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        input, w, b, input_sum = cache</span><br><span class="line">        output_prev = input     <span class="comment"># 上一层的输出 = 当前层的输入; 注意是'输入'不是输入的加权和（input_sum）</span></span><br><span class="line">        m = output_prev.shape[<span class="number">1</span>]      <span class="comment"># m是输入的样本数量，我们要取均值，所以下面的求值要除以m</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 实现式（5.13）-&gt; 误差关于权值w的偏导数</span></span><br><span class="line">        derror_wrt_dinput = activated_back_propagation(activation_choose, derror_wrt_output, input_sum)</span><br><span class="line">        derror_wrt_dw = np.dot(derror_wrt_dinput, output_prev.T) / m</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 实现式 （5.32）-&gt; 误差关于偏置b的偏导数</span></span><br><span class="line">        derror_wrt_db = np.sum(derror_wrt_dinput, axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)/m</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 为反向传播到上一层提供误差传递，见式（5.28）的 （Σδ·w） 部分</span></span><br><span class="line">        derror_wrt_output_prev = np.dot(w.T, derror_wrt_dinput)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> derror_wrt_output_prev, derror_wrt_dw, derror_wrt_db</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">back_propagation</span><span class="params">(self, output, caches)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        函数:</span></span><br><span class="line"><span class="string">            神经网络的反向传播</span></span><br><span class="line"><span class="string">        输入:</span></span><br><span class="line"><span class="string">            output：神经网络输</span></span><br><span class="line"><span class="string">            caches：所有网络层（输入层不算）的缓存参数信息  [(x, w, b, input_sum), ...]</span></span><br><span class="line"><span class="string">        返回:</span></span><br><span class="line"><span class="string">            grads: 返回当前迭代的梯度信息</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        grads = &#123;&#125;</span><br><span class="line">        L = self.param_layers_num <span class="comment">#</span></span><br><span class="line">        output = output.reshape(output.shape)  <span class="comment"># 把输出层输出输出重构成和期望输出一样的结构</span></span><br><span class="line"></span><br><span class="line">        expected_output = self.y</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 见式(5.8)</span></span><br><span class="line">        <span class="comment">#derror_wrt_output = -(expected_output - output)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 交叉熵作为误差函数</span></span><br><span class="line">        derror_wrt_output = - (np.divide(expected_output, output) - np.divide(<span class="number">1</span> - expected_output, <span class="number">1</span> - output))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 反向传播：输出层 -&gt; 隐藏层，得到梯度：见式(5.8), (5.13), (5.15)</span></span><br><span class="line">        current_cache = caches[L - <span class="number">1</span>] <span class="comment"># 取最后一层,即输出层的参数信息</span></span><br><span class="line">        grads[<span class="string">"derror_wrt_output"</span> + str(L)], grads[<span class="string">"derror_wrt_dw"</span> + str(L)], grads[<span class="string">"derror_wrt_db"</span> + str(L)] = \</span><br><span class="line">            self.layer_activation_backward(derror_wrt_output, current_cache, <span class="string">"sigmoid"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 反向传播：隐藏层 -&gt; 隐藏层，得到梯度：见式 (5.28)的(Σδ·w), (5.28), (5.32)</span></span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> reversed(range(L - <span class="number">1</span>)):</span><br><span class="line">            current_cache = caches[l]</span><br><span class="line">            derror_wrt_output_prev_temp, derror_wrt_dw_temp, derror_wrt_db_temp = \</span><br><span class="line">                self.layer_activation_backward(grads[<span class="string">"derror_wrt_output"</span> + str(l + <span class="number">2</span>)], current_cache, <span class="string">"tanh"</span>)</span><br><span class="line"></span><br><span class="line">            grads[<span class="string">"derror_wrt_output"</span> + str(l + <span class="number">1</span>)] = derror_wrt_output_prev_temp</span><br><span class="line">            grads[<span class="string">"derror_wrt_dw"</span> + str(l + <span class="number">1</span>)] = derror_wrt_dw_temp</span><br><span class="line">            grads[<span class="string">"derror_wrt_db"</span> + str(l + <span class="number">1</span>)] = derror_wrt_db_temp</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> grads</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_w_and_b</span><span class="params">(self, grads)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        函数:</span></span><br><span class="line"><span class="string">            根据梯度信息更新w，b</span></span><br><span class="line"><span class="string">        输入:</span></span><br><span class="line"><span class="string">            grads：当前迭代的梯度信息</span></span><br><span class="line"><span class="string">        返回:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 权值w和偏置b的更新，见式:（5.16),(5.18)</span></span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> range(self.param_layers_num):</span><br><span class="line">            self.w[<span class="string">"w"</span> + str(l + <span class="number">1</span>)] = self.w[<span class="string">"w"</span> + str(l + <span class="number">1</span>)] - self.learning_rate * grads[<span class="string">"derror_wrt_dw"</span> + str(l + <span class="number">1</span>)]</span><br><span class="line">            self.b[<span class="string">"b"</span> + str(l + <span class="number">1</span>)] = self.b[<span class="string">"b"</span> + str(l + <span class="number">1</span>)] - self.learning_rate * grads[<span class="string">"derror_wrt_db"</span> + str(l + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">training_modle</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""训练神经网络模型"""</span></span><br><span class="line"></span><br><span class="line">        np.random.seed(<span class="number">5</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, self.num_iterations):</span><br><span class="line">            <span class="comment"># 正向传播，得到网络输出，以及每一层的参数信息</span></span><br><span class="line">            output, caches = self.forward_propagation(self.x)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 计算网络输出误差</span></span><br><span class="line">            cost = self.compute_error(output)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 反向传播，得到梯度信息</span></span><br><span class="line">            grads = self.back_propagation(output, caches)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 根据梯度信息，更新权值w和偏置b</span></span><br><span class="line">            self.update_w_and_b(grads)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 当次迭代结束，打印误差信息</span></span><br><span class="line">            <span class="keyword">if</span> self.print_cost <span class="keyword">and</span> i % <span class="number">1000</span> == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">print</span> (<span class="string">"Cost after iteration %i: %f"</span> % (i, cost))</span><br><span class="line">            <span class="keyword">if</span> self.print_cost <span class="keyword">and</span> i % <span class="number">1000</span> == <span class="number">0</span>:</span><br><span class="line">                self.costs.append(cost)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 模型训练完后显示误差曲线</span></span><br><span class="line">        <span class="keyword">if</span> <span class="literal">False</span>:</span><br><span class="line">            plt.plot(np.squeeze(self.costs))</span><br><span class="line">            plt.ylabel(<span class="string">u'神经网络误差'</span>, fontproperties = font)</span><br><span class="line">            plt.xlabel(<span class="string">u'迭代次数 (*100)'</span>, fontproperties = font)</span><br><span class="line">            plt.title(<span class="string">u"学习率 ="</span> + str(self.learning_rate), fontproperties = font)</span><br><span class="line">            plt.show()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.w, self.b</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">predict_by_modle</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="string">"""使用训练好的模型（即最后求得w，b参数）来决策输入的样本的结果"""</span></span><br><span class="line">        output, _ = self.forward_propagation(x.T)</span><br><span class="line">        output = output.T</span><br><span class="line">        result = output / np.sum(output, axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">return</span> np.argmax(result, axis=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_decision_boundary</span><span class="params">(xy, colors, pred_func)</span>:</span></span><br><span class="line">    <span class="comment"># xy是坐标点的集合，把集合的范围算出来</span></span><br><span class="line">    <span class="comment"># 加减0.5相当于扩大画布的范围，不然画出来的图坐标点会落在图的边缘，逼死强迫症患者</span></span><br><span class="line">    x_min, x_max = xy[:, <span class="number">0</span>].min() - <span class="number">0.5</span>, xy[:, <span class="number">0</span>].max() + <span class="number">0.5</span></span><br><span class="line">    y_min, y_max = xy[:, <span class="number">1</span>].min() - <span class="number">0.5</span>, xy[:, <span class="number">1</span>].max() + <span class="number">0.5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 以h为分辨率，生成采样点的网格，就像一张网覆盖所有颜色点</span></span><br><span class="line">    h = <span class="number">.01</span></span><br><span class="line">    xx, yy = np.meshgrid(np.arange(x_min, x_max, h), np.arange(y_min, y_max, h))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 把网格点集合作为输入到模型，也就是预测这个采样点是什么颜色的点，从而得到一个决策面</span></span><br><span class="line">    Z = pred_func(np.c_[xx.ravel(), yy.ravel()])</span><br><span class="line">    Z = Z.reshape(xx.shape)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 利用等高线，把预测的结果画出来，效果上就是画出红蓝点的分界线</span></span><br><span class="line">    plt.contourf(xx, yy, Z, cmap=plt.cm.Spectral)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 训练用的红蓝点点也画出来</span></span><br><span class="line">    plt.scatter(xy[:, <span class="number">0</span>], xy[:, <span class="number">1</span>], c=colors, marker=<span class="string">'o'</span>, cmap=plt.cm.Spectral, edgecolors=<span class="string">'black'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    plt.figure(figsize=(<span class="number">16</span>, <span class="number">32</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 用sklearn的数据样本集，产生2种颜色的坐标点，noise是噪声系数，噪声越大，2种颜色的点分布越凌乱</span></span><br><span class="line">    xy, colors = sklearn.datasets.make_moons(<span class="number">60</span>, noise=<span class="number">1.0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 因为点的颜色是1bit，我们设计一个神经网络，输出层有2个神经元。</span></span><br><span class="line">    <span class="comment"># 标定输出[1,0]为红色点，输出[0,1]为蓝色点</span></span><br><span class="line">    expect_output = []</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> colors:</span><br><span class="line">        <span class="keyword">if</span> c == <span class="number">1</span>:</span><br><span class="line">            expect_output.append([<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            expect_output.append([<span class="number">1</span>,<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    expect_output = np.array(expect_output).T</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 设计3层网络，改变隐藏层神经元的个数，观察神经网络分类红蓝点的效果</span></span><br><span class="line">    hidden_layer_neuron_num_list = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">10</span>,<span class="number">20</span>,<span class="number">50</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, hidden_layer_neuron_num <span class="keyword">in</span> enumerate(hidden_layer_neuron_num_list):</span><br><span class="line">        plt.subplot(<span class="number">5</span>, <span class="number">2</span>, i + <span class="number">1</span>)</span><br><span class="line">        plt.title(<span class="string">u'隐藏层神经元数量: %d'</span> % hidden_layer_neuron_num, fontproperties = font)</span><br><span class="line"></span><br><span class="line">        nn = NeuralNetwork([<span class="number">2</span>, hidden_layer_neuron_num, <span class="number">2</span>], <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 输出和输入层都是2个节点，所以输入和输出的数据集合都要是 nx2的矩阵</span></span><br><span class="line">        nn.set_xy(xy.T, expect_output)</span><br><span class="line">        nn.set_num_iterations(<span class="number">30000</span>)</span><br><span class="line">        nn.set_learning_rate(<span class="number">0.1</span>)</span><br><span class="line">        w, b = nn.training_modle()</span><br><span class="line">        plot_decision_boundary(xy, colors, nn.predict_by_modle)</span><br><span class="line"></span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;单个神经元结构&quot;&gt;&lt;a href=&quot;#单个神经元结构&quot; class=&quot;headerlink&quot; title=&quot;单个神经元结构&quot;&gt;&lt;/a&gt;单个神经元结构&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;//loopvoid.github.io/2019/09/14/BP神经网络原理
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>自动微分法</title>
    <link href="https://loopvoid.github.io/2018/10/15/%E8%87%AA%E5%8A%A8%E5%BE%AE%E5%88%86%E6%B3%95/"/>
    <id>https://loopvoid.github.io/2018/10/15/自动微分法/</id>
    <published>2018-10-14T16:06:11.000Z</published>
    <updated>2019-08-06T07:57:48.256Z</updated>
    
    <content type="html"><![CDATA[<h1 id="几种微分求解的方法"><a href="#几种微分求解的方法" class="headerlink" title="几种微分求解的方法"></a>几种微分求解的方法</h1><ul><li>手动求解法(Manual Differentiation)</li><li>数值微分法(Numerical Differentiation)</li><li>符号微分法(Symbolic Differentiation)</li><li>自动微分法(Automatic Differentiation)</li></ul><h1 id="自动微分"><a href="#自动微分" class="headerlink" title="自动微分"></a>自动微分</h1><p>在数学和计算代数领域，automatic differentiation (AD)又称为 algorithmic differentiation 或者 computational differentiation。AD是一个可以对程序代码表示的数学函数进行自动微分的技术。AD利用链式法则来达到自动求解的目录，AD有两种主要的方法：</p><ul><li><strong>代码转换</strong>（source-code transformation）（R. Giering and T. Kaminski. 1998）： <ul><li>利用一个代码转换编译器，这个编译器会分析源代码，然后产生一个和源代码对应的伴随模式(adjoint model)程序，编译时的代码生成（如用 flex-bison 做词法、语法分析）；</li><li>优点是静态生成效率高(原始算法的3~4倍) ;</li><li>一次生成，多次使用，缺点是学习门槛较高（编译原理…）；</li><li>很多比较好的工具非免费；</li><li>对现代编程语言特性的限制（如C++类、模板等）；</li></ul></li><li><strong>运算符重载</strong>(operator overloading) <ul><li>应用比较广泛，很多编程语言特性可以很好的工作；</li><li>优点是简单直接，缺点是动态生成成本较高（代表性的工具效率是原始算法的10~35倍）。</li><li>较多免费开源 C++ 工具 (e.g. ADOL-C, CppAD, Sacado)；</li></ul></li></ul><p>AD 这两种实现方式：<strong>运算符重载</strong>与<strong>代码生成</strong>，两种方式的原理都一样， <code>链式法则</code>。AD相关工具，请到这个<a href="http://www.autodiff.org/" target="_blank" rel="noopener">http://www.autodiff.org/</a> 页面。自动微分（AD）是计算导数的最优方法，比符号计算、有限微分更快更精确，AD已经广泛应用在优化领域，包括人工神经网络的训练算法 back-propagation（BP）等。</p><h1 id="AD基本原理"><a href="#AD基本原理" class="headerlink" title="AD基本原理"></a>AD基本原理</h1><h2 id="链式法则"><a href="#链式法则" class="headerlink" title="链式法则"></a>链式法则</h2><p>AD基本原理是<code>链式法则</code>。链式法则又分为正向和反向。如下例子</p><script type="math/tex; mode=display">y=f(g(h(x)))=f(g(h(w_0)))=f(g(w_1))=f(w_2)=w_3</script><p>那么链式法则就表示为:</p><script type="math/tex; mode=display">\frac{dy}{dx}=\frac{dy}{dw_2}\frac{dw_2}{dw_1}\frac{dw_1}{dx}</script><p>正向链式法则：则从链里往外算（即，先算$\frac{dw_1}{dx}$，再算$\frac{dw_2}{dw_1}$，最后算$\frac{dy}{dw_2}$）。</p><p>反向链式法则：则从链外往外里（即，先算$\frac{dy}{dw_2}$，再算$\frac{dw_2}{dw_1}$，最后算$\frac{dw_1}{dx}$）。</p><p>简洁的表示为：</p><p>正向链式法则：计算递归式<script type="math/tex">\frac{dw_i}{dx}=\frac{dw_i}{dw_{i-1}}\frac{dw_{i-1}}{dx}，且w_3=y</script></p><p>反向链式法则：计算递归式<script type="math/tex">\frac{dy}{dw_i}=\frac{dy}{dw_{i+1}}\frac{dw_{i+1}}{dw_i}，且w_0=y</script></p><p> 通常，正向跟反向链式法则都是通过计算图来表示和计算，这样更加的方便。</p><h2 id="正向链式法则计算图"><a href="#正向链式法则计算图" class="headerlink" title="正向链式法则计算图"></a>正向链式法则计算图</h2><p>将函数转化为一个DAG（有向无环图），就能很容易的求解每一步的值。</p><h3 id="例1："><a href="#例1：" class="headerlink" title="例1："></a>例1：</h3><p>假设有计算式子：$y=x_0*x_1+x_1$  (1)，我们要求解$\frac{\partial y}{\partial x_1}$。</p><p>首先，其计算图表示为：</p><p><img src="//loopvoid.github.io/2018/10/15/自动微分法/计算图1.png" alt="计算图1.png"></p><p>把（1）式展开为链式计算序列为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c=x0*x1</span><br><span class="line">d=c+x1</span><br><span class="line">y=d</span><br></pre></td></tr></table></figure><p>那么其对应的计算图则为：</p><p><img src="//loopvoid.github.io/2018/10/15/自动微分法/计算图2.png" alt="计算图2.png"></p><p>这里假设$x_0,x_1$的初值分别为：1, 2。 (1)式展开计算子序列为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x0=1</span><br><span class="line">x1=2</span><br><span class="line">c=x0*x1</span><br><span class="line">d=c+x1</span><br><span class="line">y=d</span><br></pre></td></tr></table></figure><p>那么其对应计算图为：</p><p><img src="//loopvoid.github.io/2018/10/15/自动微分法/计算图3.png" alt="计算图3.png"></p><p>然后对该计算图求解偏导数：</p><p><img src="//loopvoid.github.io/2018/10/15/自动微分法/计算图4.png" alt="计算图4.png"></p><p>由链式法则得到：<script type="math/tex">\frac{\partial y}{\partial  x_1}=\frac{\partial y}{\partial  d}\frac{\partial d}{\partial  c}\frac{\partial c}{\partial  x_1}+\frac{\partial y}{\partial  d}\frac{\partial d}{\partial  x_1}</script></p><p>结合计算图中对应的值可知：$\frac{\partial y}{\partial  x_1}=1\times1\times1+1\times1=2$</p><h3 id="例2："><a href="#例2：" class="headerlink" title="例2："></a>例2：</h3><p>对于下列函数：<script type="math/tex">f(x_1,x_2)=ln(x_1)+x_1*x_2-sin(x_2)</script></p><p>转化为计算图：</p><p><img src="//loopvoid.github.io/2018/10/15/自动微分法/计算图5.png" alt="计算图5.png"></p><p>那么求每一步的导数值就可以表示为：</p><p><img src="//loopvoid.github.io/2018/10/15/自动微分法/计算图6.png" alt="计算图6.png"></p><p>上表，左半部分是从左往右计算图每个节点的求值结果，右半部分是每个节点对于$x_1$的求导结果，比如$\dot{v_1}=\frac{dv}{dx_1}$，注意到每一步的求导都会利用到上一步的求导结果。</p><p>对于自动微分的正向模式，如果函数输入输出为：$R \rightarrow R^m $</p><p>那么正向模式只需要计算一次上表右侧过程即可，非常高效。但是对于输入输出映射为：$R^n\rightarrow R^m$，这样一个有$n$个输入的函数，对于函数的梯度求解则需要处理$n$遍上述过程。而且再实际算法模型中，通常输入输出是极度不成比例的，也就是$n&gt;&gt;m$，那么利用正向模式进行自动微分的效率就太低了，因此有了反向模式的出现。</p><h2 id="反向链式法则计算图"><a href="#反向链式法则计算图" class="headerlink" title="反向链式法则计算图"></a>反向链式法则计算图</h2><p>自动微分的反向模式其实就是一种通用的<a href="https://en.wikipedia.org/wiki/Backpropagation" target="_blank" rel="noopener">BackPropagation</a>(<a href="http://galaxy.agh.edu.pl/~vlsi/AI/backp_t_en/backprop.html" target="_blank" rel="noopener">反向传播算法</a>)，即backpropagation是自动微分反向模式的一种特殊形式。</p><p>反向模式从最终结果开始求导，利用最终输出对每一个节点进行求导，其过程如下计算图所示： </p><p><img src="//loopvoid.github.io/2018/10/15/自动微分法/计算图7.png" alt="计算图7.png"></p><p>其具体计算过程如下表所示：   </p><p><img src="//loopvoid.github.io/2018/10/15/自动微分法/计算图8.png" alt="计算图8.png"></p><p>上表左边和之前的正向模式一致，用于求解函数值，右边则是反向模式的计算过程，须从下向上看，也就是一开始先计算输出$y$对于节点$v_5$的导数，用$\bar{v_5}=\frac{dy}{dv_5}$，这样的记号可以强调我们对当前计算结果进行缓存，以便用于后续计算，而不必重复计算。再由链式法则我们可以计算输出节点对于图种每个节点的导数。  </p><p>比如对节点$v_3$：</p><script type="math/tex; mode=display">\frac{y}{v_3}=\frac{dy}{dv_5}\frac{dv_5}{dv_3}</script><p>用$\bar{v_i}=\frac{dy}{dv_i}$记法，则有：</p><script type="math/tex; mode=display">\frac{y}{v_3}=\bar{v_5}\frac{dv_5}{dv_3}</script><p>比如对于节点$v_0$：</p><script type="math/tex; mode=display">\frac{y}{v_0}=\frac{dy}{dv_2}\frac{dv_2}{dv_0}+\frac{dy}{dv_3}\frac{dv_3}{dv_0}</script><p>用$\bar{v_i}=\frac{dy}{dv_i}$记法，则有：</p><script type="math/tex; mode=display">\frac{y}{v_0}=\bar{v_2}\frac{dv_2}{dv_0}+\bar{v_3}\frac{dv_3}{dv_0}</script><p>和backpropagation算法一样，我们必须记住前向时当前节点发出的边，然后在反向传播时，可以搜集所有受到当前节点影响的节点。 </p><p>如上的计算过程，对于像神经网络这种模型，输入通常是上万到上百万维，而输出损失函数是1维的模型，则只需要一遍反向模式计算过程，便可以求出输出对于各个输入的导数，从而轻松求取梯度用于后续优化更新。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>AD:</p><ul><li><a href="https://arxiv.org/pdf/1502.05767.pdf" target="_blank" rel="noopener">Automatic differentiation in machine learning: a survey</a></li><li><a href="http://www.met.reading.ac.uk/~swrhgnrj/publications/adept.pdf" target="_blank" rel="noopener">Fast Reverse-Mode Automatic Differentiation using Expression</a></li><li><a href="https://www.zhihu.com/question/48356514" target="_blank" rel="noopener">https://www.zhihu.com/question/48356514</a></li><li><a href="https://blog.csdn.net/daniel_ustc/article/details/77133329" target="_blank" rel="noopener">https://blog.csdn.net/daniel_ustc/article/details/77133329</a></li><li><a href="https://en.wikipedia.org/wiki/Automatic_differentiation" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Automatic_differentiation</a></li><li><a href="https://github.com/autodiff/autodiff" target="_blank" rel="noopener">https://github.com/autodiff/autodiff</a></li><li><a href="https://www.jianshu.com/p/4c2032c685dc" target="_blank" rel="noopener">https://www.jianshu.com/p/4c2032c685dc</a></li><li><a href="http://www.autodiff.org/" target="_blank" rel="noopener">http://www.autodiff.org/</a></li><li><a href="https://blog.csdn.net/u013527419/article/details/70184690" target="_blank" rel="noopener">https://blog.csdn.net/u013527419/article/details/70184690</a></li><li><a href="https://github.com/zakheav/automatic-differentiation-framework" target="_blank" rel="noopener">https://github.com/zakheav/automatic-differentiation-framework</a></li><li><a href="https://blog.csdn.net/daniel_ustc/article/details/77133329" target="_blank" rel="noopener">https://blog.csdn.net/daniel_ustc/article/details/77133329</a></li><li><a href="https://blog.csdn.net/aws3217150/article/details/70214422" target="_blank" rel="noopener">https://blog.csdn.net/aws3217150/article/details/70214422</a></li></ul><p>BP:</p><ul><li><a href="https://www.zhihu.com/question/27239198" target="_blank" rel="noopener">https://www.zhihu.com/question/27239198</a></li><li><a href="http://galaxy.agh.edu.pl/~vlsi/AI/backp_t_en/backprop.html" target="_blank" rel="noopener">http://galaxy.agh.edu.pl/~vlsi/AI/backp_t_en/backprop.html</a></li><li><a href="https://en.wikipedia.org/wiki/Backpropagation" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Backpropagation</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;几种微分求解的方法&quot;&gt;&lt;a href=&quot;#几种微分求解的方法&quot; class=&quot;headerlink&quot; title=&quot;几种微分求解的方法&quot;&gt;&lt;/a&gt;几种微分求解的方法&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;手动求解法(Manual Differentiation)&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="数学" scheme="https://loopvoid.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="自动微分" scheme="https://loopvoid.github.io/tags/%E8%87%AA%E5%8A%A8%E5%BE%AE%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>Jacobian矩阵与Hessian矩阵与最小二乘</title>
    <link href="https://loopvoid.github.io/2018/04/28/Jacobian%E7%9F%A9%E9%98%B5%E4%B8%8EHessian%E7%9F%A9%E9%98%B5%E4%B8%8E%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98/"/>
    <id>https://loopvoid.github.io/2018/04/28/Jacobian矩阵与Hessian矩阵与最小二乘/</id>
    <published>2018-04-28T08:15:17.000Z</published>
    <updated>2019-08-06T06:49:50.751Z</updated>
    
    <content type="html"><![CDATA[<h1 id="雅可比矩阵-Jacobian-matrix"><a href="#雅可比矩阵-Jacobian-matrix" class="headerlink" title="雅可比矩阵 (Jacobian matrix)"></a>雅可比矩阵 (Jacobian matrix)</h1><p>在向量分析中, 雅可比矩阵是<strong>一阶偏导</strong>数以一定方式排列成的<strong>矩阵</strong>, 其行列式称为雅可比行列式. 还有, 在代数几何中, 代数曲线的雅可比量表示雅可比簇：伴随该曲线的一个代数群, 曲线可以嵌入其中. 它们全部都以数学家卡尔·雅可比(Carl Jacob, 1804年10月4日－1851年2月18日)命名；英文雅可比量”Jacobian”可以发音为[ja ˈko bi ən]或者[ʤə ˈko bi ən].</p><p>雅可比矩阵的重要性在于它体现了一个可微方程与给出点的<strong>最优线性逼近</strong>. 因此, 雅可比矩阵类似于<strong>多元函数的导数</strong>.</p><p>假设$F:R_n→R_m$是一个从欧式n维空间转换到欧式m维空间的函数。这个函数由m个实函数组成:$ y_1(x_1,…,x_n), …, y_m(x_1,…,x_n)$. 这些函数的偏导数(如果存在)可以组成一个m行n列的矩阵，这就是所谓的雅可比矩阵：</p><script type="math/tex; mode=display">\begin{bmatrix} \frac{\partial y_1}{\partial x_1} &  \cdots & \frac{\partial y_1}{\partial x_n}\\ \vdots &  \ddots & \vdots  \\ \frac{\partial y_n}{\partial x_1} &  \cdots & \frac{\partial y_n}{\partial x_n} \end{bmatrix}</script><p>此矩阵表示为：$J_F(x_1,\cdots ,x_2)$，或者:$\frac{\partial (y_1,\cdots,y_n)}{\partial (x_1, \cdots ,x_n)}$</p><p>这个矩阵的第$i$行是由梯度函数的转置$y_i(i=1,…,m)$表示的。</p><p>如果$p$是$R_n$中的一点, $F$在$p$点可<strong>微分</strong>, 那么在$p$这一点的导数由$J_{F(p)}$给出(这是求该点导数最简便的方法). 在此情况下, 由$F_(p)$描述的<strong>线性算子</strong>即接近点$p$的$F$的<strong>最优线性逼近</strong>, $x$逼近于$p$:$F_(x) \approx F_{(p)} + J_{F(p)} \cdot (x-p)$</p><p>从数学意义上来解释雅可比矩阵，我们可以想象有6个函数，每个函数对应着有6个变量。那么针对每个输入变量$x_i$，就会能够得到对应的$y_i$.</p><script type="math/tex; mode=display">y_1=f_1(x_1,x_2,x_3,x_4,x_5,x_6)</script><script type="math/tex; mode=display">y_2=f_2(x_1,x_2,x_3,x_4,x_5,x_6)</script><script type="math/tex; mode=display">y_3=f_3(x_1,x_2,x_3,x_4,x_5,x_6)</script><script type="math/tex; mode=display">y_4=f_4(x_1,x_2,x_3,x_4,x_5,x_6)</script><script type="math/tex; mode=display">y_5=f_5(x_1,x_2,x_3,x_4,x_5,x_6)</script><script type="math/tex; mode=display">y_6=f_6(x_1,x_2,x_3,x_4,x_5,x_6)</script><p>因此$y_i$的导数可以被写成：</p><script type="math/tex; mode=display">{\mathrm{d} y_i} = \frac{\partial f_i}{\partial x_1}{\mathrm{d} x_1}+\frac{\partial f_i}{\partial x_2}{\mathrm{d} x_2}+\frac{\partial f_i}{\partial x_3}{\mathrm{d} x_3}+\frac{\partial f_i}{\partial x_4}{\mathrm{d} x_4}+\frac{\partial f_i}{\partial x_5}{\mathrm{d} x_5}+\frac{\partial f_i}{\partial x_6}{\mathrm{d} x_6}</script><p>因此结合上面的方程，我们可以将上面的方程写为向量的形式：</p><script type="math/tex; mode=display">{\mathrm{d} Y}=\frac{\partial F}{\partial X}{\mathrm{d} X}</script><p>函数F对于X的偏导数矩阵，就被称为雅可比矩阵(Jacobian)。</p><p>换句话说，雅可比矩阵就是X的速度到Y的速度的映射：$\dot{Y}=J(X)\dot{X}$<br>在某个时间步长，雅可比矩阵其实也就是针对于$x_i$的函数。在下一个时间步长的时候，$x$改变了，因此雅可比矩阵也进行了改变。</p><p>在某个给定点的雅可比行列式提供了<strong>在接近该点时的表现的重要信息</strong>. 例如, 如果连续可微函数$F$在$p$点的雅可比行列式不是零, 那么它在该点附近具有反函数. 这称为反函数定理. 更进一步, 如果pp点的雅可比行列式是正数, 则$F$在$p$点的取向不变；如果是负数, 则FF的取向相反. 而从雅可比行列式的绝对值, 就可以知道函数$F$在$p$点的缩放因子；这就是为什么它出现在换元积分法中.</p><p>对于取向问题可以这么理解, 例如一个物体在平面上匀速运动, 如果施加一个正方向的力$F$, 即取向相同, 则加速运动, 类比于速度的导数加速度为正；如果施加一个反方向的力$F$, 即取向相反, 则减速运动, 类比于速度的导数加速度为负.</p><p><a href="ttp://jacoxu.com/jacobian%E7%9F%A9%E9%98%B5%E5%92%8Chessian%E7%9F%A9%E9%98%B5/" target="_blank" rel="noopener">Jacobian矩阵和Hessian矩阵</a><br><a href="https://blog.csdn.net/noahzuo/article/details/54314112" target="_blank" rel="noopener">使用雅可比矩阵(Jacobian)来结算IK</a><br><a href="https://www.zhihu.com/question/22586361" target="_blank" rel="noopener">如何理解雅克比矩阵?—-知乎</a><br><a href="https://blog.csdn.net/u011494690/article/details/43274301" target="_blank" rel="noopener">雅克比矩阵、海森矩阵与非线性最小二乘间的关系与在SFM和Pose Estimation中的应用</a><br><a href="ttp://jacoxu.com/jacobian%E7%9F%A9%E9%98%B5%E5%92%8Chessian%E7%9F%A9%E9%98%B5/" target="_blank" rel="noopener">acobian矩阵和Hessian矩阵</a><br><a href="https://blog.csdn.net/noahzuo/article/details/54314112" target="_blank" rel="noopener">动画研究 — 使用雅可比矩阵(Jacobian)来结算IK</a></p><h1 id="海森矩阵（Hessian-matrix）"><a href="#海森矩阵（Hessian-matrix）" class="headerlink" title="海森矩阵（Hessian matrix）"></a>海森矩阵（Hessian matrix）</h1><p><strong>海森矩阵</strong>是一个自变量为向量的实值函数的<strong>二阶偏导数</strong>组成的<strong>方块矩阵</strong>.</p><p>此函数如下：<script type="math/tex">f(x_1,\cdots,x_n)</script></p><p>如果 <em>f</em> 所有的二阶导数都存在，那么 <em>f</em> 的海森矩阵即：$H(f)_{ij}(x)=D_iD_jf(x)$其中$x=(x_1,x_2,\cdots,x_n)$，即是：</p><script type="math/tex; mode=display">H(f)=\begin{bmatrix} \frac{\partial^2 f}{\partial x_1^2} &\frac{\partial^2 f}{\partial x_1\partial x_2}  &\cdots &\frac{\partial^2 f}{\partial x_1\partial x_n} \\ \frac{\partial^2 f}{\partial x_2\partial x_1} &\frac{\partial^2 f}{\partial x_2^2}  &\cdots &\frac{\partial^2 f}{\partial x_2\partial x_n} \\ \vdots  &\vdots   &\ddots   &\vdots  \\ \frac{\partial^2 f}{\partial x_n\partial x_1} &\frac{\partial^2 f}{\partial x_n\partial x_2}  &\cdots &\frac{\partial^2 f}{\partial x_n^2} \end{bmatrix}</script><p>(也有人把海森定义为以上矩阵的行列式)海森矩阵被应用于牛顿法解决的大规模优化问题.</p><h2 id="海森矩阵在牛顿法中的应用"><a href="#海森矩阵在牛顿法中的应用" class="headerlink" title="海森矩阵在牛顿法中的应用"></a>海森矩阵在牛顿法中的应用</h2><p>一般来说, 牛顿法主要应用在两个方面:</p><ul><li>求方程的根</li><li>最优化</li></ul><h3 id="求根"><a href="#求根" class="headerlink" title="求根"></a>求根</h3><p>并不是所有的方程都有求根公式, 或者求根公式很复杂, 导致求解困难. 利用牛顿法, 可以迭代求解.</p><p>原理是利用泰勒公式, 在$x_0$处展开, 且展开到一阶, 即$f(x)=f(x_0)+(x-x_0)f’(x_0)$</p><p>求解方程$f(x)=0$，即求解$f(x_0)+(x-x_0)f’(x_0) = 0$</p><p>即是求解<script type="math/tex">x=x_1=x_0-\frac{f(x_0)}{f'(x_0)}</script></p><p>因为这是利用泰勒公式的一阶展开,$f(x)$的值是近似相等，这里求得的$x_1$，只能让$f(x_1) \approx 0$。于是乎, 迭代求解的想法就很自然了, 可以进而推出：$x_{n+1}=x_n-\frac{f(x_n)}{f’(x_n)}$， 通过迭代, 这个式子必然在$f(x^*)=0$的时候收敛.过程如下图：</p><p><img src="//loopvoid.github.io/2018/04/28/Jacobian矩阵与Hessian矩阵与最小二乘/hessian.jpg" alt="hessian"></p><h3 id="最优化"><a href="#最优化" class="headerlink" title="最优化"></a>最优化</h3><p>在最优化的问题中, 线性最优化至少可以使用单纯形法(或称<strong><a href="https://en.wikipedia.org/wiki/Fixed-point_arithmetic" target="_blank" rel="noopener">不动点算法</a></strong>)求解, 但对于非线性优化问题, 牛顿法提供了一种求解的办法.假设任务是优化一个目标函数$f$,求函数$f$的极大极小问题可以转化为求解函数$f$的导数${f}’=0$的问题。, 这样求可以把优化问题看成方程(${f}’=0$)求解问题。剩下的问题就和前面提到的牛顿法求解很相似了。</p><p>这次为了求解${f}’=0$的根, 首先把$f(x)$在探索点$x_n$处泰勒展开, 展开到2阶形式进行近似：</p><script type="math/tex; mode=display">f(x)=f(x_n)+f'(x_n)(x-x_n)+\frac{f''(x_n)}{2}(x-x_n)^2</script><p>然后用$f(x)$的最小点做为新的探索点$f(x+1)$，据此，令：</p><script type="math/tex; mode=display">f'(x)=f'(x_n)+f''(x_n)(x-x_n)=0</script><p>求得出迭代公式:</p><script type="math/tex; mode=display">x_{n+1}=x_n-\frac{f'(n)}{f''(n)},n=0,1,...</script><p>一般认为牛顿法可以利用到曲线本身的信息, 比梯度下降法更容易收敛（迭代更少次数）, 如下图是一个最小化一个目标方程的例子, 红色曲线是利用牛顿法迭代求解, 绿色曲线是利用梯度下降法求解.</p><p><img src="//loopvoid.github.io/2018/04/28/Jacobian矩阵与Hessian矩阵与最小二乘/optimize.jpg" alt="optimize"></p><p>在上面讨论的是2维情况, 高维情况的牛顿迭代公式是：</p><script type="math/tex; mode=display">x_{n+1}=x_n-[\bigtriangledown ^2f(x_n)]^{-1}\bigtriangledown f(x_n),n\geqslant 0</script><p>其中$\bigtriangledown ^2$是<strong>Hessian矩阵</strong>，$\bigtriangledown$为$f$的<strong>梯度向量</strong>，$f$的矢量微分运算。</p><p>高维情况依然可以用牛顿迭代求解, 但是问题是Hessian矩阵引入的复杂性, 使得牛顿迭代求解的难度大大增加, 但是已经有了解决这个问题的办法就是Quasi-Newton method, 不再直接计算Hessian矩阵, 而是每一步的时候使用<strong>梯度向量</strong>更新Hessian矩阵的近似.</p><p><strong>Reference：</strong><br><a href="ttp://jacoxu.com/jacobian%E7%9F%A9%E9%98%B5%E5%92%8Chessian%E7%9F%A9%E9%98%B5/" target="_blank" rel="noopener">Jacobian矩阵和Hessian矩阵</a><br><a href="https://blog.csdn.net/u011494690/article/details/43274301" target="_blank" rel="noopener">雅克比矩阵、海森矩阵与非线性最小二乘间的关系与在SFM和Pose Estimation中的应用</a><br><a href="https://my.oschina.net/u/3579120/blog/1508433" target="_blank" rel="noopener">最优化方法:牛顿迭代法和拟牛顿迭代法</a></p><h1 id="最小二乘"><a href="#最小二乘" class="headerlink" title="最小二乘"></a>最小二乘</h1><p>最小二乘法的本质是最小化系数矩阵所张成的向量空间到观测向量的欧式误差距离.</p><p>最小二乘法的一种常见的描述是残差满足正态分布的最大似然估计</p><p>现行的最小二乘法是勒让德( A. M. Legendre)于1805年在其著作《计算慧星轨道的新方法》中提出的。它的主要思想就是选择未知参数，使得<strong>理论值</strong>与<strong>观测值</strong>之差的平方和达到最小：$H = \sum_{0}^{m}(y-y_i)^2$</p><h2 id="线性最小二乘问题"><a href="#线性最小二乘问题" class="headerlink" title="线性最小二乘问题"></a>线性最小二乘问题</h2><p>采用线性模型去拟合数据，即$y(x)=Jx$，则目标函数为$f(x)=\frac{1}{2}||Jx-y||^2$，同时$\bigtriangledown f(x)=J^T(Jx-y)$，</p><p>$\bigtriangledown^2 f(x)=J^TJ$。</p><p>根据最优化定理，该问题的最优解满足如下条件：$\bigtriangledown f(x)=0$，即是$J^TJx=J^Ty$。</p><p>求解该方程，有如下方法:</p><ol><li><strong><a href="https://en.wikipedia.org/wiki/Cholesky_decomposition" target="_blank" rel="noopener">Cholesky分解</a></strong>：当m&gt;&gt;n时，并且J比较稀疏时比较实用，但是其精度和条件数的平方相关 </li><li><strong><a href="https://en.wikipedia.org/wiki/QR_decomposition" target="_blank" rel="noopener">QR分解</a></strong>：精度和条件数相关 </li><li><strong><a href="https://en.wikipedia.org/wiki/Singular-value_decomposition" target="_blank" rel="noopener">SVD分解</a></strong>：相对比较鲁棒，同时也可以添加正则项避免J是个病态矩阵。 </li><li><strong>数值迭代算法</strong>：对于大规模数据比较实用。</li></ol><h2 id="非线性最小二乘问题"><a href="#非线性最小二乘问题" class="headerlink" title="非线性最小二乘问题"></a>非线性最小二乘问题</h2><p>采用非线性模型拟合数据，模型本身可能矢量梯度或者Hessian矩阵不容易得到。</p><h3 id="高斯牛顿方法（Gauss-Newton方法）"><a href="#高斯牛顿方法（Gauss-Newton方法）" class="headerlink" title="高斯牛顿方法（Gauss-Newton方法）"></a>高斯牛顿方法（Gauss-Newton方法）</h3><p>根据标准牛顿方程，$\bigtriangledown f(x_k)p=-\bigtriangledown f(x_k) $可以得到该问题的需要满</p><p>足的条件，即$J^TJP^{GN}=-J^Tr_K$</p><p>此时Hessian矩阵用第一项代替，即$\bigtriangledown^2f(x) \approx J^TJ$</p><p>得到搜索方向后，可以使用线搜索的方法得到步长，重复进行可以得到最优解。</p><p><strong>Reference:</strong><br><a href="https://blog.csdn.net/fangqingan_java/article/details/48948487" target="_blank" rel="noopener">最小二乘问题(Least-Squares)</a><br><a href="https://blog.csdn.net/bitcarmanlee/article/details/51589143" target="_blank" rel="noopener">最小二乘法 来龙去脉</a><br><a href="http://lanbing510.info/2016/03/28/Least-Squares-Parameter-Estimation.html" target="_blank" rel="noopener">最小二乘法的参数估计</a><br><a href="https://blog.csdn.net/qll125596718/article/details/8248249" target="_blank" rel="noopener">一元线性回归模型与最小二乘法及其C++实现</a><br><a href="http://blog.sciencenet.cn/home.php?mod=space&amp;uid=465130&amp;do=blog&amp;id=1001688" target="_blank" rel="noopener">机器视觉中的非线性最小二乘法</a><br><a href="https://blog.csdn.net/ivysister/article/details/45438413" target="_blank" rel="noopener">最小二乘法，牛顿法，梯度下降法以及比较</a><br><a href="https://www.cnblogs.com/iamccme/archive/2013/05/15/3080737.html" target="_blank" rel="noopener">机器学习经典算法之——-最小二乘法</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;雅可比矩阵-Jacobian-matrix&quot;&gt;&lt;a href=&quot;#雅可比矩阵-Jacobian-matrix&quot; class=&quot;headerlink&quot; title=&quot;雅可比矩阵 (Jacobian matrix)&quot;&gt;&lt;/a&gt;雅可比矩阵 (Jacobian matri
      
    
    </summary>
    
      <category term="基础知识" scheme="https://loopvoid.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="基础知识" scheme="https://loopvoid.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="最优化" scheme="https://loopvoid.github.io/tags/%E6%9C%80%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>C++并发学习笔记(三)(std::mutex 详解)</title>
    <link href="https://loopvoid.github.io/2018/03/17/C-%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89-std-mutex-%E8%AF%A6%E8%A7%A3/"/>
    <id>https://loopvoid.github.io/2018/03/17/C-并发学习笔记-三-std-mutex-详解/</id>
    <published>2018-03-17T14:51:18.000Z</published>
    <updated>2019-08-06T06:58:19.373Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Mutex</strong>又称为互斥量，C++ 11中与 Mutex 相关的类（包括锁类型）和函数都声明在<code>&lt;mutex&gt;</code> 头文件中，所以如果你需要使用 std::mutex，就必须包含 <code>&lt;mutex&gt;</code>头文件。</p><p>std::mutex 是C++11 中最基本的互斥量，std::mutex 对象提供了独占所有权的特性——即不支持递归地对 std::mutex 对象上锁，而 std::recursive_lock 则可以递归地对互斥量对象上锁。</p><h1 id="mutex头文件介绍"><a href="#mutex头文件介绍" class="headerlink" title="mutex头文件介绍"></a>mutex头文件介绍</h1><p><strong>互斥量基本作用：</strong> 互斥占有一个变量，一段时间内仅一个线程可以访问。即该类可以限制对某物的访问，只有先获得许可才可访问某物，否则一般可设为阻塞等待。能有效避免资源竞争问题。</p><h2 id="Mutexes类（四种）"><a href="#Mutexes类（四种）" class="headerlink" title="Mutexes类（四种）"></a>Mutexes类（四种）</h2><ul><li><code>std::mutex</code>，最基本的 Mutex 类。</li><li><code>std::recursive_mutex</code>，递归 Mutex 类。</li><li><code>std::time_mutex</code>，定时 Mutex 类。</li><li><code>std::recursive_timed_mutex</code>，定时递归 Mutex 类。</li></ul><h2 id="Lock类（两种）"><a href="#Lock类（两种）" class="headerlink" title="Lock类（两种）"></a>Lock类（两种）</h2><ul><li><a href="http://www.cplusplus.com/reference/mutex/lock_guard/" target="_blank" rel="noopener">std::lock_guard</a>，与 Mutex RAII 相关，方便线程对互斥量上锁。</li><li><a href="http://www.cplusplus.com/reference/mutex/unique_lock/" target="_blank" rel="noopener">std::unique_lock</a>，与 Mutex RAII 相关，方便线程对互斥量上锁，但提供了更好的上锁和解锁控制。</li></ul><h2 id="其他类型"><a href="#其他类型" class="headerlink" title="其他类型"></a>其他类型</h2><ul><li><a href="http://www.cplusplus.com/reference/mutex/once_flag/" target="_blank" rel="noopener">std::once_flag</a></li><li><a href="http://www.cplusplus.com/reference/mutex/adopt_lock_t/" target="_blank" rel="noopener">std::adopt_lock_t</a></li><li><a href="http://www.cplusplus.com/reference/mutex/defer_lock_t/" target="_blank" rel="noopener">std::defer_lock_t</a></li><li><a href="http://www.cplusplus.com/reference/mutex/try_to_lock_t/" target="_blank" rel="noopener">std::try_to_lock_t</a></li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li><a href="http://www.cplusplus.com/reference/mutex/try_lock/" target="_blank" rel="noopener">std::try_lock</a>，尝试同时对多个互斥量上锁。</li><li><a href="http://www.cplusplus.com/reference/mutex/lock/" target="_blank" rel="noopener">std::lock</a>，可以同时对多个互斥量上锁。</li><li><a href="http://www.cplusplus.com/reference/mutex/call_once/" target="_blank" rel="noopener">std::call_once</a>，如果多个线程需要同时调用某个函数，call_once 可以保证多个线程对该函数只调用一次。</li></ul><h1 id="std-mutex-介绍"><a href="#std-mutex-介绍" class="headerlink" title="std::mutex 介绍"></a>std::mutex 介绍</h1><ul><li><p><strong>构造函数</strong>，std::mutex不允许拷贝构造，也不允许 move 拷贝，最初产生的 mutex 对象是处于 <strong>unlocked</strong> 状态的。</p></li><li><p><strong>lock()</strong>，调用线程将锁住该互斥量。线程调用该函数会发生下面 3 种情况：</p><p>(1). 如果该互斥量当前没有被锁住，则调用线程将该互斥量锁住，直到调用 unlock之前，该线程一直拥有该锁。</p><p>(2). 如果当前互斥量被其他线程锁住，则当前的调用线程被阻塞住。</p><p>(3). 如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)。</p></li><li><p><strong>unlock()</strong>， 解锁，释放对互斥量的所有权。</p></li><li><p><strong>try_lock()</strong>，尝试锁住互斥量，如果互斥量被其他线程占有，则当前线程也不会被阻塞。线程调用该函数也会出现下面 3 种情况，</p><p>(1). 如果当前互斥量没有被其他线程占有，则该线程锁住互斥量，直到该线程调用 unlock 释放互斥量。</p><p>(2). 如果当前互斥量被其他线程锁住，则当前调用线程返回 false，而并不会被阻塞掉。</p><p>(3). 如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)。</p></li></ul><p><strong>mutex::lock     </strong>Example(<a href="http://www.cplusplus.com/reference/mutex/mutex/lock/" target="_blank" rel="noopener">reference</a>):</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mutex::lock/unlock</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;       // std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;         // std::thread</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;          // std::mutex</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::mutex mtx;           <span class="comment">// mutex for critical section</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_thread_id</span> <span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// critical section (exclusive access to std::cout signaled by locking mtx):</span></span><br><span class="line">  mtx.lock();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"thread #"</span> &lt;&lt; id &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  mtx.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::thread threads[<span class="number">10</span>];</span><br><span class="line">  <span class="comment">// spawn 10 threads:</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i)</span><br><span class="line">    threads[i] = <span class="built_in">std</span>::thread(print_thread_id,i+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; th : threads) th.join();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">thread #1</span><br><span class="line">thread #2</span><br><span class="line">thread #3</span><br><span class="line">thread #4</span><br><span class="line">thread #5</span><br><span class="line">thread #6</span><br><span class="line">thread #7</span><br><span class="line">thread #8</span><br><span class="line">thread #9</span><br><span class="line">thread #10</span><br></pre></td></tr></table></figure><p><strong>mutex::try_lock     </strong>Example(<a href="http://www.cplusplus.com/reference/mutex/mutex/try_lock/" target="_blank" rel="noopener">reference</a>):</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mutex::try_lock example</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;       // std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;         // std::thread</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;          // std::mutex</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">volatile</span> <span class="keyword">int</span> <span class="title">counter</span> <span class="params">(<span class="number">0</span>)</span></span>; <span class="comment">// non-atomic counter</span></span><br><span class="line"><span class="built_in">std</span>::mutex mtx;           <span class="comment">// locks access to counter</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attempt_10k_increases</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mtx.try_lock()) &#123;   <span class="comment">// only increase if currently not locked:</span></span><br><span class="line">      ++counter;</span><br><span class="line">      mtx.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::thread threads[<span class="number">10</span>];</span><br><span class="line">  <span class="comment">// spawn 10 threads:</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i)</span><br><span class="line">    threads[i] = <span class="built_in">std</span>::thread(attempt_10k_increases);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; th : threads) th.join();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; counter &lt;&lt; <span class="string">" successful increases of the counter.\n"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Possible output (any count between 1 and 100000 possible):</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">17987 successful increases of the counter.</span><br></pre></td></tr></table></figure><h1 id="std-recursive-mutex-介绍"><a href="#std-recursive-mutex-介绍" class="headerlink" title="std::recursive_mutex 介绍"></a>std::recursive_mutex 介绍</h1><p><code>std::recursive_mutex</code> 与<code>std::mutex</code> 一样，也是一种可以被上锁的对象，但和 <code>std::mutex</code> 不同的是，<code>std::recursive_mutex</code> <strong>允许同一个线程对互斥量多次上锁（即递归上锁）</strong>，来获得对互斥量对象的<strong>多层所有权</strong>，<code>std::recursive_mutex</code> 释放互斥量时需要调用与该锁层次深度相同次数的 <code>unlock()</code>，可理解为 <code>lock()</code> 次数和<code>unlock()</code>次数相同，除此之外，<code>std::recursive_mutex</code> 的特性和 <code>std::mutex</code> 大致相同。</p><p>如果<strong>一个线程中可能在执行中需要再次获得锁</strong>的情况，按常规的做法会出现<strong>死锁</strong>。此时就需要使用递归式互斥量<code>std::recursive_mutex</code>来避免这个问题。<code>std::recursive_mutex</code>不会产生上述的死锁问题，只是是增加锁的计数,但必须确保你unlock和lock的次数相同，其他线程才可能锁这个mutex。</p><h1 id="std-time-mutex-介绍"><a href="#std-time-mutex-介绍" class="headerlink" title="std::time_mutex 介绍"></a>std::time_mutex 介绍</h1><p><code>std::time_mutex</code> 比 <code>std::mutex</code> 多了两个成员函数，<code>try_lock_for()，try_lock_until()</code>。</p><h2 id="try-lock-for"><a href="#try-lock-for" class="headerlink" title="try_lock_for()"></a>try_lock_for()</h2><p><code>try_lock_for</code> 函数接受一个时间范围，表示在这一段时间范围之内线程如果没有获得锁则被阻塞住（与 std::mutex 的 try_lock() 不同，try_lock 如果被调用时没有获得锁则直接返回 false），如果在此期间其他线程释放了锁，则该线程可以获得对互斥量的锁，如果超时（即在指定时间内还是没有获得锁），则返回 false。</p><p><strong>try_lock_for() —-</strong>Example(<a href="http://www.cplusplus.com/reference/mutex/timed_mutex/try_lock_for/" target="_blank" rel="noopener">reference</a>) </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;       // std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;         // std::chrono::milliseconds</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;         // std::thread</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;          // std::timed_mutex</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::timed_mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fireworks</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// waiting to get a lock: each thread prints "-" every 200ms:</span></span><br><span class="line">  <span class="keyword">while</span> (!mtx.try_lock_for(<span class="built_in">std</span>::chrono::milliseconds(<span class="number">200</span>))) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"-"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// got a lock! - wait for 1s, then this thread prints "*"</span></span><br><span class="line">  <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::milliseconds(<span class="number">1000</span>));</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"*\n"</span>;</span><br><span class="line">  mtx.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::thread threads[<span class="number">5</span>];</span><br><span class="line">  <span class="comment">// spawn 5 threads:</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    threads[i] = <span class="built_in">std</span>::thread(fireworks);</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; th : threads) th.join();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">----------------*</span><br><span class="line">---------------*</span><br><span class="line">----------*</span><br><span class="line">-----*</span><br><span class="line">*</span><br></pre></td></tr></table></figure><h2 id="try-lock-until"><a href="#try-lock-until" class="headerlink" title="try_lock_until()"></a>try_lock_until()</h2><p><code>try_lock_until</code> 函数则接受一个时间点作为参数，在指定时间点未到来之前线程如果没有获得锁则被阻塞住，如果在此期间其他线程释放了锁，则该线程可以获得对互斥量的锁，如果超时（即在指定时间内还是没有获得锁），则返回 false。</p><h1 id="std-lock-guard-介绍"><a href="#std-lock-guard-介绍" class="headerlink" title="std::lock_guard 介绍"></a>std::lock_guard 介绍</h1><p>与 Mutex RAII 相关，方便线程对互斥量上锁。</p><p>Example(<a href="http://www.cplusplus.com/reference/mutex/lock_guard/" target="_blank" rel="noopener">reference</a>):</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;       // std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;         // std::thread</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;          // std::mutex, std::lock_guard</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;      // std::logic_error</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_even</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x%<span class="number">2</span>==<span class="number">0</span>) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" is even\n"</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">throw</span> (<span class="built_in">std</span>::logic_error(<span class="string">"not even"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_thread_id</span> <span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// using a local lock_guard to lock mtx guarantees unlocking on destruction / exception:</span></span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lck (mtx);</span><br><span class="line">        print_even(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (<span class="built_in">std</span>::logic_error&amp;) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"[exception caught]\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::thread threads[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">// spawn 10 threads:</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i)</span><br><span class="line">        threads[i] = <span class="built_in">std</span>::thread(print_thread_id,i+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; th : threads) th.join();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[exception caught]</span><br><span class="line">2 is even</span><br><span class="line">[exception caught]</span><br><span class="line">4 is even</span><br><span class="line">[exception caught]</span><br><span class="line">6 is even</span><br><span class="line">[exception caught]</span><br><span class="line">8 is even</span><br><span class="line">[exception caught]</span><br><span class="line">10 is even</span><br></pre></td></tr></table></figure><h1 id="std-unique-lock-介绍"><a href="#std-unique-lock-介绍" class="headerlink" title="std::unique_lock 介绍"></a>std::unique_lock 介绍</h1><p>与 Mutex RAII 相关，方便线程对互斥量上锁，但提供了更好的上锁和解锁控制。</p><p>Example(<a href="http://www.cplusplus.com/reference/mutex/unique_lock/" target="_blank" rel="noopener">reference</a>):</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;       // std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;         // std::thread</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;          // std::mutex, std::unique_lock</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::mutex mtx;           <span class="comment">// mutex for critical section</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_block</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// critical section (exclusive access to std::cout signaled by lifetime of lck):</span></span><br><span class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lck (mtx);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">th1</span> <span class="params">(print_block,<span class="number">50</span>,<span class="string">'*'</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">th2</span> <span class="params">(print_block,<span class="number">50</span>,<span class="string">'$'</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    th1.join();</span><br><span class="line">    th2.join();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">**************************************************</span><br><span class="line"><span class="meta">$</span><span class="bash">$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$</span></span><br></pre></td></tr></table></figure><h1 id="std-lock-介绍"><a href="#std-lock-介绍" class="headerlink" title="std::lock 介绍"></a>std::lock 介绍</h1><p>Example(<a href="http://www.cplusplus.com/reference/mutex/lock/" target="_blank" rel="noopener">reference</a>):</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// std::lock example</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;       // std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;         // std::thread</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;          // std::mutex, std::lock</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::mutex foo,bar;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task_a</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// foo.lock(); bar.lock(); // replaced by:</span></span><br><span class="line">  <span class="built_in">std</span>::lock (foo,bar);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"task a\n"</span>;</span><br><span class="line">  foo.unlock();</span><br><span class="line">  bar.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task_b</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// bar.lock(); foo.lock(); // replaced by:</span></span><br><span class="line">  <span class="built_in">std</span>::lock (bar,foo);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"task b\n"</span>;</span><br><span class="line">  bar.unlock();</span><br><span class="line">  foo.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="function">thread <span class="title">th1</span> <span class="params">(task_a)</span></span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="function">thread <span class="title">th2</span> <span class="params">(task_b)</span></span>;</span><br><span class="line"></span><br><span class="line">  th1.join();</span><br><span class="line">  th2.join();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Possible output (order of lines may vary):</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">task a</span><br><span class="line">task b</span><br></pre></td></tr></table></figure><h1 id="std-try-lock-介绍"><a href="#std-try-lock-介绍" class="headerlink" title="std::try_lock 介绍"></a>std::try_lock 介绍</h1><p>尝试lock，若线程不可被lock返回false，否则进行lock。</p><p>Example(<a href="http://www.cplusplus.com/reference/mutex/try_lock/" target="_blank" rel="noopener">reference</a>):</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;       // std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;         // std::thread</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;          // std::mutex, std::try_lock</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::mutex foo,bar;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task_a</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  foo.lock();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"task a\n"</span>;</span><br><span class="line">  bar.lock();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  foo.unlock();</span><br><span class="line">  bar.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task_b</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = try_lock(bar,foo);</span><br><span class="line">  <span class="keyword">if</span> (x==<span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"task b\n"</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    bar.unlock();</span><br><span class="line">    foo.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"[task b failed: mutex "</span> &lt;&lt; (x?<span class="string">"foo"</span>:<span class="string">"bar"</span>) &lt;&lt; <span class="string">" locked]\n"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="function">thread <span class="title">th1</span> <span class="params">(task_a)</span></span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="function">thread <span class="title">th2</span> <span class="params">(task_b)</span></span>;</span><br><span class="line"></span><br><span class="line">  th1.join();</span><br><span class="line">  th2.join();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">task a</span><br><span class="line">[task b failed: mutex foo locked]</span><br></pre></td></tr></table></figure><h1 id="std-call-once-介绍"><a href="#std-call-once-介绍" class="headerlink" title="std::call_once 介绍"></a>std::call_once 介绍</h1><p>call_once可以很好的满足，某些场景下，我们需要代码只被执行一次，比如单例类的初始化，考虑到多线程安全，需要进行加锁控制。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Fn</span>, <span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">call_once</span> (<span class="title">once_flag</span>&amp; <span class="title">flag</span>, <span class="title">Fn</span>&amp;&amp; <span class="title">fn</span>, <span class="title">Args</span>&amp;&amp;... <span class="title">args</span>);</span></span><br></pre></td></tr></table></figure><ul><li><p>第一个参数是<code>std::once_flag</code>的对象(once_flag是不允许修改的，其拷贝构造函数和operator=函数都声明为delete)，</p></li><li><p>第二个参数可调用实体，即要求只执行一次的代码，后面可变参数是其参数列表。</p></li></ul><p>call_once保证函数fn只被执行一次，如果有多个线程同时执行函数fn调用，则只有一个活动线程(active call)会执行函数，其他的线程在这个线程执行返回之前会处于”passive execution”(被动执行状态)——不会直接返回，直到活动线程对fn调用结束才返回。对于所有调用函数fn的并发线程，数据可见性都是同步的(一致的)。</p><p>如果活动线程在执行fn时抛出异常，则会从处于”passive execution”状态的线程中挑一个线程成为活动线程继续执行fn，依此类推。一旦活动线程返回，所有”passive execution”状态的线程也返回,不会成为活动线程。(实际上once_flag相当于一个锁，使用它的线程都会在上面等待，只有一个线程允许执行。如果该线程抛出异常，那么从等待中的线程中选择一个，重复上面的流程)。</p><p>还有一个要注意的地方是 once_flag的生命周期，它必须要比使用它的线程的生命周期要长。所以通常定义成全局变量比较好。</p><p>Example(<a href="http://www.cplusplus.com/reference/mutex/call_once/" target="_blank" rel="noopener">reference</a>)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// call_once example</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;       // std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;         // std::thread, std::this_thread::sleep_for</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;         // std::chrono::milliseconds</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;          // std::call_once, std::once_flag</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> winner;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_winner</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; winner = x; &#125;</span><br><span class="line"><span class="built_in">std</span>::once_flag winner_flag;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait_1000ms</span> <span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// count to 1000, waiting 1ms between increments:</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; ++i)</span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::milliseconds(<span class="number">1</span>));</span><br><span class="line">  <span class="comment">// claim to be the winner (only the first such call is executed):</span></span><br><span class="line">  <span class="built_in">std</span>::call_once (winner_flag,set_winner,id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::thread threads[<span class="number">10</span>];</span><br><span class="line">  <span class="comment">// spawn 10 threads:</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i)</span><br><span class="line">    threads[i] = <span class="built_in">std</span>::thread(wait_1000ms,i+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"waiting for the first among 10 threads to count 1000 ms...\n"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; th : threads) th.join();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"winner thread: "</span> &lt;&lt; winner &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">waiting for the first among 10 threads to count 1000 ms...</span><br><span class="line">winner thread: 2</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Mutex&lt;/strong&gt;又称为互斥量，C++ 11中与 Mutex 相关的类（包括锁类型）和函数都声明在&lt;code&gt;&amp;lt;mutex&amp;gt;&lt;/code&gt; 头文件中，所以如果你需要使用 std::mutex，就必须包含 &lt;code&gt;&amp;lt;mutex&amp;
      
    
    </summary>
    
      <category term="Cpp" scheme="https://loopvoid.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://loopvoid.github.io/tags/Cpp/"/>
    
      <category term="Thread" scheme="https://loopvoid.github.io/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>C++并发学习笔记(二)(std::thread 详解)</title>
    <link href="https://loopvoid.github.io/2018/03/17/C-%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C-std-thread-%E8%AF%A6%E8%A7%A3/"/>
    <id>https://loopvoid.github.io/2018/03/17/C-并发学习笔记-二-std-thread-详解/</id>
    <published>2018-03-17T07:01:18.000Z</published>
    <updated>2019-08-06T06:59:03.700Z</updated>
    
    <content type="html"><![CDATA[<h1 id="std-thread-构造"><a href="#std-thread-构造" class="headerlink" title="std::thread 构造"></a>std::thread 构造</h1><p>std::thread 在<code>&lt;thread&gt;</code> 头文件中声明，因此使用 <code>std::thread</code>时需要包含<code>&lt;thread&gt;</code>头文件。</p><div class="table-container"><table><thead><tr><th style="text-align:left">default</th><th style="text-align:left">thread() noexcept;</th><th style="text-align:left">默认构造函数，创建一个空的 thread 执行对象</th></tr></thead><tbody><tr><td style="text-align:left">initialization</td><td style="text-align:left">template <class fn, class... args> explicit thread (Fn&amp;&amp; fn, Args&amp;&amp;… args);</class></td><td style="text-align:left">初始化构造函数，创建一个 thread对象，该 thread对象可被 joinable，新产生的线程会调用 fn 函数，该函数的参数由 args 给出。</td></tr><tr><td style="text-align:left">copy [deleted]</td><td style="text-align:left">thread (const thread&amp;) = delete;</td><td style="text-align:left">拷贝构造函数(被禁用)，意味着 thread 不可被拷贝构造。</td></tr><tr><td style="text-align:left">move</td><td style="text-align:left">thread (thread&amp;&amp; x) noexcept;</td><td style="text-align:left">move 构造函数，move 构造函数，调用成功之后 x 不代表任何 thread 执行对象</td></tr></tbody></table></div><p>注意：可被 joinable 的 thread 对象必须在他们销毁之前被主线程 join 或者将其设置为 detached.</p><p>Example (<a href="http://en.cppreference.com/w/cpp/thread/thread/thread" target="_blank" rel="noopener">reference</a>)：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Thread 1 executing\n"</span>;</span><br><span class="line">        ++n;</span><br><span class="line">        <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::milliseconds(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span>&amp; n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Thread 2 executing\n"</span>;</span><br><span class="line">        ++n;</span><br><span class="line">        <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::milliseconds(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">std</span>::thread t1; <span class="comment">// t1 is not a thread</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t2</span><span class="params">(f1, n + <span class="number">1</span>)</span></span>; <span class="comment">// pass by value</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t3</span><span class="params">(f2, <span class="built_in">std</span>::ref(n))</span></span>; <span class="comment">// pass by reference</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t4</span><span class="params">(<span class="built_in">std</span>::move(t3))</span></span>; <span class="comment">// t4 is now running f2(). t3 is no longer a thread</span></span><br><span class="line">    t2.join();</span><br><span class="line">    t4.join();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Final value of n is "</span> &lt;&lt; n &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Thread 1 executing</span><br><span class="line">Thread 2 executing</span><br><span class="line">Thread 1 executing</span><br><span class="line">Thread 2 executing</span><br><span class="line">Thread 1 executing</span><br><span class="line">Thread 2 executing</span><br><span class="line">Thread 1 executing</span><br><span class="line">Thread 2 executing</span><br><span class="line">Thread 1 executing</span><br><span class="line">Thread 2 executing</span><br><span class="line">Final value of n is 5</span><br></pre></td></tr></table></figure><h1 id="move-赋值操作"><a href="#move-赋值操作" class="headerlink" title="move 赋值操作"></a>move 赋值操作</h1><div class="table-container"><table><thead><tr><th>move</th><th><code>thread&amp; operator= (thread&amp;&amp; rhs) noexcept;</code></th><th>move 赋值操作，如果当前对象不可 joinable，需要传递一个右值引用(rhs)给 move 赋值操作；如果当前对象可被 joinable，则 terminate() 报错。</th></tr></thead><tbody><tr><td>copy [deleted]</td><td><code>thread&amp; operator= (const thread&amp;) = delete;</code></td><td>拷贝赋值操作被禁用，thread 对象不可被拷贝。</td></tr></tbody></table></div><p>Example :</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sub_task</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::milliseconds(n));</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello world "</span> </span><br><span class="line">&lt;&lt; <span class="built_in">std</span>::this_thread::get_id()</span><br><span class="line">&lt;&lt; <span class="string">" paused "</span> &lt;&lt; n &lt;&lt; <span class="string">" milliseconds"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::thread threads[<span class="number">5</span>];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Spawning 5 threads...\n"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">threads[i] = <span class="built_in">std</span>::thread(sub_task, i);</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Done spawning threads! Now wait for them to join\n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;t : threads)</span><br><span class="line">t.join();</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"All threads joined.\n"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="其他成员函数"><a href="#其他成员函数" class="headerlink" title="其他成员函数"></a>其他成员函数</h1><h2 id="get-id"><a href="#get-id" class="headerlink" title="get_id"></a>get_id</h2><p><a href="http://www.cplusplus.com/reference/thread/thread/get_id/" target="_blank" rel="noopener"><strong>get_id</strong></a>获取线程 ID<br>若该线程是joinable的，该函数返回该线程ID<br>若该线程不是joinable的，该函数返回成员默认类型<a href="http://www.cplusplus.com/thread::id" target="_blank" rel="noopener"><strong>thread::id</strong></a></p><p>Example：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// thread::get_id / this_thread::get_id</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;       // std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;         // std::thread, std::thread::id, std::this_thread::get_id</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;         // std::chrono::seconds</span></span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::thread::id main_thread_id = <span class="built_in">std</span>::this_thread::get_id();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">is_main_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( main_thread_id == <span class="built_in">std</span>::this_thread::get_id() )</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"This is the main thread.\n"</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"This is not the main thread.\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  is_main_thread();</span><br><span class="line">  <span class="built_in">std</span>::<span class="function">thread <span class="title">th</span> <span class="params">(is_main_thread)</span></span>;</span><br><span class="line">  th.join();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">This is the main thread.</span><br><span class="line">This is not the main thread.</span><br></pre></td></tr></table></figure><h2 id="joinable"><a href="#joinable" class="headerlink" title="joinable"></a>joinable</h2><p><a href="http://www.cplusplus.com/reference/thread/thread/joinable/" target="_blank" rel="noopener"><strong>joinable</strong></a>    检查线程是否可被 join</p><p>线程可被join：当其为可执行线程时。</p><p>线程不可被join：</p><ul><li>1、线程是<strong><a href="http://www.cplusplus.com/thread::thread" target="_blank" rel="noopener">default-constructed</a></strong>(默认构造)</li><li>2、当其被moved</li><li>3、当其成员<strong>join</strong>或<strong>detach</strong>被调用时</li></ul><p>当去销毁一个仍然可以“joinable”的C++线程对象会被认为是一种错误。为了销毁一个C++线程对象，约么join()函数需要被调用（并结束），要么detach()函数被调用。如果一个C++线程对象当销毁时仍然可以被join，异常会被抛出。</p><p>Example:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;       // std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;         // std::thread</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mythread</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// do stuff...</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::thread foo;</span><br><span class="line">  <span class="built_in">std</span>::<span class="function">thread <span class="title">bar</span><span class="params">(mythread)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Joinable after construction:\n"</span> &lt;&lt; <span class="built_in">std</span>::boolalpha;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"foo: "</span> &lt;&lt; foo.joinable() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"bar: "</span> &lt;&lt; bar.joinable() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (foo.joinable()) foo.join();</span><br><span class="line">  <span class="keyword">if</span> (bar.joinable()) bar.join();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Joinable after joining:\n"</span> &lt;&lt; <span class="built_in">std</span>::boolalpha;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"foo: "</span> &lt;&lt; foo.joinable() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"bar: "</span> &lt;&lt; bar.joinable() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output(after 3 seconds):</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Joinable after construction:</span><br><span class="line">foo: false</span><br><span class="line">bar: true</span><br><span class="line">Joinable after joining:</span><br><span class="line">foo: false</span><br><span class="line">bar: false</span><br></pre></td></tr></table></figure><h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><p><a href="http://www.cplusplus.com/reference/thread/thread/join/" target="_blank" rel="noopener"><strong>join</strong></a>Join线程</p><p>当thread::join()函数被调用后，调用它的线程会被block，直到线程的执行被完成。基本上，这是一种可以用来知道一个线程已结束的机制。当thread::join()返回时，OS的执行的线程已经完成，C++线程对象可以被销毁。</p><p>Exapmle:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;       // std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;         // std::thread, std::this_thread::sleep_for</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;         // std::chrono::seconds</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pause_thread</span><span class="params">(<span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::this_thread::sleep_for (<span class="built_in">std</span>::chrono::seconds(n));</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"pause of "</span> &lt;&lt; n &lt;&lt; <span class="string">" seconds ended\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Spawning 3 threads...\n"</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="function">thread <span class="title">t1</span> <span class="params">(pause_thread,<span class="number">1</span>)</span></span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="function">thread <span class="title">t2</span> <span class="params">(pause_thread,<span class="number">2</span>)</span></span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="function">thread <span class="title">t3</span> <span class="params">(pause_thread,<span class="number">3</span>)</span></span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Done spawning threads. Now waiting for them to join:\n"</span>;</span><br><span class="line">  t1.join();</span><br><span class="line">  t2.join();</span><br><span class="line">  t3.join();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"All threads joined!\n"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output (after 3 seconds):</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Spawning 3 threads...</span><br><span class="line">Done spawning threads. Now waiting for them to join:</span><br><span class="line">pause of 1 seconds ended</span><br><span class="line">pause of 2 seconds ended</span><br><span class="line">pause of 3 seconds ended</span><br><span class="line">All threads joined!</span><br></pre></td></tr></table></figure><h2 id="detach"><a href="#detach" class="headerlink" title="detach"></a>detach</h2><p><a href="http://www.cplusplus.com/reference/thread/thread/detach/" target="_blank" rel="noopener"><strong>detach</strong></a>Detach线程</p><p>detach允许线程独立运行，线程结束，资源会释放。</p><p>当thread::detach()函数被调用后，执行的线程从线程对象中被分离，已不再被一个线程对象所表达—这是两个独立的事情。C++线程对象可以被销毁，同时OS执行的线程可以继续。如果程序想要知道执行的线程何时结束，就需要一些其它的机制。join()函数在那个thread对象上不能再被调用，因为它已经不再和一个执行的线程相关联。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;       // std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;         // std::thread, std::this_thread::sleep_for</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;         // std::chrono::seconds</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pause_thread</span><span class="params">(<span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::this_thread::sleep_for (<span class="built_in">std</span>::chrono::seconds(n));</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"pause of "</span> &lt;&lt; n &lt;&lt; <span class="string">" seconds ended\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Spawning and detaching 3 threads...\n"</span>;</span><br><span class="line">  <span class="built_in">std</span>::thread (pause_thread,<span class="number">1</span>).detach();</span><br><span class="line">  <span class="built_in">std</span>::thread (pause_thread,<span class="number">2</span>).detach();</span><br><span class="line">  <span class="built_in">std</span>::thread (pause_thread,<span class="number">3</span>).detach();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Done spawning threads.\n"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"(the main thread will now pause for 5 seconds)\n"</span>;</span><br><span class="line">  <span class="comment">// give the detached threads time to finish (but not guaranteed!):</span></span><br><span class="line">  pause_thread(<span class="number">5</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Spawning and detaching 3 threads...</span><br><span class="line">Done spawning threads.</span><br><span class="line">(the main thread will now pause for 5 seconds)</span><br><span class="line">pause of 1 seconds ended</span><br><span class="line">pause of 2 seconds ended</span><br><span class="line">pause of 3 seconds ended</span><br><span class="line">pause of 5 seconds ended</span><br></pre></td></tr></table></figure><h2 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h2><p><a href="http://www.cplusplus.com/reference/thread/thread/swap/" target="_blank" rel="noopener"><strong>swap</strong></a>Swap线程</p><p>互换两个 thread 对象的底层句柄</p><p>Example:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t1</span><span class="params">(foo)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t2</span><span class="params">(bar)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"thread 1 id: "</span> &lt;&lt; t1.get_id() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"thread 2 id: "</span> &lt;&lt; t2.get_id() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::swap(t1, t2);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"after std::swap(t1, t2):"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"thread 1 id: "</span> &lt;&lt; t1.get_id() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"thread 2 id: "</span> &lt;&lt; t2.get_id() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    t1.swap(t2);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"after t1.swap(t2):"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"thread 1 id: "</span> &lt;&lt; t1.get_id() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"thread 2 id: "</span> &lt;&lt; t2.get_id() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">thread 1 id: 1892</span><br><span class="line">thread 2 id: 2584</span><br><span class="line">after std::swap(t1, t2):</span><br><span class="line">thread 1 id: 2584</span><br><span class="line">thread 2 id: 1892</span><br><span class="line">after t1.swap(t2):</span><br><span class="line">thread 1 id: 1892</span><br><span class="line">thread 2 id: 2584</span><br></pre></td></tr></table></figure><h2 id="native-handle"><a href="#native-handle" class="headerlink" title="native_handle"></a>native_handle</h2><p><a href="http://www.cplusplus.com/reference/thread/thread/native_handle/" target="_blank" rel="noopener"><strong>native_handle</strong></a>返回 native handle 表示线程的实现定义句柄类型</p><p>Example: 在 POSIX 系统上用 native_handle 启用 C++ 线程的实时调度</p><p>只有库函数支持该函数时该方法才会有效，用于获得与操作系统相关的原生线程句柄</p><p>Example:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;  </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"n="</span>&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(show,<span class="number">18</span>)</span></span>;  </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"t.get_id="</span>&lt;&lt;t.get_id()&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">    <span class="keyword">auto</span> tn=t.native_handle();  </span><br><span class="line">    t.join();  </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"tn="</span>&lt;&lt;tn&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t.get_id=n=2</span><br><span class="line">18</span><br><span class="line">tn=2</span><br></pre></td></tr></table></figure><h2 id="hardware-concurrency-static"><a href="#hardware-concurrency-static" class="headerlink" title="hardware_concurrency [static]"></a>hardware_concurrency [static]</h2><p><a href="http://www.cplusplus.com/reference/thread/thread/hardware_concurrency/" target="_blank" rel="noopener"><strong>hardware_concurrency (static)</strong></a>检测硬件并发特性</p><p>公共静态成员函数、检测硬件的并发特性、返回硬件线程上下文的数量</p><p>返回值：支持的并发线程数。若值不可计算，则返回 0；</p><p>Example:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> n = <span class="built_in">std</span>::thread::hardware_concurrency();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">" concurrent threads are supported.\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8 concurrent threads are supported.</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;std-thread-构造&quot;&gt;&lt;a href=&quot;#std-thread-构造&quot; class=&quot;headerlink&quot; title=&quot;std::thread 构造&quot;&gt;&lt;/a&gt;std::thread 构造&lt;/h1&gt;&lt;p&gt;std::thread 在&lt;code&gt;&amp;lt;t
      
    
    </summary>
    
      <category term="Cpp" scheme="https://loopvoid.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://loopvoid.github.io/tags/Cpp/"/>
    
      <category term="Thread" scheme="https://loopvoid.github.io/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>C++并发学习笔记(一)</title>
    <link href="https://loopvoid.github.io/2018/03/17/C-%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/"/>
    <id>https://loopvoid.github.io/2018/03/17/C-并发学习笔记-一/</id>
    <published>2018-03-17T06:47:18.000Z</published>
    <updated>2019-08-06T06:57:39.128Z</updated>
    
    <content type="html"><![CDATA[<h1 id="资料汇总"><a href="#资料汇总" class="headerlink" title="资料汇总"></a>资料汇总</h1><p><a href="http://www.open-std.org/jtc1/sc22/wg21/" target="_blank" rel="noopener">http://www.open-std.org/jtc1/sc22/wg21/</a></p><p>C++0x/C++11 Support in GCC：<a href="http://gcc.gnu.org/projects/cxx0x.html" target="_blank" rel="noopener">http://gcc.gnu.org/projects/cxx0x.html</a></p><p>What is C++0x：<a href="https://www2.research.att.com/~bs/what-is-2009.pdf" target="_blank" rel="noopener">https://www2.research.att.com/~bs/what-is-2009.pdf</a></p><p>Overview of the New C++：<a href="http://www.artima.com/shop/overview_of_the_new_cpp" target="_blank" rel="noopener">http://www.artima.com/shop/overview_of_the_new_cpp</a></p><p>Overview of the New C++ (C++0x).pdf：<a href="http://ishare.iask.sina.com.cn/f/20120005.html?from=like" target="_blank" rel="noopener">http://ishare.iask.sina.com.cn/f/20120005.html?from=like</a></p><p>A Brief Look at C++0x：<a href="http://www.artima.com/cppsource/cpp0x.html" target="_blank" rel="noopener">http://www.artima.com/cppsource/cpp0x.html</a></p><p>Summary of C++11 Feature Availability in gcc and MSVC：<a href="http://www.aristeia.com/C++11/C++11FeatureAvailability.htm" target="_blank" rel="noopener">http://www.aristeia.com/C++11/C++11FeatureAvailability.htm</a></p><p>C++ 11: Come Closer：<a href="http://www.codeproject.com/Articles/344282/Cplusplus-11-Come-Closer" target="_blank" rel="noopener">http://www.codeproject.com/Articles/344282/Cplusplus-11-Come-Closer</a></p><p>C++11 threads, locks and condition variables： <a href="http://www.codeproject.com/Articles/598695/Cplusplus11-threads-locks-and-condition-variables" target="_blank" rel="noopener">http://www.codeproject.com/Articles/598695/Cplusplus11-threads-locks-and-condition-variables</a></p><p>Move Semantics and Perfect Forwarding in C++11：<a href="http://www.codeproject.com/Articles/397492/Move-Semantics-and-Perfect-Forwarding-in-Cplusplus" target="_blank" rel="noopener">http://www.codeproject.com/Articles/397492/Move-Semantics-and-Perfect-Forwarding-in-Cplusplus</a></p><p><a href="http://solarianprogrammer.com/categories/C++11/" target="_blank" rel="noopener">http://solarianprogrammer.com/categories/C++11/</a></p><p>C++11 Concurrency：<a href="http://www.baptiste-wicht.com/2012/03/cpp11-concurrency-part1-start-threads/" target="_blank" rel="noopener">http://www.baptiste-wicht.com/2012/03/cpp11-concurrency-part1-start-threads/</a></p><p><a href="http://www.hpl.hp.com/personal/Hans_Boehm/misc_slides/sfacm-cleaned.pdf" target="_blank" rel="noopener">http://www.hpl.hp.com/personal/Hans_Boehm/misc_slides/sfacm-cleaned.pdf</a></p><p><a href="http://en.cppreference.com/w/cpp/thread" target="_blank" rel="noopener">http://en.cppreference.com/w/cpp/thread</a></p><p><a href="http://isocpp.org/blog/2012/12/c11-a-cheat-sheet-alex-sinyakov" target="_blank" rel="noopener">http://isocpp.org/blog/2012/12/c11-a-cheat-sheet-alex-sinyakov</a></p><p>The Biggest Changes in C++11：<a href="http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/" target="_blank" rel="noopener">http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/</a></p><p>Ten C++11 Features Every C++ Developer Should Use：<a href="http://www.codeproject.com/Articles/570638/Ten-Cplusplus11-Features-Every-Cplusplus-Developer" target="_blank" rel="noopener">http://www.codeproject.com/Articles/570638/Ten-Cplusplus11-Features-Every-Cplusplus-Developer</a></p><p> C++11 – A Glance [part 1 of n]：<a href="http://www.codeproject.com/Articles/312029/Cplusplus11-A-Glance-part-1-of-n" target="_blank" rel="noopener">http://www.codeproject.com/Articles/312029/Cplusplus11-A-Glance-part-1-of-n</a></p><p> C++11 – A Glance [part 2 of n]：<a href="http://www.codeproject.com/Articles/314415/Cplusplus11-A-Glance-part-2-of-n" target="_blank" rel="noopener">http://www.codeproject.com/Articles/314415/Cplusplus11-A-Glance-part-2-of-n</a></p><p>C++11（及现代C++风格）和快速迭代式开发：<a href="http://mindhacks.cn/2012/08/27/modern-cpp-practices/" target="_blank" rel="noopener">http://mindhacks.cn/2012/08/27/modern-cpp-practices/</a></p><p>Lambda Functions in C++11 - the Definitive Guide：<a href="http://www.cprogramming.com/c++11/c++11-lambda-closures.html" target="_blank" rel="noopener">http://www.cprogramming.com/c++11/c++11-lambda-closures.html</a></p><p>Better types in C++11 - nullptr, enum classes (strongly typed enumerations) and cstdint：<a href="http://www.cprogramming.com/c++11/c++11-nullptr-strongly-typed-enum-class.html" target="_blank" rel="noopener">http://www.cprogramming.com/c++11/c++11-nullptr-strongly-typed-enum-class.html</a></p><p>Rvalue-references-and-move-semantics-in-c++11：<a href="http://www.cprogramming.com/c++11/rvalue-references-and-move-semantics-in-c++11.html" target="_blank" rel="noopener">http://www.cprogramming.com/c++11/rvalue-references-and-move-semantics-in-c++11.html</a></p><p><a href="http://www.gotw.ca/publications/index.htm" target="_blank" rel="noopener">http://www.gotw.ca/publications/index.htm</a></p><p><a href="http://www.devx.com/SpecialReports/Door/38865" target="_blank" rel="noopener">http://www.devx.com/SpecialReports/Door/38865</a></p><p>Multi-threading in C++0x：<a href="http://accu.org/index.php/journals/1584" target="_blank" rel="noopener">http://accu.org/index.php/journals/1584</a></p><p>C++ 0X feature summary cheat sheat：<a href="http://www.iesensor.com/blog/2011/05/31/c-0x-feature-summary-cheat-sheat/" target="_blank" rel="noopener">http://www.iesensor.com/blog/2011/05/31/c-0x-feature-summary-cheat-sheat/</a></p><p>Multithreading in C++0x part 1: Starting Threads：<a href="http://www.justsoftwaresolutions.co.uk/threading/multithreading-in-c++0x-part-1-starting-threads.html" target="_blank" rel="noopener">http://www.justsoftwaresolutions.co.uk/threading/multithreading-in-c++0x-part-1-starting-threads.html</a></p><p><a href="http://en.cppreference.com/w/cpp/thread" target="_blank" rel="noopener">http://en.cppreference.com/w/cpp/thread</a></p><p><a href="http://www.cplusplus.com/reference/multithreading/" target="_blank" rel="noopener">http://www.cplusplus.com/reference/multithreading/</a></p><h1 id="与-C-11-多线程相关的头文件"><a href="#与-C-11-多线程相关的头文件" class="headerlink" title="与 C++11 多线程相关的头文件"></a>与 C++11 多线程相关的头文件</h1><p>C++11 新标准中引入了四个头文件来支持多线程编程，他们分别是<code>&lt;atomic&gt;</code> ,<code>&lt;thread&gt;</code>,<code>&lt;mutex&gt;</code>,<code>&lt;condition_variable&gt;</code>和<code>&lt;future&gt;</code>。</p><ul><li><code>&lt;atomic&gt;</code>：该头文主要声明了两个类, <code>std::atomic</code> 和<code>std::atomic_flag</code>，另外还声明了一套 C 风格的原子类型和与 C 兼容的原子操作的函数。</li><li><code>&lt;thread&gt;</code>：该头文件主要声明了 <code>std::thread</code> 类，另外 <code>std::this_thread</code> 命名空间也在该头文件中。</li><li><code>&lt;mutex&gt;</code>：该头文件主要声明了与<strong>互斥量(mutex)</strong>相关的类，包括 <code>std::mutex</code> 系列类，<code>std::lock_guard</code>, <code>std::unique_lock</code>, 以及其他的类型和函数。</li><li><code>&lt;condition_variable&gt;</code>：该头文件主要声明了与条件变量相关的类，包括 <code>std::condition_variable</code> 和 <code>std::condition_variable_any</code>。</li><li><code>&lt;future&gt;</code>：该头文件主要声明了 <code>std::promise</code>, <code>std::package_task</code> 两个 Provider 类，以及 <code>std::future</code> 和 <code>std::shared_future</code> 两个 Future 类，另外还有一些与之相关的类型和函数，<code>std::async()</code> 函数就声明在此头文件中。</li></ul><h1 id="多线程Hello-World"><a href="#多线程Hello-World" class="headerlink" title="多线程Hello World!"></a>多线程Hello World!</h1><p>Example 1：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sub_task</span><span class="params">()</span></span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello world"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">t</span><span class="params">(sub_task)</span></span>;</span><br><span class="line">t.join();</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Example 2：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i+j &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">uint8_t</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">t</span><span class="params">(output, i, i)</span></span>;</span><br><span class="line">t.detach();</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：<a href="http://www.cnblogs.com/haippy/" target="_blank" rel="noopener">256code</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;资料汇总&quot;&gt;&lt;a href=&quot;#资料汇总&quot; class=&quot;headerlink&quot; title=&quot;资料汇总&quot;&gt;&lt;/a&gt;资料汇总&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/&quot; target=&quot;_bla
      
    
    </summary>
    
      <category term="Cpp" scheme="https://loopvoid.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://loopvoid.github.io/tags/Cpp/"/>
    
      <category term="Thread" scheme="https://loopvoid.github.io/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>Cpp回调函数的方式和作用</title>
    <link href="https://loopvoid.github.io/2018/03/17/Cpp%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%9A%84%E6%96%B9%E5%BC%8F%E5%92%8C%E4%BD%9C%E7%94%A8/"/>
    <id>https://loopvoid.github.io/2018/03/17/Cpp回调函数的方式和作用/</id>
    <published>2018-03-17T05:04:18.000Z</published>
    <updated>2019-08-06T06:56:25.140Z</updated>
    
    <content type="html"><![CDATA[<h1 id="指针函数和函数指针"><a href="#指针函数和函数指针" class="headerlink" title="指针函数和函数指针"></a>指针函数和函数指针</h1><p>谈到回调函数得先区分好<strong>指针函数</strong>和<strong>函数指针。</strong></p><h2 id="指针函数"><a href="#指针函数" class="headerlink" title="指针函数"></a>指针函数</h2><p><strong>指针函数：</strong>是指带指针的函数，本质是一个<strong>函数</strong>，函数的返回类型是某一类型的指针。</p><p><strong>声明格式：</strong><code>类型标识符 *函数名(参数表)</code></p><p><strong>示例：</strong> <code>int *func(x,y)</code></p><p>首先它是一个函数，只不过这个函数的返回值是一个地址值。函数返回值必须用同类型的指针变量来接受，也就是说，指针函数一定有函数返回值，而且，在主调函数中，函数返回值必须赋给同类型的指针变量。由于返回的是一个地址，所以类型说明符一般都是int。</p><p>函数返回的是一个地址值，经常使用在返回数组的某一元素地址上。</p><p>下面是一个简单的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">get_letter</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> arr[]=&#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> &amp;arr[num<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (<span class="keyword">char</span>) *get_letter(num) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子函数<code>int *get_letter(int num)</code>返回的是数组某元素的地址。输出的是这个地址里的值。</p><p><code>(char) *get_letter(num)</code>其中(char)是将*get_letter(num)返回的数组某元素的地址里的值转换成char类型输出。</p><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p><strong>函数指针</strong>是指向函数的指针变量<strong>，**</strong>本质是一个指针变量。**</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*f_p)(<span class="keyword">int</span> x);<span class="comment">//声明一个函数指针</span></span><br><span class="line">f_p = func;<span class="comment">//将func函数首地址赋值给指针f_P</span></span><br></pre></td></tr></table></figure><p>指向函数的指针包含了函数的地址的入口地址，可以通过它来调用函数。</p><p><strong>声明格式：</strong><code>类型说明符 (*函数名)(参数)</code></p><p>其实这里不能称为函数名，应该叫做指针的变量名。这个特殊的指针指向一个返回整型值的函数。</p><p>指针的声明必须和它指向函数的声明保持一致。</p><p>指针名和指针运算符外面的括号改变了默认的运算符优先级。如果没有圆括号，就变成了一个返回整型指针的函数原型的声明。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (*f_p)();<span class="comment">//声明一个函数指针，参数列表为控</span></span><br><span class="line"><span class="comment">//把函数的地址赋值给函数指针，可以采用下面两种形式：</span></span><br><span class="line">f_p = &amp;Function;</span><br><span class="line">f_p = Function;</span><br></pre></td></tr></table></figure><p>取地址运算符&amp;不是必需的，因为单单一个函数标识符就标号表示了它的地址.<br>如果是函数调用，还必须包含一个圆括号括起来的参数表。</p><p>可以采用如下两种方式来通过指针调用函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = (*f_p)();</span><br><span class="line">x = f_p;</span><br></pre></td></tr></table></figure><p>下面是一个简单的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>(*f_p)();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FileFunc</span><span class="params">()</span></span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"FileFunc"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EditFunc</span><span class="params">()</span></span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"EditFunc"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">f_p = FileFunc;</span><br><span class="line">(*f_p)();<span class="comment">//第一种调用方式</span></span><br><span class="line">f_p =EditFunc;</span><br><span class="line">f_p();<span class="comment">//第二种调用方式</span></span><br><span class="line">    </span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FileFunc</span><br><span class="line">EditFunc</span><br><span class="line">请按任意键继续. . .</span><br></pre></td></tr></table></figure><h1 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h1><p>回调函数是通过<strong>函数指针</strong>调用的函数：把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，就称为回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。</p><p>引用知乎 <a href="https://www.zhihu.com/question/19801131/answer/13005983" target="_blank" rel="noopener">常溪玲</a>一个形象的示例：</p><p>你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。在这个例子里，你的电话号码就叫<strong>回调函数</strong>，你把电话留给店员就叫<strong>登记回调函数</strong>，店里后来有货了叫做<strong>触发回调关联的事件</strong>，店员给你打电话叫做<strong>调用回调函数</strong>，你到店里去取货叫做<strong>响应回调事件</strong>。</p><p>下面是一个简单的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*Fun_p)</span><span class="params">(<span class="keyword">int</span>)</span></span>;<span class="comment">//定义一个函数指针类型  </span></span><br><span class="line">Fun_p p = <span class="literal">NULL</span>;<span class="comment">//用Fun定义一个变量p，它指向一个返回值为空参数为int的函数  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 向外提供的回调函数注册接口，提供注册登记服务 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerFun</span><span class="params">(Fun_p pCallback)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    p = pCallback;  </span><br><span class="line">    </span><br><span class="line">&#125;  </span><br><span class="line"> <span class="comment">//达成某一条件后，通过名片（函数指针p），传回结果 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trigger</span><span class="params">(<span class="keyword">int</span> result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (*p)(result);<span class="comment">//将result传入当前函数指针(*p)所指向的函数(callback函数)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//回调函数 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callback</span><span class="params">(<span class="keyword">int</span> a)</span> </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"callback result = "</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    registerFun(callback);<span class="comment">//注册回调函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">    trigger(result);<span class="comment">//触发回调函数关联事件</span></span><br><span class="line">      </span><br><span class="line">    system(<span class="string">"pause"</span>); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出：callback result = 1</span><br></pre></td></tr></table></figure><p><code>typedef int (* Fun_p)(void);</code>定义了一个新类型 Fun</p><p><code>Fun_p p = NULL;</code>//用Fun_p定义一个变量p，p的类型是<code>void (*Fun_p)(int)</code>这样一个<strong>函数指针</strong>类型。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;指针函数和函数指针&quot;&gt;&lt;a href=&quot;#指针函数和函数指针&quot; class=&quot;headerlink&quot; title=&quot;指针函数和函数指针&quot;&gt;&lt;/a&gt;指针函数和函数指针&lt;/h1&gt;&lt;p&gt;谈到回调函数得先区分好&lt;strong&gt;指针函数&lt;/strong&gt;和&lt;strong&gt;函
      
    
    </summary>
    
      <category term="Cpp" scheme="https://loopvoid.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://loopvoid.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>Linux多线程编程入门笔记</title>
    <link href="https://loopvoid.github.io/2018/03/16/Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"/>
    <id>https://loopvoid.github.io/2018/03/16/Linux多线程编程入门笔记/</id>
    <published>2018-03-16T14:27:18.000Z</published>
    <updated>2019-08-06T06:46:13.973Z</updated>
    
    <content type="html"><![CDATA[<h2 id="最基础，进程同时创建5个线程，各自调用同一个函数"><a href="#最基础，进程同时创建5个线程，各自调用同一个函数" class="headerlink" title="最基础，进程同时创建5个线程，各自调用同一个函数"></a>最基础，进程同时创建5个线程，各自调用同一个函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; //多线程相关操作头文件，可移植众多平台  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_THREADS 5 <span class="comment">//线程数  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">say_hello</span><span class="params">( <span class="keyword">void</span>* args )</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"hello..."</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125; <span class="comment">//函数返回的是函数指针，便于后面作为参数  </span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">pthread_t</span> tids[NUM_THREADS]; <span class="comment">//线程id  </span></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; ++i )  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">int</span> ret = pthread_create( &amp;tids[i], <span class="literal">NULL</span>, say_hello, <span class="literal">NULL</span> ); <span class="comment">//参数：创建的线程id，线程参数，线程运行函数的起始地址，运行函数的参数  </span></span><br><span class="line">        <span class="keyword">if</span>( ret != <span class="number">0</span> ) <span class="comment">//创建线程成功返回0  </span></span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"pthread_create error:error_code="</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    pthread_exit( <span class="literal">NULL</span> ); <span class="comment">//等待各个线程退出后，进程才结束，否则进程强制结束，线程处于未终止的状态 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入命令：<code>g++ pthread_chap1.cpp -o pthread_chap1 -lpthread</code></p><p>注意:</p><blockquote><ul><li>此为c++程序，故用g++来编译生成可执行文件，并且要调用处理多线程操作相关的静态链接库文件pthread。</li><li>-lpthread 编译选项到位置可任意，如g++ -o pthread_chap1 pthread_chap1.cpp -lpthread</li><li>​</li></ul></blockquote><p>测试结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">jack@jack:~/coding/muti_thread$ ./pthread_chap1 </span><br><span class="line">hello...hello...  </span><br><span class="line">hello...  </span><br><span class="line">hello...  </span><br><span class="line">  </span><br><span class="line">hello... </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">jack@jack:~/coding/muti_thread$ ./pthread_chap1 </span><br><span class="line">hello...hello...hello...  </span><br><span class="line">hello...  </span><br><span class="line">  </span><br><span class="line">hello...</span><br></pre></td></tr></table></figure><p>可知，两次运行的结果会有差别，这不是多线程的特点吧？这显然没有同步？还有待进一步探索…<br>多线程的运行是混乱的，混乱就是正常？</p><h2 id="线程调用到函数在一个类中，那必须将该函数声明为静态函数函数"><a href="#线程调用到函数在一个类中，那必须将该函数声明为静态函数函数" class="headerlink" title="线程调用到函数在一个类中，那必须将该函数声明为静态函数函数"></a>线程调用到函数在一个类中，那必须将该函数声明为静态函数函数</h2><p>因为静态成员函数属于静态全局区，线程可以共享这个区域，故可以各自调用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_THREADS 5  </span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">say_hello</span><span class="params">( <span class="keyword">void</span>* args )</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"hello..."</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">pthread_t</span> tids[NUM_THREADS];  </span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; ++i )  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">int</span> ret = pthread_create( &amp;tids[i], <span class="literal">NULL</span>, Hello::say_hello, <span class="literal">NULL</span> );  </span><br><span class="line">        <span class="keyword">if</span>( ret != <span class="number">0</span> )  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"pthread_create error:error_code"</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    pthread_exit( <span class="literal">NULL</span> );  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jack@jack:~/coding/muti_thread$ ./pthread_chap2</span><br><span class="line">hello...hello...hello...  </span><br><span class="line">hello...  </span><br><span class="line">hello... </span><br><span class="line"></span><br><span class="line">jack@jack:~/coding/muti_thread$ ./pthread_chap2</span><br><span class="line">hello...</span><br><span class="line">hello...</span><br><span class="line">hello...  </span><br><span class="line">hello...  </span><br><span class="line">hello...</span><br></pre></td></tr></table></figure><h2 id="如何在线程调用函数时传入参数呢？"><a href="#如何在线程调用函数时传入参数呢？" class="headerlink" title="如何在线程调用函数时传入参数呢？"></a>如何在线程调用函数时传入参数呢？</h2><p>先看下面修改的代码，传入线程编号作为参数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; //多线程相关操作头文件，可移植众多平台  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_THREADS 5 <span class="comment">//线程数  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">say_hello</span><span class="params">( <span class="keyword">void</span>* args )</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i = *( (<span class="keyword">int</span>*)args ); <span class="comment">//对传入的参数进行强制类型转换，由无类型指针转变为整形指针，再用*读取其指向到内容  </span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"hello in "</span> &lt;&lt; i &lt;&lt;  <span class="built_in">endl</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">&#125; <span class="comment">//函数返回的是函数指针，便于后面作为参数  </span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">pthread_t</span> tids[NUM_THREADS]; <span class="comment">//线程id  </span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"hello in main.."</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; ++i )  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">int</span> ret = pthread_create( &amp;tids[i], <span class="literal">NULL</span>, say_hello, (<span class="keyword">void</span>*)&amp;i ); <span class="comment">//传入到参数必须强转为void*类型，即无类型指针，&amp;i表示取i的地址，即指向i的指针  </span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Current pthread id = "</span> &lt;&lt; tids[i] &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//用tids数组打印创建的进程id信息  </span></span><br><span class="line">        <span class="keyword">if</span>( ret != <span class="number">0</span> ) <span class="comment">//创建线程成功返回0  </span></span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"pthread_create error:error_code="</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    pthread_exit( <span class="literal">NULL</span> ); <span class="comment">//等待各个线程退出后，进程才结束，否则进程强制结束，线程处于未终止的状态 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">jack@jack:~/coding/muti_thread$ ./pthread_chap2 </span><br><span class="line">hello <span class="keyword">in</span> main..  </span><br><span class="line">Current pthread id = 3078458224  </span><br><span class="line">Current pthread id = 3070065520  </span><br><span class="line">hello <span class="keyword">in</span> hello <span class="keyword">in</span> 2  </span><br><span class="line">1  </span><br><span class="line">Current pthread id = hello <span class="keyword">in</span> 2  </span><br><span class="line">3061672816  </span><br><span class="line">Current pthread id = 3053280112  </span><br><span class="line">hello <span class="keyword">in</span> 4  </span><br><span class="line">Current pthread id = hello <span class="keyword">in</span> 4  </span><br><span class="line">3044887408</span><br></pre></td></tr></table></figure><p>显然不是想要的结果，调用顺序很乱，这是为什么呢？<br>这是因为多线程到缘故，主进程还没开始对i赋值，线程已经开始跑了…?<br>修改代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; //多线程相关操作头文件，可移植众多平台  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_THREADS 5 <span class="comment">//线程数  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">say_hello</span><span class="params">( <span class="keyword">void</span>* args )</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"hello in thread "</span> &lt;&lt; *( (<span class="keyword">int</span> *)args ) &lt;&lt;  <span class="built_in">endl</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125; <span class="comment">//函数返回的是函数指针，便于后面作为参数  </span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">pthread_t</span> tids[NUM_THREADS]; <span class="comment">//线程id  </span></span><br><span class="line">    <span class="keyword">int</span> indexes[NUM_THREADS]; <span class="comment">//用来保存i的值避免被修改  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; ++i )  </span><br><span class="line">    &#123;  </span><br><span class="line">        indexes[i] = i;  </span><br><span class="line">        <span class="keyword">int</span> ret = pthread_create( &amp;tids[i], <span class="literal">NULL</span>, say_hello, (<span class="keyword">void</span>*)&amp;(indexes[i]) );  </span><br><span class="line">        <span class="keyword">if</span>( ret != <span class="number">0</span> ) <span class="comment">//创建线程成功返回0  </span></span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"pthread_create error:error_code="</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; ++i )  </span><br><span class="line">        pthread_join( tids[i], <span class="literal">NULL</span> ); <span class="comment">//pthread_join用来等待一个线程的结束，是一个线程阻塞的函数 </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jack@jack:~/coding/muti_thread$ ./pthread_chap3 </span><br><span class="line">hello <span class="keyword">in</span> thread hello <span class="keyword">in</span> thread hello <span class="keyword">in</span> thread hello <span class="keyword">in</span> thread hello <span class="keyword">in</span> thread 30124</span><br></pre></td></tr></table></figure><p>这是正常的吗？感觉还是有问题…待续</p><p>代码中如果没有pthread_join主线程会很快结束从而使整个进程结束，从而使创建的线程没有机会开始执行就结束了。加入pthread_join后，主线程会一直等待直到等待的线程结束自己才结束，使创建的线程有机会执行。</p><h2 id="线程创建时属性参数的设置pthread-attr-t及join功能的使用"><a href="#线程创建时属性参数的设置pthread-attr-t及join功能的使用" class="headerlink" title="线程创建时属性参数的设置pthread_attr_t及join功能的使用"></a>线程创建时属性参数的设置pthread_attr_t及join功能的使用</h2><p>线程的属性由结构体pthread_attr_t进行管理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>                           detachstate;     线程的分离状态</span><br><span class="line">    <span class="keyword">int</span>                          schedpolicy;   线程调度策略</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span>      <span class="title">schedparam</span>;</span>   线程的调度参数</span><br><span class="line">    <span class="keyword">int</span> inheritsched; 线程的继承性 </span><br><span class="line">    <span class="keyword">int</span> scope; 线程的作用域 </span><br><span class="line">    <span class="keyword">size_t</span> guardsize; 线程栈末尾的警戒缓冲区大小 </span><br><span class="line">    <span class="keyword">int</span> stackaddr_set; <span class="keyword">void</span> * stackaddr; 线程栈的位置 </span><br><span class="line">    <span class="keyword">size_t</span> stacksize; 线程栈的大小</span><br><span class="line">&#125;<span class="keyword">pthread_attr_t</span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_THREADS 5  </span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">say_hello</span><span class="params">( <span class="keyword">void</span>* args )</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"hello in thread "</span> &lt;&lt; *(( <span class="keyword">int</span> * )args) &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">    <span class="keyword">int</span> status = <span class="number">10</span> + *(( <span class="keyword">int</span> * )args); <span class="comment">//线程退出时添加退出的信息，status供主程序提取该线程的结束信息  </span></span><br><span class="line">    pthread_exit( ( <span class="keyword">void</span>* )status ); </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">pthread_t</span> tids[NUM_THREADS];  </span><br><span class="line">    <span class="keyword">int</span> indexes[NUM_THREADS];  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">pthread_attr_t</span> attr; <span class="comment">//线程属性结构体，创建线程时加入的参数  </span></span><br><span class="line">    pthread_attr_init( &amp;attr ); <span class="comment">//初始化  </span></span><br><span class="line">    pthread_attr_setdetachstate( &amp;attr, PTHREAD_CREATE_JOINABLE ); <span class="comment">//是设置你想要指定线程属性参数，这个参数表明这个线程是可以join连接的，join功能表示主程序可以等线程结束后再去做某事，实现了主程序和线程同步功能  </span></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; ++i )  </span><br><span class="line">    &#123;  </span><br><span class="line">        indexes[i] = i;  </span><br><span class="line">        <span class="keyword">int</span> ret = pthread_create( &amp;tids[i], &amp;attr, say_hello, ( <span class="keyword">void</span>* )&amp;( indexes[i] ) );  </span><br><span class="line">        <span class="keyword">if</span>( ret != <span class="number">0</span> )  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"pthread_create error:error_code="</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;   </span><br><span class="line">    pthread_attr_destroy( &amp;attr ); <span class="comment">//释放内存   </span></span><br><span class="line">    <span class="keyword">void</span> *status;  </span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; ++i )  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">int</span> ret = pthread_join( tids[i], &amp;status ); <span class="comment">//主程序join每个线程后取得每个线程的退出信息status  </span></span><br><span class="line">        <span class="keyword">if</span>( ret != <span class="number">0</span> )  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"pthread_join error:error_code="</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"pthread_join get status:"</span> &lt;&lt; (<span class="keyword">long</span>)status &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">jack@jack:~/coding/muti_thread$ ./pthread_chap4  </span><br><span class="line">hello in thread hello in thread hello in thread hello in thread <span class="number">0</span>hello in thread <span class="number">321</span>  </span><br><span class="line">  </span><br><span class="line"><span class="number">4</span>  </span><br><span class="line">pthread_join get status:<span class="number">10</span>  </span><br><span class="line">pthread_join get status:<span class="number">11</span>  </span><br><span class="line">pthread_join get status:<span class="number">12</span>  </span><br><span class="line">pthread_join get status:<span class="number">13</span>  </span><br><span class="line">pthread_join get status:<span class="number">14</span></span><br></pre></td></tr></table></figure><h2 id="互斥锁的实现"><a href="#互斥锁的实现" class="headerlink" title="互斥锁的实现"></a>互斥锁的实现</h2><p>互斥锁是实现线程同步的一种机制，只要在临界区前后对资源加锁就能阻塞其他进程的访问。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_THREADS 5  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>; <span class="comment">//定义全局变量，让所有线程同时写，这样就需要锁机制  </span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> sum_mutex; <span class="comment">//互斥锁  </span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">say_hello</span><span class="params">( <span class="keyword">void</span>* args )</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"hello in thread "</span> &lt;&lt; *(( <span class="keyword">int</span> * )args) &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">    pthread_mutex_lock( &amp;sum_mutex ); <span class="comment">//先加锁，再修改sum的值，锁被占用就阻塞，直到拿到锁再修改sum;  </span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"before sum is "</span> &lt;&lt; sum &lt;&lt; <span class="string">" in thread "</span> &lt;&lt; *( ( <span class="keyword">int</span>* )args ) &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">    sum += *( ( <span class="keyword">int</span>* )args );  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"after sum is "</span> &lt;&lt; sum &lt;&lt; <span class="string">" in thread "</span> &lt;&lt; *( ( <span class="keyword">int</span>* )args ) &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">    pthread_mutex_unlock( &amp;sum_mutex ); <span class="comment">//释放锁，供其他线程使用  </span></span><br><span class="line">    pthread_exit( <span class="number">0</span> ); </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">pthread_t</span> tids[NUM_THREADS];  </span><br><span class="line">    <span class="keyword">int</span> indexes[NUM_THREADS];  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">pthread_attr_t</span> attr; <span class="comment">//线程属性结构体，创建线程时加入的参数  </span></span><br><span class="line">    pthread_attr_init( &amp;attr ); <span class="comment">//初始化  </span></span><br><span class="line">    pthread_attr_setdetachstate( &amp;attr, PTHREAD_CREATE_JOINABLE ); <span class="comment">//是设置你想要指定线程属性参数，这个参数表明这个线程是可以join连接的，join功能表示主程序可以等线程结束后再去做某事，实现了主程序和线程同步功能  </span></span><br><span class="line">    pthread_mutex_init( &amp;sum_mutex, <span class="literal">NULL</span> ); <span class="comment">//对锁进行初始化      </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; ++i )  </span><br><span class="line">    &#123;  </span><br><span class="line">        indexes[i] = i;  </span><br><span class="line">        <span class="keyword">int</span> ret = pthread_create( &amp;tids[i], &amp;attr, say_hello, ( <span class="keyword">void</span>* )&amp;( indexes[i] ) ); <span class="comment">//5个进程同时去修改sum  </span></span><br><span class="line">        <span class="keyword">if</span>( ret != <span class="number">0</span> )  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"pthread_create error:error_code="</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;   </span><br><span class="line">    pthread_attr_destroy( &amp;attr ); <span class="comment">//释放内存   </span></span><br><span class="line">    <span class="keyword">void</span> *status;  </span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; ++i )  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">int</span> ret = pthread_join( tids[i], &amp;status ); <span class="comment">//主程序join每个线程后取得每个线程的退出信息status  </span></span><br><span class="line">        <span class="keyword">if</span>( ret != <span class="number">0</span> )  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"pthread_join error:error_code="</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"finally sum is "</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">    pthread_mutex_destroy( &amp;sum_mutex ); <span class="comment">//注销锁  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">jack@jack:~/coding/muti_thread$ ./pthread_chap5 </span><br><span class="line">hello in thread hello in thread hello in thread <span class="number">410</span>  </span><br><span class="line">before sum is hello in thread <span class="number">0</span> in thread <span class="number">4</span>  </span><br><span class="line">after sum is <span class="number">4</span> in thread <span class="number">4</span>hello in thread   </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="number">2</span>  </span><br><span class="line"><span class="number">3</span>  </span><br><span class="line">before sum is <span class="number">4</span> in thread <span class="number">1</span>  </span><br><span class="line">after sum is <span class="number">5</span> in thread <span class="number">1</span>  </span><br><span class="line">before sum is <span class="number">5</span> in thread <span class="number">0</span>  </span><br><span class="line">after sum is <span class="number">5</span> in thread <span class="number">0</span>  </span><br><span class="line">before sum is <span class="number">5</span> in thread <span class="number">2</span>  </span><br><span class="line">after sum is <span class="number">7</span> in thread <span class="number">2</span>  </span><br><span class="line">before sum is <span class="number">7</span> in thread <span class="number">3</span>  </span><br><span class="line">after sum is <span class="number">10</span> in thread <span class="number">3</span>  </span><br><span class="line">finally sum is <span class="number">10</span></span><br></pre></td></tr></table></figure><p>可知，sum的访问和修改顺序是正常的，这就达到了多线程的目的了，但是线程的运行顺序是混乱的，混乱就是正常？</p><h2 id="信号量的实现"><a href="#信号量的实现" class="headerlink" title="信号量的实现"></a>信号量的实现</h2><p>信号量是线程同步的另一种实现机制，信号量的操作有signal和wait，本例子采用条件信号变量pthread_cond_t tasks_cond;<br>信号量的实现也要给予锁机制。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOUNDARY 5  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span> tasks = <span class="number">10</span>;  </span><br><span class="line"><span class="keyword">pthread_mutex_t</span> tasks_mutex; <span class="comment">//互斥锁  </span></span><br><span class="line"><span class="keyword">pthread_cond_t</span> tasks_cond; <span class="comment">//条件信号变量，处理两个线程间的条件关系，当task&gt;5，hello2处理，反之hello1处理，直到task减为0  </span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">say_hello2</span><span class="params">( <span class="keyword">void</span>* args )</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">pthread_t</span> pid = pthread_self(); <span class="comment">//获取当前线程id  </span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"["</span> &lt;&lt; pid &lt;&lt; <span class="string">"] hello in thread "</span> &lt;&lt;  *( ( <span class="keyword">int</span>* )args ) &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">bool</span> is_signaled = <span class="literal">false</span>; <span class="comment">//sign  </span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">    pthread_mutex_lock( &amp;tasks_mutex ); <span class="comment">//加锁  </span></span><br><span class="line">    <span class="keyword">if</span>( tasks &gt; BOUNDARY )  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"["</span> &lt;&lt; pid &lt;&lt; <span class="string">"] take task: "</span> &lt;&lt; tasks &lt;&lt; <span class="string">" in thread "</span> &lt;&lt; *( (<span class="keyword">int</span>*)args ) &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">        --tasks; <span class="comment">//modify  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( !is_signaled )  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"["</span> &lt;&lt; pid &lt;&lt; <span class="string">"] pthread_cond_signal in thread "</span> &lt;&lt; *( ( <span class="keyword">int</span>* )args ) &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">        pthread_cond_signal( &amp;tasks_cond ); <span class="comment">//signal:向hello1发送信号，表明已经&gt;5  </span></span><br><span class="line">        is_signaled = <span class="literal">true</span>; <span class="comment">//表明信号已发送，退出此线程  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    pthread_mutex_unlock( &amp;tasks_mutex ); <span class="comment">//解锁  </span></span><br><span class="line">    <span class="keyword">if</span>( tasks == <span class="number">0</span> )  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line">    &#125;      </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">say_hello1</span><span class="params">( <span class="keyword">void</span>* args )</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">pthread_t</span> pid = pthread_self(); <span class="comment">//获取当前线程id  </span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"["</span> &lt;&lt; pid &lt;&lt; <span class="string">"] hello in thread "</span> &lt;&lt;  *( ( <span class="keyword">int</span>* )args ) &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        pthread_mutex_lock( &amp;tasks_mutex ); <span class="comment">//加锁  </span></span><br><span class="line">        <span class="keyword">if</span>( tasks &gt; BOUNDARY )  </span><br><span class="line">        &#123;  </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"["</span> &lt;&lt; pid &lt;&lt; <span class="string">"] pthread_cond_signal in thread "</span> &lt;&lt; *( ( <span class="keyword">int</span>* )args ) &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">        pthread_cond_wait( &amp;tasks_cond, &amp;tasks_mutex ); <span class="comment">//wait:等待信号量生效，接收到信号，向hello2发出信号，跳出wait,执行后续   </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"["</span> &lt;&lt; pid &lt;&lt; <span class="string">"] take task: "</span> &lt;&lt; tasks &lt;&lt; <span class="string">" in thread "</span> &lt;&lt; *( (<span class="keyword">int</span>*)args ) &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">            --tasks;  </span><br><span class="line">    &#125;  </span><br><span class="line">        pthread_mutex_unlock( &amp;tasks_mutex ); <span class="comment">//解锁  </span></span><br><span class="line">        <span class="keyword">if</span>( tasks == <span class="number">0</span> )  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">pthread_attr_t</span> attr; <span class="comment">//线程属性结构体，创建线程时加入的参数  </span></span><br><span class="line">    pthread_attr_init( &amp;attr ); <span class="comment">//初始化  </span></span><br><span class="line">    pthread_attr_setdetachstate( &amp;attr, PTHREAD_CREATE_JOINABLE ); <span class="comment">//是设置你想要指定线程属性参数，这个参数表明这个线程是可以join连接的，join功能表示主程序可以等线程结束后再去做某事，实现了主程序和线程同步功能  </span></span><br><span class="line">    pthread_cond_init( &amp;tasks_cond, <span class="literal">NULL</span> ); <span class="comment">//初始化条件信号量  </span></span><br><span class="line">    pthread_mutex_init( &amp;tasks_mutex, <span class="literal">NULL</span> ); <span class="comment">//初始化互斥量  </span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid1, tid2; <span class="comment">//保存两个线程id  </span></span><br><span class="line">    <span class="keyword">int</span> index1 = <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">int</span> ret = pthread_create( &amp;tid1, &amp;attr, say_hello1, ( <span class="keyword">void</span>* )&amp;index1 );  </span><br><span class="line">    <span class="keyword">if</span>( ret != <span class="number">0</span> )  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"pthread_create error:error_code="</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">int</span> index2 = <span class="number">2</span>;  </span><br><span class="line">    ret = pthread_create( &amp;tid2, &amp;attr, say_hello2, ( <span class="keyword">void</span>* )&amp;index2 );  </span><br><span class="line">    <span class="keyword">if</span>( ret != <span class="number">0</span> )  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"pthread_create error:error_code="</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    pthread_join( tid1, <span class="literal">NULL</span> ); <span class="comment">//连接两个线程  </span></span><br><span class="line">    pthread_join( tid2, <span class="literal">NULL</span> );   </span><br><span class="line">  </span><br><span class="line">    pthread_attr_destroy( &amp;attr ); <span class="comment">//释放内存   </span></span><br><span class="line">    pthread_mutex_destroy( &amp;tasks_mutex ); <span class="comment">//注销锁  </span></span><br><span class="line">    pthread_cond_destroy( &amp;tasks_cond ); <span class="comment">//正常退出  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：<br>先在线程2中执行say_hello2，再跳转到线程1中执行say_hello1，直到tasks减到0为止。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">jack@jack:~/coding/muti_thread$ ./pthread_chap6  </span><br><span class="line">[3069823856] hello <span class="keyword">in</span> thread 2  </span><br><span class="line">[3078216560] hello <span class="keyword">in</span> thread 1[3069823856] take task: 10 <span class="keyword">in</span> thread 2  </span><br><span class="line">  </span><br><span class="line">[3069823856] take task: 9 <span class="keyword">in</span> thread 2  </span><br><span class="line">[3069823856] take task: 8 <span class="keyword">in</span> thread 2  </span><br><span class="line">[3069823856] take task: 7 <span class="keyword">in</span> thread 2  </span><br><span class="line">[3069823856] take task: 6 <span class="keyword">in</span> thread 2  </span><br><span class="line">[3069823856] pthread_cond_signal <span class="keyword">in</span> thread 2  </span><br><span class="line">[3078216560] take task: 5 <span class="keyword">in</span> thread 1  </span><br><span class="line">[3078216560] take task: 4 <span class="keyword">in</span> thread 1  </span><br><span class="line">[3078216560] take task: 3 <span class="keyword">in</span> thread 1  </span><br><span class="line">[3078216560] take task: 2 <span class="keyword">in</span> thread 1  </span><br><span class="line">[3078216560] take task: 1 <span class="keyword">in</span> thread 1</span><br></pre></td></tr></table></figure><p>到此，对多线程编程有了一个初步的了解，当然还有其他实现线程同步的机制，有待进一步探索。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;最基础，进程同时创建5个线程，各自调用同一个函数&quot;&gt;&lt;a href=&quot;#最基础，进程同时创建5个线程，各自调用同一个函数&quot; class=&quot;headerlink&quot; title=&quot;最基础，进程同时创建5个线程，各自调用同一个函数&quot;&gt;&lt;/a&gt;最基础，进程同时创建5个线程
      
    
    </summary>
    
      <category term="Cpp" scheme="https://loopvoid.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://loopvoid.github.io/tags/Cpp/"/>
    
      <category term="Pthread" scheme="https://loopvoid.github.io/tags/Pthread/"/>
    
  </entry>
  
  <entry>
    <title>Opencv基于特征点的图像对齐</title>
    <link href="https://loopvoid.github.io/2018/03/12/Opencv%E5%9F%BA%E4%BA%8E%E7%89%B9%E5%BE%81%E7%82%B9%E7%9A%84%E5%9B%BE%E5%83%8F%E5%AF%B9%E9%BD%90/"/>
    <id>https://loopvoid.github.io/2018/03/12/Opencv基于特征点的图像对齐/</id>
    <published>2018-03-12T10:22:33.000Z</published>
    <updated>2019-08-06T06:43:34.420Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二维图像之间的单应变换"><a href="#二维图像之间的单应变换" class="headerlink" title="二维图像之间的单应变换"></a>二维图像之间的单应变换</h1><p>图像中的2D点(x,y)(x,y)可以被表示成3D向量的形式$(x_1,x_2,x_3)$，其中$x=\frac{x_1}{x_3}$，$y=\frac{x_2}{x_3}$。它被叫做点的齐次表达，位于投影平面$P^2$上。所谓单应就是发生在投影平面$P^2$上的点和线可逆的映射。其它叫法包括射影变换、投影变换和平面投影变换等。</p><p>单应变换矩阵是一个3*3的矩阵H。这个变换可以被任意乘上一个非零常数，而不改变变换本身。它虽然具有9个元素，但是具有8个自由度。这意味这它里面有8个未知参数待求。</p><p>典型地，可以通过图像之间的特征匹配来估计单应矩阵。</p><h2 id="单应和齐次坐标"><a href="#单应和齐次坐标" class="headerlink" title="单应和齐次坐标"></a>单应和齐次坐标</h2><p>一个单应矩阵是大小为3*3的矩阵$H = \begin{bmatrix} h_{11} &amp; h_{12} &amp; h_{13}\\ h_{21} &amp; h_{22} &amp; h_{23}\\ h_{31} &amp; h_{32} &amp; h_{33}\end{bmatrix}$，满足给定一个点 $P_1 = \left[ \begin{matrix}   x_1 \\   y_1 \\  w_1  \end{matrix} \right]$ ,矩阵H把点$P_1$变换成一个新的点$P_2 = \left[ \begin{matrix}   x_2 \\   y_2 \\  w_2  \end{matrix} \right] = \begin{bmatrix} h_{11} &amp; h_{12} &amp; h_{13}\\  h_{21} &amp; h_{22} &amp; h_{23}\\ h_{31} &amp; h_{32} &amp; h_{33}\end{bmatrix}\cdot  \left[ \begin{matrix}   x_1 \\   y_1 \\  w_1  \end{matrix} \right]$ 。由于他们都是齐次坐标，对应在图像上的两个点分别是$\left[ \begin{matrix}   \frac{x_1}{w_1}  \\  \frac{y_1}{w_1}\end{matrix} \right]$，$\left[ \begin{matrix}   \frac{x_2}{w_2}  \\  \frac{y_2}{w_2}\end{matrix} \right]$ 。</p><h2 id="单应的自由度"><a href="#单应的自由度" class="headerlink" title="单应的自由度"></a>单应的自由度</h2><p>如果给定一个单位$H={h_{ij}}$，给H的每个元素乘上a，得到的单应$aH$和$H$作用相同，因为新的单应无非把齐次点$P_1$变成了齐次点$aP_2$，$aP_2$和$P_2$在图像上对应的点是相同的。所以一个单应中只有8个自由度，一般令$h_{33}=1$来归一化。</p><h2 id="求解单应"><a href="#求解单应" class="headerlink" title="求解单应"></a>求解单应</h2><p>8个未知数需要8个方程来求解，之所以4对点能求解，因为他们一个点能提供两个方程。</p><p>假设图像上有两个点$(x_1,y_1)$，$(x_2,y_2)$，他们的齐次坐标为$\left[ \begin{matrix}   x_1 \\   y_1 \\  1  \end{matrix} \right]$，$\left[ \begin{matrix}   x_2 \\   y_2 \\  1  \end{matrix} \right]$。</p><p>带入上述的推导可以得到：</p><script type="math/tex; mode=display">x_2=x_1h_{11}+y_1h_{12}+h_{13}</script><script type="math/tex; mode=display">y_2=x_1h_{21}+y_1h_{22}+h_{23}</script><script type="math/tex; mode=display">1=x_1h_{31}+y_1h_{32}+h_{33}</script><p>一般令$h_{33}=1$来归一化，可得到：</p><script type="math/tex; mode=display">x_2=\frac{x_1h_{11}+y_1h_{12}+h_{13}}{x_1h_{31}+y_1h_{32}+1}</script><script type="math/tex; mode=display">y_2=\frac{x_1h_{21}+y_1h_{22}+h_{23}}{x_1h_{31}+y_1h_{32}+1}</script><p>把这两个式子重新组织一下，得到等价的矩阵形式：</p><script type="math/tex; mode=display">Au=v</script><script type="math/tex; mode=display">A = \left[ \begin{matrix}   x_1 \  y_1 \  1 \  0 \  0 \  0  \ -x_1x_2  \  -x_2y_1 \\ 0 \ 0 \ 0 \ x_1 \ y_1 \ 1 \ -x_1y_2 \ -y_1y_2  \end{matrix} \right]</script><script type="math/tex; mode=display">u=\left[ \begin{matrix}   h_{11} \  h_{12} \  h_{13} \  h_{21} \  h_{22} \  h_{23} \  h_{31} \  h_{32} \  h_{33}  \end{matrix} \right]^T</script><script type="math/tex; mode=display">v=\left[ \begin{matrix} x_2 \ y_2  \end{matrix} \right]^T</script><p>如果有四对不共线匹配点对，这个方程组就能够垒到8行，存在唯一解。</p><p>如果多于四对点，比如有n对点，方程就垒到2n行，用最小二乘法或SVD分解就可以求解$H$。</p><p>由于点对中可能存在不少错误匹配，一般使用RANSAC算法剔除错误匹配点对。</p><h1 id="Opencv中单应性矩阵H的计算"><a href="#Opencv中单应性矩阵H的计算" class="headerlink" title="Opencv中单应性矩阵H的计算"></a>Opencv中单应性矩阵H的计算</h1><p>如果在两幅对应的图像中已知4个映射点的坐标，就可以使用 <a href="https://docs.opencv.org/3.4.1/d9/d0c/group__calib3d.html#gafd3ef89257e27d5235f4467cbb1b6a63" target="_blank" rel="noopener">findHomography</a>函数如下：</p><p><strong>C++:  </strong> <code>Mat cv::findHomography(InputArray srcPoints,InputArray dstPoints,OutputArray mask,int method = 0,double ransacReprojThreshold = 3)</code><br><strong>Python:</strong> <code>retval,mask=cv.findHomography(srcPoints,dstPoints[,method[,ransacReprojThreshold[,mask[,maxIters[,confidence]]]]])</code></p><h1 id="自动寻找对应点-corresponding-points"><a href="#自动寻找对应点-corresponding-points" class="headerlink" title="自动寻找对应点(corresponding points)"></a>自动寻找对应点(corresponding points)</h1><p>由上文知道知道两对对应点(4个映射点)的坐标即可求得单应性矩阵H。</p><p>我们可以使用在OpenCV中的几个关键点检测器（例如SIFT，SURF和ORB）。</p><p>本文将采用ORB关键点检测器，SIFT和SURF已经注册专利。</p><p>一个特征点检测器由两个部分组成：</p><p><strong>定位器(Locator)：</strong>它可以识别图像上在平移（移位），缩放（缩小增大/缩小）和旋转等图像变换下稳定的点。 定位器查找这些点的x，y坐标。 ORB检测器使用的定位器叫做<a href="https://docs.opencv.org/3.0-beta/doc/py_tutorials/py_feature2d/py_fast/py_fast.html" target="_blank" rel="noopener">FAST</a>。<br><strong>描述符(Descriptor)：</strong>上述步骤中的定位器仅告诉我们特征点在哪里。 特征检测器的第二部分是对点的外观进行编码的描述符，以便我们可以从另幅图中指出同一个特征点。 在特征点处评定的描述符只是一个数字数组。 理想情况下，两幅图像中的相同物理点应具有相同的描述符。 ORB使用的是<a href="https://www.robots.ox.ac.uk/~vgg/rg/papers/brisk.pdf" target="_blank" rel="noopener">BRISK</a>特征描述符的修改版本。</p><h1 id="总结：图像对齐思路"><a href="#总结：图像对齐思路" class="headerlink" title="总结：图像对齐思路"></a>总结：图像对齐思路</h1><p>1、读取图像</p><p>2、特征点检测</p><p>3、匹配特征点</p><p>4、计算单应矩阵参数</p><p>5、矫正图像</p><h1 id="C-Code"><a href="#C-Code" class="headerlink" title="C++ Code"></a>C++ Code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/xfeatures2d.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/features2d.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv::xfeatures2d;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_FEATURES = <span class="number">500</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> GOOD_MATCH_PERCENT = <span class="number">0.15f</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">alignImages</span><span class="params">(Mat &amp;im1, Mat &amp;im2, Mat &amp;im1Reg, Mat &amp;h)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Convert images to grayscale</span></span><br><span class="line">  Mat im1Gray, im2Gray;</span><br><span class="line">  cvtColor(im1, im1Gray, CV_BGR2GRAY);</span><br><span class="line">  cvtColor(im2, im2Gray, CV_BGR2GRAY);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Variables to store keypoints and descriptors</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;KeyPoint&gt; keypoints1, keypoints2;</span><br><span class="line">  Mat descriptors1, descriptors2;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Detect ORB features and compute descriptors.</span></span><br><span class="line">  Ptr&lt;Feature2D&gt; orb = ORB::create(MAX_FEATURES);</span><br><span class="line">  orb-&gt;detectAndCompute(im1Gray, Mat(), keypoints1, descriptors1);</span><br><span class="line">  orb-&gt;detectAndCompute(im2Gray, Mat(), keypoints2, descriptors2);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Match features.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;DMatch&gt; matches;</span><br><span class="line">  Ptr&lt;DescriptorMatcher&gt; matcher = DescriptorMatcher::create(<span class="string">"BruteForce-Hamming"</span>);</span><br><span class="line">  matcher-&gt;match(descriptors1, descriptors2, matches, Mat());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Sort matches by score</span></span><br><span class="line">  <span class="built_in">std</span>::sort(matches.begin(), matches.end());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Remove not so good matches</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> numGoodMatches = matches.size() * GOOD_MATCH_PERCENT;</span><br><span class="line">  matches.erase(matches.begin()+numGoodMatches, matches.end());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Draw top matches</span></span><br><span class="line">  Mat imMatches;</span><br><span class="line">  drawMatches(im1, keypoints1, im2, keypoints2, matches, imMatches);</span><br><span class="line">  imwrite(<span class="string">"matches.jpg"</span>, imMatches);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Extract location of good matches</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Point2f&gt; points1, points2;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>( <span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; matches.size(); i++ )</span><br><span class="line">  &#123;</span><br><span class="line">    points1.push_back( keypoints1[ matches[i].queryIdx ].pt );</span><br><span class="line">    points2.push_back( keypoints2[ matches[i].trainIdx ].pt );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Find homography</span></span><br><span class="line">  h = findHomography( points1, points2, RANSAC );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Use homography to warp image</span></span><br><span class="line">  warpPerspective(im1, im1Reg, h, im2.size());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// Read reference image</span></span><br><span class="line">  <span class="function"><span class="built_in">string</span> <span class="title">refFilename</span><span class="params">(<span class="string">"form.jpg"</span>)</span></span>; </span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"Reading reference image : "</span> &lt;&lt; refFilename &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">  Mat imReference = imread(refFilename);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Read image to be aligned</span></span><br><span class="line">  <span class="function"><span class="built_in">string</span> <span class="title">imFilename</span><span class="params">(<span class="string">"scanned-form.jpg"</span>)</span></span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"Reading image to align : "</span> &lt;&lt; imFilename &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">  Mat im = imread(imFilename);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Registered image will be resotred in imReg. </span></span><br><span class="line">  <span class="comment">// The estimated homography will be stored in h. </span></span><br><span class="line">  Mat imReg, h;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Align images</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"Aligning images ..."</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">  alignImages(im, imReference, imReg, h);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Write aligned image to disk. </span></span><br><span class="line">  <span class="function"><span class="built_in">string</span> <span class="title">outFilename</span><span class="params">(<span class="string">"aligned.jpg"</span>)</span></span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"Saving aligned image : "</span> &lt;&lt; outFilename &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">  imwrite(outFilename, imReg);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Print estimated homography</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"Estimated homography : \n"</span> &lt;&lt; h &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;二维图像之间的单应变换&quot;&gt;&lt;a href=&quot;#二维图像之间的单应变换&quot; class=&quot;headerlink&quot; title=&quot;二维图像之间的单应变换&quot;&gt;&lt;/a&gt;二维图像之间的单应变换&lt;/h1&gt;&lt;p&gt;图像中的2D点(x,y)(x,y)可以被表示成3D向量的形式$(x_
      
    
    </summary>
    
      <category term="Opencv" scheme="https://loopvoid.github.io/categories/Opencv/"/>
    
    
      <category term="Opencv" scheme="https://loopvoid.github.io/tags/Opencv/"/>
    
  </entry>
  
  <entry>
    <title>查找算法</title>
    <link href="https://loopvoid.github.io/2018/03/09/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
    <id>https://loopvoid.github.io/2018/03/09/查找算法/</id>
    <published>2018-03-09T13:57:31.000Z</published>
    <updated>2019-08-06T05:45:31.597Z</updated>
    
    <content type="html"><![CDATA[<h1 id="顺序查找-Sequential-Search"><a href="#顺序查找-Sequential-Search" class="headerlink" title="顺序查找(Sequential Search)"></a>顺序查找(Sequential Search)</h1><p><strong>说明：顺序查找适合于存储结构为顺序存储或链接存储的线性表</strong></p><p><strong>复杂度：O(n)</strong></p><p><strong>基本思想：</strong>顺序查找也称线性查找(Liner Search)，属于无序查找算法。</p><p>从数据结构线性表的一端开始，顺序扫描，依次比较扫描到的结点，若相等则表示查找成功；</p><p>若扫描结束仍没有找到目标，则查找失败；</p><p>查找失败则需要进行n+1次比较，则时间复杂度为 <strong>O(n)</strong></p><h2 id="C-实现"><a href="#C-实现" class="headerlink" title="C++实现"></a>C++实现</h2><ul><li><p>Code Example 1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> V&gt; <span class="function"><span class="keyword">int</span> <span class="title">sequential_search</span><span class="params">(<span class="keyword">const</span> T *arr, V key, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (key == arr[i])</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr1[] = &#123; <span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">13</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> len1 = (<span class="keyword">int</span>)<span class="keyword">sizeof</span>(arr1) / <span class="keyword">sizeof</span>(*arr1);</span><br><span class="line"><span class="keyword">int</span> key1 = <span class="number">8</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Index: "</span> &lt;&lt; sequential_search(arr1, key1, len1) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> arr2[] = &#123; <span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>,<span class="string">'f'</span>,<span class="string">'g'</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> len2 = (<span class="keyword">int</span>)<span class="keyword">sizeof</span>(arr2) / <span class="keyword">sizeof</span>(*arr2);</span><br><span class="line"><span class="keyword">char</span> key2 = <span class="string">'e'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Index: "</span> &lt;&lt; sequential_search(arr2, key2, len2) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Code Example 2</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">13</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> key = <span class="number">13</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> elem : arr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (key == elem)</span><br><span class="line">&#123;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"not fund !"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="二分查找-Binary-Search"><a href="#二分查找-Binary-Search" class="headerlink" title="二分查找(Binary Search)"></a>二分查找(Binary Search)</h1><p><strong>说明：元素必须是有序的，若无序则需先排序</strong></p><p><strong>复杂度：O(log2n)</strong></p><p><strong>基本思想：</strong>将n个元素分成大致相等的两部分，取a[n/2]与x做比较，如果x=a[n/2],则找到x,算法中止；</p><p>如果x&lt;a[n/2],则只要在数组a的左半部分继续搜索x</p><p>如果x&gt;a[n/2],则只要在数组a的右半部搜索x.</p><p>时间复杂度无非就是while循环的次数,总共有n个元素，</p><p>渐渐跟下去就是n,n/2,n/4,….n/2^k（接下来操作元素的剩余个数），其中k就是循环的次数</p><p>由于你n/2^k取整后&gt;=1，即令n/2^k=1</p><p>可得k=log2n,（是以2为底，n的对数）</p><p>所以时间复杂度可以表示O(h)=O(log2n)</p><h2 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++实现"></a>C++实现</h2><ul><li>随机数生成</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line">srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;rand()&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">取得(<span class="number">0</span>,x)的随机整数：rand()%x；</span><br><span class="line">取得(a,b)的随机整数：rand()%(b-a)；</span><br><span class="line">取得[a,b)的随机整数：rand()%(b-a)+a；</span><br><span class="line">取得[a,b]的随机整数：rand()%(b-a+<span class="number">1</span>)+a；</span><br><span class="line">取得(a,b]的随机整数：rand()%(b-a)+a+<span class="number">1</span>；</span><br><span class="line">取得<span class="number">0</span><span class="number">-1</span>之间的浮点数：rand()/<span class="keyword">double</span>(RAND_MAX)</span><br></pre></td></tr></table></figure><ul><li>每次都从中间分，完成查找次数相对稳定</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br></pre></td></tr></table></figure><ul><li>每次的mid值由左右界限来生成随机值</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mid = rand() % (right - left + <span class="number">1</span>) + left;</span><br></pre></td></tr></table></figure><ul><li>Code</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> V&gt; <span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(V *arr,T key, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> right = len - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//int mid = (left + right) / 2;</span></span><br><span class="line"><span class="keyword">int</span> mid = rand() % (right - left + <span class="number">1</span>) + left;</span><br><span class="line"><span class="keyword">if</span> (arr[mid] == key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"real times to target:"</span> &lt;&lt; <span class="string">"\t\t"</span> &lt;&lt; count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(key &gt; arr[mid])</span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> key = <span class="string">'a'</span>+ <span class="number">29</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> len = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">char</span> arr[len];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">arr[i] = <span class="string">'a'</span> + i;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"expected times to target:"</span> &lt;&lt; <span class="string">"\t"</span> &lt;&lt; log2(len) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; binary_search(arr, key, len) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="插值查找-Interpolation-Search"><a href="#插值查找-Interpolation-Search" class="headerlink" title="插值查找(Interpolation Search)"></a>插值查找(Interpolation Search)</h1><p>在二分查找的基础上，二分查找是每次都分一办查找。但是我们查字典的时候并不会是一半一半的翻页。</p><p>比如查c开头的单词，我们会从字典的<strong>(c-a)/(z-a)</strong>部分打开。</p><p>这种折半的查找方式并不是每次折半<strong>1/2</strong>，因此我们将二分法的折<strong>1/2</strong>的方式优化为自适应的<strong>(c-a)/(z-a)</strong>的比例。</p><p>二分法：<strong>mid=(left+right )/2, 即mid=left+1/2*(right -left);</strong></p><p>插值法则是： <strong>mid = left+ (key - arr[left])/(arr[right] - key) * (right - left)</strong></p><p><strong>基本思想：基于二分法，改进查找点的自适应性，从而提高效率。插值查找也属于有序查找。</strong></p><p><strong>复杂度：查找成功/失败都是$O(log_2(log_2^n))$。</strong></p><p>注：<strong>对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多。反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择。</strong></p><h2 id="C-实现-2"><a href="#C-实现-2" class="headerlink" title="C++实现"></a>C++实现</h2><ul><li>Code<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> V&gt; <span class="keyword">size_t</span> interpolation_search(V *arr, T key, <span class="keyword">size_t</span> len, <span class="keyword">size_t</span> &amp;count)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> right = len - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((arr[left]!=arr[right]) &amp;&amp; (key&gt;arr[left]) &amp;&amp; (key&lt;arr[right]))</span><br><span class="line">&#123;</span><br><span class="line">count++;</span><br><span class="line">mid = left + (right - left) * (key - arr[left]) / (arr[right] - arr[left]);</span><br><span class="line"><span class="keyword">if</span> (key &gt; arr[mid])</span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (arr[mid] == key)</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> key = <span class="string">'a'</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> len = <span class="number">29</span>;</span><br><span class="line"><span class="keyword">size_t</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> arr[len];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">arr[i] = <span class="string">'a'</span> + i;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"expected times to target:\t"</span> &lt;&lt; log2(log2(len)) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"position: \t"</span> &lt;&lt; interpolation_search(arr, key, len, count) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"real times to target:\t"</span> &lt;&lt; count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>输出： </strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">expected <span class="built_in">times</span> to target:       2.28036</span><br><span class="line">position:       10</span><br><span class="line">real <span class="built_in">times</span> to target:   1</span><br></pre></td></tr></table></figure></p><h1 id="分块查找-Block-Search"><a href="#分块查找-Block-Search" class="headerlink" title="分块查找(Block Search)"></a>分块查找(Block Search)</h1><p><strong>分块有序：</strong>整个表中的元素未必有序，但若划分为若干块后，每一块中的所有元素均小于（或大于）其后面块中的所有元素。</p><p>分块查找又称<strong>索引顺序查找</strong>，它是顺序查找的一种改进方法。首先须要对数组进行分块，分块查找须要建立一个“索引表”。索引表分为m块，每块含有N/m个元素，块内是无序的，块间是有序的，比如块2中最大元素小于块3中最小元素。先用二分查找索引表。确定须要查找的keyword在哪一块，然后再在对应的块内用顺序查找。</p><p><strong>操作步骤：</strong></p><p>　　step1 先选取各块中的最大关键字构成一个索引表；</p><p>　　step2 查找分两个部分：先对索引表进行二分查找或顺序查找，以确定待查记录在哪一块中；然后，在已确定的块中用顺序法进行查找。</p><p><strong>时间复杂度：</strong>O(log(m)+N/m)</p><h2 id="C-实现-Block-search"><a href="#C-实现-Block-search" class="headerlink" title="C++实现(Block search)"></a>C++实现(Block search)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//索引表--结构体模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">struct</span> <span class="title">Index_table</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">T key;</span><br><span class="line"><span class="keyword">int</span> link;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index_able为索引表,x为原数组,N为数组大小，m为块大小, keyword为查找目标</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;  <span class="function"><span class="keyword">int</span> <span class="title">index_order_search</span><span class="params">(Index_table&lt;T&gt; *index_able, T *x, <span class="keyword">int</span> N, <span class="keyword">int</span> m, T keyword)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> L = (N + m - <span class="number">1</span>) / m;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; L &amp;&amp; index_able[i].key &lt; keyword)</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">if</span> (i == L)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = index_able[i].link; j &lt; index_able[i].link + m; j++)</span><br><span class="line"><span class="keyword">if</span> (x[j] == keyword)</span><br><span class="line"><span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//block1(22,0)    |block2(48,6)      |block3(86,12)</span></span><br><span class="line"><span class="comment">//22,12,13,8,9,20,|33,42,44,38,24,48,|60,58,74,49,86,53</span></span><br><span class="line"><span class="comment">//0 ,1 ,2 ,3,4,5 ,|6 ,7 ,8 ,9 ,10,11,|12,13,14,15,16,17</span></span><br><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">22</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="number">33</span>,<span class="number">42</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">24</span>,<span class="number">48</span>,<span class="number">60</span>,<span class="number">58</span>,<span class="number">74</span>,<span class="number">49</span>,<span class="number">86</span>,<span class="number">53</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> len = (<span class="keyword">unsigned</span>)<span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(*arr);</span><br><span class="line"><span class="keyword">int</span> block_size = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span> target = <span class="number">33</span>;</span><br><span class="line"></span><br><span class="line">Index_table&lt;<span class="keyword">int</span>&gt; index_table[<span class="number">3</span>];</span><br><span class="line">index_table[<span class="number">0</span>].key = <span class="number">22</span>;</span><br><span class="line">index_table[<span class="number">0</span>].link = <span class="number">0</span>;</span><br><span class="line">index_table[<span class="number">1</span>].key = <span class="number">48</span>;</span><br><span class="line">index_table[<span class="number">1</span>].link = <span class="number">6</span>; </span><br><span class="line">index_table[<span class="number">2</span>].key = <span class="number">86</span>;</span><br><span class="line">index_table[<span class="number">2</span>].link = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; index_order_search(index_table, arr, len, block_size, target) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;顺序查找-Sequential-Search&quot;&gt;&lt;a href=&quot;#顺序查找-Sequential-Search&quot; class=&quot;headerlink&quot; title=&quot;顺序查找(Sequential Search)&quot;&gt;&lt;/a&gt;顺序查找(Sequential Sea
      
    
    </summary>
    
      <category term="Algorithm" scheme="https://loopvoid.github.io/categories/Algorithm/"/>
    
    
      <category term="Cpp" scheme="https://loopvoid.github.io/tags/Cpp/"/>
    
      <category term="Algorithm" scheme="https://loopvoid.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Google C++ Style Guide</title>
    <link href="https://loopvoid.github.io/2018/03/06/Google-C-Style-Guide/"/>
    <id>https://loopvoid.github.io/2018/03/06/Google-C-Style-Guide/</id>
    <published>2018-03-06T04:46:33.000Z</published>
    <updated>2019-08-06T06:53:45.511Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Google-C-Style-Guide"><a href="#Google-C-Style-Guide" class="headerlink" title="Google C++ Style Guide"></a>Google C++ Style Guide</h1><p><img src="//loopvoid.github.io/2018/03/06/Google-C-Style-Guide/Google C++ Style Guide.jpg" alt="KalmanModelImg"></p><p><a href="http://blog.csdn.net/voidccc/article/details/37599203" target="_blank" rel="noopener">Reference</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Google-C-Style-Guide&quot;&gt;&lt;a href=&quot;#Google-C-Style-Guide&quot; class=&quot;headerlink&quot; title=&quot;Google C++ Style Guide&quot;&gt;&lt;/a&gt;Google C++ Style Guide&lt;/
      
    
    </summary>
    
      <category term="Cpp" scheme="https://loopvoid.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://loopvoid.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>Mat和IplImage转换</title>
    <link href="https://loopvoid.github.io/2018/01/29/Mat%E5%92%8CIplImage%E8%BD%AC%E6%8D%A2/"/>
    <id>https://loopvoid.github.io/2018/01/29/Mat和IplImage转换/</id>
    <published>2018-01-29T07:14:09.000Z</published>
    <updated>2019-09-26T14:40:38.238Z</updated>
    
    <content type="html"><![CDATA[<p>Mat 是OpenCV和C++的接口矩阵类，ImlImage是OpenCV和C语言的接口的结构体，但是C++程序有时候时候还是要用到ImlImage。</p><p><strong>浅拷贝是不需要释放内存的。</strong></p><p><strong>深拷贝才需要释放内存。</strong></p><h1 id="IplImage-转-Mat"><a href="#IplImage-转-Mat" class="headerlink" title="IplImage 转 Mat"></a>IplImage 转 Mat</h1><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>直接使用cvarrToMat函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IplImage* src = cvLoadImage(<span class="string">"./res/tmp.jpg"</span>);  </span><br><span class="line">Mat img;  </span><br><span class="line">img = cvarrToMat(src);</span><br></pre></td></tr></table></figure><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>需要在Mat里创建一个新的Mat对象，然后进行数据的复制，再用上述的函数进行数据头的复制（即浅拷贝）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IplImage* src = cvLoadImage(<span class="string">"c://tmp.jpg"</span>);  </span><br><span class="line">Mat img_tmp;  </span><br><span class="line">img_tmp = cvarrToMat(src);  </span><br><span class="line">Mat img = img_tmp.clone();</span><br></pre></td></tr></table></figure><h1 id="Mat-转-IplImage"><a href="#Mat-转-IplImage" class="headerlink" title="Mat 转 IplImage"></a>Mat 转 IplImage</h1><h2 id="浅拷贝-1"><a href="#浅拷贝-1" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mat img = imread(./res/tmp.jpg);</span><br><span class="line">IplImage *src = &amp;IplImage(img);</span><br></pre></td></tr></table></figure><h2 id="深拷贝-即再复制一次数据"><a href="#深拷贝-即再复制一次数据" class="headerlink" title="深拷贝(即再复制一次数据)"></a>深拷贝(即再复制一次数据)</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Mat img = imread(./res/tmp.jpg);</span><br><span class="line">IplImage *src_tmp = &amp;IplImage(img);</span><br><span class="line">IplImage *src = cvCloneImage(src_tmp);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Mat 是OpenCV和C++的接口矩阵类，ImlImage是OpenCV和C语言的接口的结构体，但是C++程序有时候时候还是要用到ImlImage。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;浅拷贝是不需要释放内存的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;深拷贝才需要释放
      
    
    </summary>
    
      <category term="Opencv" scheme="https://loopvoid.github.io/categories/Opencv/"/>
    
    
      <category term="Opencv" scheme="https://loopvoid.github.io/tags/Opencv/"/>
    
  </entry>
  
  <entry>
    <title>Opencv截取屏幕(BitBlt API)</title>
    <link href="https://loopvoid.github.io/2018/01/29/Opencv%E6%88%AA%E5%8F%96%E5%B1%8F%E5%B9%95-BitBlt-API/"/>
    <id>https://loopvoid.github.io/2018/01/29/Opencv截取屏幕-BitBlt-API/</id>
    <published>2018-01-29T07:05:53.000Z</published>
    <updated>2019-08-06T06:40:42.898Z</updated>
    
    <content type="html"><![CDATA[<h1 id="截取整个屏幕"><a href="#截取整个屏幕" class="headerlink" title="截取整个屏幕"></a>截取整个屏幕</h1><p>直接获取整个屏幕当前显示画面，便于后期计算处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _MSC_VER</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment( linker, <span class="meta-string">"/subsystem:\"windows\" /entry:\"mainCRTStartup\""</span> )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _AFXDLL<span class="comment">//为了方便是用mfc类  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;afxwin.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line">LPVOID  screenCaptureData = <span class="literal">NULL</span>;</span><br><span class="line">HBITMAP hBitmap;</span><br><span class="line">HDC hDDC;</span><br><span class="line">HDC hCDC;</span><br><span class="line"><span class="keyword">int</span> nWidth;</span><br><span class="line"><span class="keyword">int</span> nHeight;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initGDI</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">nWidth = GetSystemMetrics(SM_CXSCREEN);<span class="comment">//得到屏幕的分辨率的x  </span></span><br><span class="line">nHeight = GetSystemMetrics(SM_CYSCREEN);<span class="comment">//得到屏幕分辨率的y  </span></span><br><span class="line">screenCaptureData = <span class="keyword">new</span> <span class="keyword">char</span>[nWidth*nHeight * <span class="number">4</span>];</span><br><span class="line"><span class="built_in">memset</span>(screenCaptureData, <span class="number">0</span>, nWidth);</span><br><span class="line"><span class="comment">// Get desktop DC, create a compatible dc, create a comaptible bitmap and select into compatible dc.  </span></span><br><span class="line">hDDC = GetDC(GetDesktopWindow());<span class="comment">//得到屏幕的dc  </span></span><br><span class="line">hCDC = CreateCompatibleDC(hDDC);<span class="comment">//  </span></span><br><span class="line">hBitmap = CreateCompatibleBitmap(hDDC, nWidth, nHeight);<span class="comment">//得到位图  </span></span><br><span class="line">SelectObject(hCDC, hBitmap); <span class="comment">//好像总得这么写。  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gdiScreenCapture</span><span class="params">(LPVOID screenCaptureData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BitBlt(hCDC, <span class="number">0</span>, <span class="number">0</span>, nWidth, nHeight, hDDC, <span class="number">0</span>, <span class="number">0</span>, SRCCOPY);</span><br><span class="line">GetBitmapBits(hBitmap, nWidth*nHeight * <span class="number">4</span>, screenCaptureData);<span class="comment">//得到位图的数据，并存到screenCaptureData数组中。  </span></span><br><span class="line">IplImage *img_tmp = cvCreateImage(cvSize(nWidth, nHeight), <span class="number">8</span>, <span class="number">4</span>);<span class="comment">//创建一个rgba格式的IplImage,内容为空  </span></span><br><span class="line"><span class="built_in">memcpy</span>(img_tmp-&gt;imageData, screenCaptureData, nWidth*nHeight * <span class="number">4</span>);<span class="comment">//这样比较浪费时间，但写的方便,这里必须得是*4。  </span></span><br><span class="line">IplImage *img2_tmp = cvCreateImage(cvSize(nWidth, nHeight), <span class="number">8</span>, <span class="number">3</span>);<span class="comment">//创建一个bgr格式的IplImage，可以没有这个Img2这个变量。 </span></span><br><span class="line"></span><br><span class="line">cv::Mat img = cv::cvarrToMat(img_tmp);</span><br><span class="line">cv::Mat img2 = cv::cvarrToMat(img2_tmp);</span><br><span class="line"></span><br><span class="line">cvtColor(img, img2, CV_BGRA2BGR);</span><br><span class="line">imwrite(<span class="string">"rgba.jpg"</span>, img);</span><br><span class="line">cv::waitKey();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">initGDI();</span><br><span class="line">gdiScreenCapture(screenCaptureData);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;截取整个屏幕&quot;&gt;&lt;a href=&quot;#截取整个屏幕&quot; class=&quot;headerlink&quot; title=&quot;截取整个屏幕&quot;&gt;&lt;/a&gt;截取整个屏幕&lt;/h1&gt;&lt;p&gt;直接获取整个屏幕当前显示画面，便于后期计算处理。&lt;/p&gt;
&lt;figure class=&quot;highlight 
      
    
    </summary>
    
      <category term="Opencv" scheme="https://loopvoid.github.io/categories/Opencv/"/>
    
    
      <category term="Opencv" scheme="https://loopvoid.github.io/tags/Opencv/"/>
    
  </entry>
  
</feed>
