<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chuan·Yen</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://loopvoid.github.io/"/>
  <updated>2019-09-14T07:38:56.872Z</updated>
  <id>https://loopvoid.github.io/</id>
  
  <author>
    <name>Chuan Yen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>BP神经网络原理和简明理解</title>
    <link href="https://loopvoid.github.io/2019/09/14/BP%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86%E5%92%8C%E7%AE%80%E6%98%8E%E7%90%86%E8%A7%A3/"/>
    <id>https://loopvoid.github.io/2019/09/14/BP神经网络原理和简明理解/</id>
    <published>2019-09-14T02:48:09.000Z</published>
    <updated>2019-09-14T07:38:56.872Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单个神经元结构"><a href="#单个神经元结构" class="headerlink" title="单个神经元结构"></a>单个神经元结构</h1><p><img src="//loopvoid.github.io/2019/09/14/BP神经网络原理和简明理解/bp1.jpg" alt="bp1"></p><ul><li><p>输入：$x_1,x_2,…,x_n$</p></li><li><p>输出：$y$</p></li><li><p>输入和输出的关系(函数)：$y = (x_1\ast w_1+x_2\ast w_2+…+x_n\ast w_n+)+b = \sum_{i=1}^n x_i\ast w_i+b$，其中$w_i$是权重</p></li><li><p>将输入用矩阵表示：$X = [x_1,x_2,…,x_n]^T,X为一个n行1列的矩阵$</p></li><li><p>将权重用矩阵表示：$W=[w_1,x_2,…,w_n]$</p></li><li><p>那么输出可以表示为：$y=[w_1.w_2,…,w_n] \cdot [x_1,_2,…,x_n]^T+b=WX+b$</p></li></ul><h1 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h1><p>激活函数是一类复杂的问题，为便于理解这里有几条重要的特性：</p><ul><li><strong>非线性</strong>：即导数不是常数，不然求导之后退化为直线。对于一些画一条直线仍然无法分开的问题，非线性可以把直线掰弯，自从变弯以后，就能包罗万象了。</li><li><strong>几乎处处可导</strong>：数学上，处处可导为后面的后向传播算法（BP算法）提供了核心条件。</li><li><strong>输出范围有限</strong>：一般是限定在[0,1]，有限的输出范围使得神经元对于一些比较大的输入也会比较稳定。</li><li><strong>非饱和性</strong>：饱和就是指，当输入比较大的时候，输出几乎没变化了，那么会导致梯度消失！梯度消失带来的负面影响就是会限制了神经网络表达能力。<strong>sigmoid</strong>，<strong>tanh</strong>函数都是软饱和的，<strong>阶跃函数</strong>是硬饱和。<strong>软</strong>是指输入趋于无穷大的时候输出无限接近上线，<strong>硬</strong>是指像阶跃函数那样，输入非0输出就已经始终都是上限值。关于数学表示<strong><a href="https://www.cnblogs.com/rgvb178/p/6055213.html" target="_blank" rel="noopener">传送门</a></strong>里面有详细写到。如果激活函数是饱和的，带来的缺陷就是系统迭代更新变慢，系统收敛就慢，当然这是可以有办法弥补的，一种方法是使用交叉熵函数作为损失函数。<strong>ReLU</strong>是非饱和的，效果挺不错。</li><li><strong>单调性</strong>：即导数符号不变。导出要么一直大于0，要么一直小于0，不要上蹿下跳。导数符号不变，让神经网络训练容易收敛。</li></ul><p>这里用到<strong>Sigmoid</strong>函数方便理解：</p><p>Sigmoid函数：$$y = \frac{1}{e^{(-x)}+1}$$</p><p><img src="//loopvoid.github.io/2019/09/14/BP神经网络原理和简明理解/bp2.jpg" alt="bp2"></p><p>S函数的导数：</p><p>$$ y’= (\frac{1}{e^{-x}+1})’ \ =(\frac{u}{v})’,这里u=1,v=e^{-x}+1 \ =\frac{u’v-uv’}{v^2} \ =\frac{1’<em>(e^{-x}+1)-1</em>(e^{-x}+1)’}{(e^{-x}+1)^2} \ =\frac{e^{-x}}{(e^{-x}+1)^2} \ = \frac{1}{1+e^{-x}}<em>\frac{1+e^{-x}-1}{1+e^{-x}} \ = \frac{1}{1+e^{-x}}</em>(1-\frac{1}{1+e^{-x}}), 令y=\frac{1}{e^{-x}+1} \ =y*(1-y)$$</p><p>S函数的导数的图像：</p><p><img src="//loopvoid.github.io/2019/09/14/BP神经网络原理和简明理解/bp3.jpg" alt="bp3"></p><h1 id="传播过程"><a href="#传播过程" class="headerlink" title="传播过程"></a>传播过程</h1><p>下面是一个典型的三层神经网络结构，第一层是输入层，第二层是隐藏层，第三层是输出层。</p><p><img src="//loopvoid.github.io/2019/09/14/BP神经网络原理和简明理解/bp4.jpg" alt="bp4"></p><ul><li><strong>正向传播</strong>：输入$i_1,i_2$数据，然后一层一层传播下去，知道输出层输出结果。</li><li><strong>反向传播</strong>：输入、期望的输出为已知。在开始时，权重$w$,偏置$b$初始化为随机值，按网络计算后观察结果。根据结果的<strong>误差</strong>(也叫损失)，调整权重$w$,偏置$b$，这时就完成了一次反向传播。</li><li>当完成了一次正反向传播，也就完成了一次神经网络的训练迭代，反复迭代，误差越来越小，直至训练完成。</li></ul><h1 id="BP算法推导和数值计算"><a href="#BP算法推导和数值计算" class="headerlink" title="BP算法推导和数值计算"></a>BP算法推导和数值计算</h1><h2 id="初始化参数"><a href="#初始化参数" class="headerlink" title="初始化参数"></a>初始化参数</h2><ul><li>输入：$i_1=0.1,i_2=0.2$</li><li>输出：$O_1=0.01,O_2=0.99,(训练时的输出期望值)$</li><li>权重：$w_1=0.1,w_2=0.2,w_3=0.3,w_4=0.4 \ w_5=0.5,w_6=0.6,w_7=0.7,w_8=0.8 \ (这些权重是随机初始化的，通过多次迭代训练调整直到训练完成)$</li><li>偏置：$b_1=0.55,b_2=0.56,b_3=0.66,b_4=0.67 \ (同随机初始化)$<h2 id="正向传播"><a href="#正向传播" class="headerlink" title="正向传播"></a>正向传播</h2><ul><li>输入层–&gt;隐藏层：</li></ul></li><li>计算<strong>隐藏层</strong>神经元$h_1$的输入加权和：$$IN_{h1}=w_1<em>i_1+w_2</em>i_2+1<em>b_1 \ =0.1</em>0.1+0.2<em>0.2+1</em>0.55 \ =0.6$$</li><li>计算<strong>隐藏层</strong>神经元$h_1$的输出，要通过激活函数Sigmoid处理：$$OUT_{h1}=\frac{1}{e^{-IN_{h1}}+1} \ =\frac{1}{e^{-0.6}+1} \ =0.6456563062$$</li><li>同理计算出<strong>隐藏层</strong>神经元$h_2$的输出：$$OUT_{h2}=0.6592603884$$<ul><li>隐藏层–&gt;输出层：</li></ul></li><li>计算<strong>输出层</strong>神经元$O_1$的<strong>输入</strong>加权和：$$IN_{O_1}=w_5<em>OUT_{h_1}+w_6</em>OUT_{h_2}+1<em>b_3 \ =0.5</em>0.6456563062+0.6<em>0.6592603884+1</em>0.66 \ =1.3783843861$$</li><li>计算<strong>输出层</strong>神经元$O_1$的输出：$$OUT_{O_1}=\frac{1}{e^{-IN_{O_1}}+1} \ =\frac{1}{e^{-1.3783843861}}\ =0.7987314002 $$</li><li>同理计算出<strong>输出层</strong>神经元$O_2$的输出：$$OUT_{O_2}=0.8374488853$$</li></ul><p>正向传播结束，可以看到输出层输出的结果：$[0.7987314002,0.8374488853]$，但是训练数据的期望输出是$[0.01,0.99]$，相差太大，这时就需要利用反向传播，更新权重$w$，然后重新计算输出。</p><h2 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h2><ul><li>计算输出误差：<ul><li>误差计算：$$E_{total}=\sum_{i=1}^2E_{OUT_{O_i}} \ =E_{OUT_{O_1}} + E_{OUT_{O_2}} \ =\frac{1}{2}(expected_{OUT_{O_1}}-OUT_{O_1})^2+\frac{1}{2}(expected_{OUT_{O_2}}-OUT_{O_2})^2 \ =\frac{1}{2}<em>(O_1-OUT_{O_1})^2+\frac{1}{2}</em>(O_2-OUT_{O_2})^2 \ =\frac{1}{2}<em>(0.01-0.7987314002)^2+\frac{1}{2}</em>(0.99-0.8374488853)^2 \=0.0116359213+0.3110486109 \=0.3226845322 \ 其中：E_{OUT_{O_1}}=0.0116359213,E_{OUT_{O_2}}= 0.3110486109$$</li><li>PS:这里使用这个简单的误差计算便于理解，实际上其效果有待提高。如果激活函数是饱和的，带来的缺陷就是系统迭代更新变慢，系统收敛就慢，当然这是可以有办法弥补的，一种方法是使用<strong>交叉熵函数</strong>作为损失函数。<a href="https://blog.csdn.net/lanchunhui/article/details/50086025" target="_blank" rel="noopener">这里</a>有更详细的介绍。</li><li>交叉熵损失函数：$$E_{total}=\frac{1}{m}\sum_{i=1}^m(O_i\cdot log OUT_{O_i}+(1-O_i)\cdot log(1-OUT_{O_i}))$$</li><li>对输出求偏导：$$\frac{\partial E_{total}}{\partial OUT_{O_i}}=\frac{1}{m}\sum_{i=1}^m(\frac{O_i}{OUT_{O_i}}-\frac{1-O_i}{1-OUT_{O_i}})$$</li></ul></li><li>隐藏层–&gt;输出层的权重的更新：<ul><li>链式求导法则(详细可参考<a href="[https://loopvoid.github.io/2018/10/15/%E8%87%AA%E5%8A%A8%E5%BE%AE%E5%88%86%E6%B3%95/](https://loopvoid.github.io/2018/10/15/自动微分法/)">这篇文章</a>)：$$假设y是u的函数，而u是x的函数：y=f(u),u=g(x) \ 那么对应的复合函数就是：y=f(g(x)) \ 那么y对x的导数则有：\frac{dy}{dx}=\frac{dy}{du}\cdot \frac{du}{dx}$$</li><li>以权重$w_5$举例计算：权重$w$的大小能直接影响输出，$w$不合适会使输出有误差。要知道某个$w$对误差影响的程度，可以用<strong>误差对该$w$的变化率</strong>来表达。如果$w$的很少的变化，会导致误差增大很多，说明这个$w$对误差影响的程度就更大，也就是说，误差对该$w$的变化率越高。而误差对$w$的变化率就是误差对$w$的偏导。如图，总误差的大小首先受输出层神经元$O_1$的输出影响，继续反推，$O_1$的输出受它自己的输入的影响，而它自己的输入会受到$w_5$的影响。<img src="//loopvoid.github.io/2019/09/14/BP神经网络原理和简明理解/bp5.jpg" alt="bp5"></li><li>那么根据链式法则有：$$\frac{\partial E_{total}}{\partial w_5}=\frac{\partial E_{total}}{\partial OUT_{O_1}}\frac{\partial OUT_{O_1}}{\partial IN_{O_1}}\frac{\partial IN_{O_1}}{\partial w_5} \ \because E_{total}=\frac{1}{2}(O_1-OUT_{O_1})^2+\frac{1}{2}(O_2-OUT_{O_2})^2 \ \therefore \frac{\partial E_{total}}{\partial OUT_{O_1}}=\frac{\partial (\frac{1}{2}(O_1-OUT_{O_1})^2+\frac{1}{2}(O_2-OUT_{O_2})^2)}{\partial OUT_{O_1}} \ =2<em>\frac{1}{2}(O_1-OUT_{O_1})^{2-1}</em>(0-1)+0 \ =-(O_1-OUT_{O_1}) \ =-(0.01-0.7987314002) \ =0.7887314002$$</li><li>$$\because OUT_{O_1}=\frac{1}{e^{-IN_{O_1}}+1} \ \therefore \frac{\partial OUT_{O_1}}{\partial IN_{O_1}}=\frac{\partial (\frac{1}{e^{-IN_{O_1}}+1})}{\partial IN_{O_1}} \ =OUT_{O_1}(1-OUT_{O_1}) \ =0.7987314002*(1-0.7987314002) \ =0.1607595505 $$</li><li>$$\because IN_{O_1}=w_5<em>OUT_{h_1}+w_6</em>OUT_{h_2}+1<em>b_3 \ \therefore \frac{\partial IN_{O_1}}{\partial w_5}=\frac{\partial (w_5</em>OUT_{h_1}+w_6<em>OUT_{H}+1</em>b_3)}{\partial w_5} \ =1<em>w_5^{(1-1)}</em>OUT_{h_1}+0+0 \ =OUT_{h_1} \=0.6456563062$$</li><li>所以：$$\frac{\partial E_{total}}{\partial w_5}=\frac{\partial E_{total}}{\partial OUT_{O_1}}\frac{\partial OUT_{O_1}}{\partial IN_{O_1}}\frac{\partial IN_{O_1}}{\partial w_5} \=0.7887314002<em>0.1607595505</em>0.6456563062\=0.0818667051$$</li><li>归纳如下：$$\frac{\partial E_{total}}{\partial w_5}=\frac{\partial E_{total}}{\partial OUT_{O_1}}\frac{\partial OUT_{O_1}}{\partial IN_{O_1}}\frac{\partial IN_{O_1}}{\partial w_5} \ =-(O_1-OUT_{O_1})\cdot OUT_{O_1}\cdot (1-OUT_{O_1})\cdot OUT_{h_1}\=\sigma_{O_1}\cdot OUT_{h_1} \ 其中，\sigma_{O_1}=-(O_1-OUT_{O_1})\cdot OUT_{O_1}\cdot (1-OUT_{O_1})$$</li></ul></li><li>隐藏层–&gt;输出层的偏置的更新：<ul><li>同理<strong>输出层</strong>偏置b更新如下：$$$$</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;单个神经元结构&quot;&gt;&lt;a href=&quot;#单个神经元结构&quot; class=&quot;headerlink&quot; title=&quot;单个神经元结构&quot;&gt;&lt;/a&gt;单个神经元结构&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;//loopvoid.github.io/2019/09/14/BP神经网络原理
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>蒙特卡洛搜索树</title>
    <link href="https://loopvoid.github.io/2019/08/20/%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>https://loopvoid.github.io/2019/08/20/蒙特卡洛搜索树/</id>
    <published>2019-08-20T10:02:56.000Z</published>
    <updated>2019-08-20T10:23:42.290Z</updated>
    
    <content type="html"><![CDATA[<p>[1]AlphaGo Zero论文</p><p><a href="https://deepmind.com/documents/119/agz_unformatted_nature.pdf" target="_blank" rel="noopener">https://deepmind.com/documents/119/agz_unformatted_nature.pdf</a></p><p>[2] 什么是强化学习？</p><p><a href="https://mubu.com/doc/WNKomuDNl" target="_blank" rel="noopener">https://mubu.com/doc/WNKomuDNl</a></p><p>[3]强化学习系列笔记</p><p><a href="http://www.cnblogs.com/steven-yang/p/6481772.html" target="_blank" rel="noopener">http://www.cnblogs.com/steven-yang/p/6481772.html</a></p><p>[4]蒙特卡洛搜索树—走子演算</p><p><a href="http://t.cn/RWMmLdM" target="_blank" rel="noopener">http://t.cn/RWMmLdM</a></p><p>[5] 深入浅出看懂 AlphaGo 如何下棋<br>原论文（英文）：<a href="https://link.jianshu.com/?t=https://www.nature.com/articles/nature24270.epdf?author_access_token=VJXbVjaSHxFoctQQ4p2k4tRgN0jAjWel9jnR3ZoTv0PVW4gB86EEpGqTRDtpIz-2rmo8-KG06gqVobU5NSCFeHILHcVFUeMsbvwS-lxjqQGg98faovwjxeTUgZAUMnRQ" target="_blank" rel="noopener">Mastering the game of Go without human knowledge</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[1]AlphaGo Zero论文&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://deepmind.com/documents/119/agz_unformatted_nature.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://d
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>自动微分法</title>
    <link href="https://loopvoid.github.io/2018/10/15/%E8%87%AA%E5%8A%A8%E5%BE%AE%E5%88%86%E6%B3%95/"/>
    <id>https://loopvoid.github.io/2018/10/15/自动微分法/</id>
    <published>2018-10-14T16:06:11.000Z</published>
    <updated>2019-08-06T07:57:48.256Z</updated>
    
    <content type="html"><![CDATA[<h1 id="几种微分求解的方法"><a href="#几种微分求解的方法" class="headerlink" title="几种微分求解的方法"></a>几种微分求解的方法</h1><ul><li>手动求解法(Manual Differentiation)</li><li>数值微分法(Numerical Differentiation)</li><li>符号微分法(Symbolic Differentiation)</li><li>自动微分法(Automatic Differentiation)</li></ul><h1 id="自动微分"><a href="#自动微分" class="headerlink" title="自动微分"></a>自动微分</h1><p>在数学和计算代数领域，automatic differentiation (AD)又称为 algorithmic differentiation 或者 computational differentiation。AD是一个可以对程序代码表示的数学函数进行自动微分的技术。AD利用链式法则来达到自动求解的目录，AD有两种主要的方法：</p><ul><li><strong>代码转换</strong>（source-code transformation）（R. Giering and T. Kaminski. 1998）： <ul><li>利用一个代码转换编译器，这个编译器会分析源代码，然后产生一个和源代码对应的伴随模式(adjoint model)程序，编译时的代码生成（如用 flex-bison 做词法、语法分析）；</li><li>优点是静态生成效率高(原始算法的3~4倍) ;</li><li>一次生成，多次使用，缺点是学习门槛较高（编译原理…）；</li><li>很多比较好的工具非免费；</li><li>对现代编程语言特性的限制（如C++类、模板等）；</li></ul></li><li><strong>运算符重载</strong>(operator overloading) <ul><li>应用比较广泛，很多编程语言特性可以很好的工作；</li><li>优点是简单直接，缺点是动态生成成本较高（代表性的工具效率是原始算法的10~35倍）。</li><li>较多免费开源 C++ 工具 (e.g. ADOL-C, CppAD, Sacado)；</li></ul></li></ul><p>AD 这两种实现方式：<strong>运算符重载</strong>与<strong>代码生成</strong>，两种方式的原理都一样， <code>链式法则</code>。AD相关工具，请到这个<a href="http://www.autodiff.org/" target="_blank" rel="noopener">http://www.autodiff.org/</a> 页面。自动微分（AD）是计算导数的最优方法，比符号计算、有限微分更快更精确，AD已经广泛应用在优化领域，包括人工神经网络的训练算法 back-propagation（BP）等。</p><h1 id="AD基本原理"><a href="#AD基本原理" class="headerlink" title="AD基本原理"></a>AD基本原理</h1><h2 id="链式法则"><a href="#链式法则" class="headerlink" title="链式法则"></a>链式法则</h2><p>AD基本原理是<code>链式法则</code>。链式法则又分为正向和反向。如下例子</p><p>$$y=f(g(h(x)))=f(g(h(w_0)))=f(g(w_1))=f(w_2)=w_3$$</p><p>那么链式法则就表示为:</p><p>$$\frac{dy}{dx}=\frac{dy}{dw_2}\frac{dw_2}{dw_1}\frac{dw_1}{dx}$$</p><p>正向链式法则：则从链里往外算（即，先算$\frac{dw_1}{dx}$，再算$\frac{dw_2}{dw_1}$，最后算$\frac{dy}{dw_2}$）。</p><p>反向链式法则：则从链外往外里（即，先算$\frac{dy}{dw_2}$，再算$\frac{dw_2}{dw_1}$，最后算$\frac{dw_1}{dx}$）。</p><p>简洁的表示为：</p><p>正向链式法则：计算递归式$$\frac{dw_i}{dx}=\frac{dw_i}{dw_{i-1}}\frac{dw_{i-1}}{dx}，且w_3=y$$</p><p>反向链式法则：计算递归式$$\frac{dy}{dw_i}=\frac{dy}{dw_{i+1}}\frac{dw_{i+1}}{dw_i}，且w_0=y$$</p><p> 通常，正向跟反向链式法则都是通过计算图来表示和计算，这样更加的方便。</p><h2 id="正向链式法则计算图"><a href="#正向链式法则计算图" class="headerlink" title="正向链式法则计算图"></a>正向链式法则计算图</h2><p>将函数转化为一个DAG（有向无环图），就能很容易的求解每一步的值。</p><h3 id="例1："><a href="#例1：" class="headerlink" title="例1："></a>例1：</h3><p>假设有计算式子：$y=x_0*x_1+x_1$  (1)，我们要求解$\frac{\partial y}{\partial x_1}$。</p><p>首先，其计算图表示为：</p><p><img src="//loopvoid.github.io/2018/10/15/自动微分法/%E8%AE%A1%E7%AE%97%E5%9B%BE1.png" alt="计算图1.png"></p><p>把（1）式展开为链式计算序列为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c=x0*x1</span><br><span class="line">d=c+x1</span><br><span class="line">y=d</span><br></pre></td></tr></table></figure><p>那么其对应的计算图则为：</p><p><img src="//loopvoid.github.io/2018/10/15/自动微分法/%E8%AE%A1%E7%AE%97%E5%9B%BE2.png" alt="计算图2.png"></p><p>这里假设$x_0,x_1$的初值分别为：1, 2。 (1)式展开计算子序列为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x0=1</span><br><span class="line">x1=2</span><br><span class="line">c=x0*x1</span><br><span class="line">d=c+x1</span><br><span class="line">y=d</span><br></pre></td></tr></table></figure><p>那么其对应计算图为：</p><p><img src="//loopvoid.github.io/2018/10/15/自动微分法/%E8%AE%A1%E7%AE%97%E5%9B%BE3.png" alt="计算图3.png"></p><p>然后对该计算图求解偏导数：</p><p><img src="//loopvoid.github.io/2018/10/15/自动微分法/%E8%AE%A1%E7%AE%97%E5%9B%BE4.png" alt="计算图4.png"></p><p>由链式法则得到：$$\frac{\partial y}{\partial  x_1}=\frac{\partial y}{\partial  d}\frac{\partial d}{\partial  c}\frac{\partial c}{\partial  x_1}+\frac{\partial y}{\partial  d}\frac{\partial d}{\partial  x_1}$$</p><p>结合计算图中对应的值可知：$\frac{\partial y}{\partial  x_1}=1\times1\times1+1\times1=2$</p><h3 id="例2："><a href="#例2：" class="headerlink" title="例2："></a>例2：</h3><p>对于下列函数：$$f(x_1,x_2)=ln(x_1)+x_1*x_2-sin(x_2)$$</p><p>转化为计算图：</p><p><img src="//loopvoid.github.io/2018/10/15/自动微分法/%E8%AE%A1%E7%AE%97%E5%9B%BE5.png" alt="计算图5.png"></p><p>那么求每一步的导数值就可以表示为：</p><p><img src="//loopvoid.github.io/2018/10/15/自动微分法/%E8%AE%A1%E7%AE%97%E5%9B%BE6.png" alt="计算图6.png"></p><p>上表，左半部分是从左往右计算图每个节点的求值结果，右半部分是每个节点对于$x_1$的求导结果，比如$\dot{v_1}=\frac{dv}{dx_1}$，注意到每一步的求导都会利用到上一步的求导结果。</p><p>对于自动微分的正向模式，如果函数输入输出为：$R \rightarrow R^m $</p><p>那么正向模式只需要计算一次上表右侧过程即可，非常高效。但是对于输入输出映射为：$R^n\rightarrow R^m$，这样一个有$n$个输入的函数，对于函数的梯度求解则需要处理$n$遍上述过程。而且再实际算法模型中，通常输入输出是极度不成比例的，也就是$n&gt;&gt;m$，那么利用正向模式进行自动微分的效率就太低了，因此有了反向模式的出现。</p><h2 id="反向链式法则计算图"><a href="#反向链式法则计算图" class="headerlink" title="反向链式法则计算图"></a>反向链式法则计算图</h2><p>自动微分的反向模式其实就是一种通用的<a href="https://en.wikipedia.org/wiki/Backpropagation" target="_blank" rel="noopener">BackPropagation</a>(<a href="http://galaxy.agh.edu.pl/~vlsi/AI/backp_t_en/backprop.html" target="_blank" rel="noopener">反向传播算法</a>)，即backpropagation是自动微分反向模式的一种特殊形式。</p><p>反向模式从最终结果开始求导，利用最终输出对每一个节点进行求导，其过程如下计算图所示： </p><p><img src="//loopvoid.github.io/2018/10/15/自动微分法/%E8%AE%A1%E7%AE%97%E5%9B%BE7.png" alt="计算图7.png"></p><p>其具体计算过程如下表所示：   </p><p><img src="//loopvoid.github.io/2018/10/15/自动微分法/%E8%AE%A1%E7%AE%97%E5%9B%BE8.png" alt="计算图8.png"></p><p>上表左边和之前的正向模式一致，用于求解函数值，右边则是反向模式的计算过程，须从下向上看，也就是一开始先计算输出$y$对于节点$v_5$的导数，用$\bar{v_5}=\frac{dy}{dv_5}$，这样的记号可以强调我们对当前计算结果进行缓存，以便用于后续计算，而不必重复计算。再由链式法则我们可以计算输出节点对于图种每个节点的导数。  </p><p>比如对节点$v_3$：</p><p>$$\frac{y}{v_3}=\frac{dy}{dv_5}\frac{dv_5}{dv_3}$$</p><p>用$\bar{v_i}=\frac{dy}{dv_i}$记法，则有：</p><p>$$\frac{y}{v_3}=\bar{v_5}\frac{dv_5}{dv_3}$$</p><p>比如对于节点$v_0$：</p><p>  $$\frac{y}{v_0}=\frac{dy}{dv_2}\frac{dv_2}{dv_0}+\frac{dy}{dv_3}\frac{dv_3}{dv_0}$$</p><p>用$\bar{v_i}=\frac{dy}{dv_i}$记法，则有：</p><p>  $$\frac{y}{v_0}=\bar{v_2}\frac{dv_2}{dv_0}+\bar{v_3}\frac{dv_3}{dv_0}$$</p><p>和backpropagation算法一样，我们必须记住前向时当前节点发出的边，然后在反向传播时，可以搜集所有受到当前节点影响的节点。 </p><p>如上的计算过程，对于像神经网络这种模型，输入通常是上万到上百万维，而输出损失函数是1维的模型，则只需要一遍反向模式计算过程，便可以求出输出对于各个输入的导数，从而轻松求取梯度用于后续优化更新。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>AD:</p><ul><li><a href="https://arxiv.org/pdf/1502.05767.pdf" target="_blank" rel="noopener">Automatic differentiation in machine learning: a survey</a></li><li><a href="http://www.met.reading.ac.uk/~swrhgnrj/publications/adept.pdf" target="_blank" rel="noopener">Fast Reverse-Mode Automatic Differentiation using Expression</a></li><li><a href="https://www.zhihu.com/question/48356514" target="_blank" rel="noopener">https://www.zhihu.com/question/48356514</a></li><li><a href="https://blog.csdn.net/daniel_ustc/article/details/77133329" target="_blank" rel="noopener">https://blog.csdn.net/daniel_ustc/article/details/77133329</a></li><li><a href="https://en.wikipedia.org/wiki/Automatic_differentiation" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Automatic_differentiation</a></li><li><a href="https://github.com/autodiff/autodiff" target="_blank" rel="noopener">https://github.com/autodiff/autodiff</a></li><li><a href="https://www.jianshu.com/p/4c2032c685dc" target="_blank" rel="noopener">https://www.jianshu.com/p/4c2032c685dc</a></li><li><a href="http://www.autodiff.org/" target="_blank" rel="noopener">http://www.autodiff.org/</a></li><li><a href="https://blog.csdn.net/u013527419/article/details/70184690" target="_blank" rel="noopener">https://blog.csdn.net/u013527419/article/details/70184690</a></li><li><a href="https://github.com/zakheav/automatic-differentiation-framework" target="_blank" rel="noopener">https://github.com/zakheav/automatic-differentiation-framework</a></li><li><a href="https://blog.csdn.net/daniel_ustc/article/details/77133329" target="_blank" rel="noopener">https://blog.csdn.net/daniel_ustc/article/details/77133329</a></li><li><a href="https://blog.csdn.net/aws3217150/article/details/70214422" target="_blank" rel="noopener">https://blog.csdn.net/aws3217150/article/details/70214422</a></li></ul><p>BP:</p><ul><li><a href="https://www.zhihu.com/question/27239198" target="_blank" rel="noopener">https://www.zhihu.com/question/27239198</a></li><li><a href="http://galaxy.agh.edu.pl/~vlsi/AI/backp_t_en/backprop.html" target="_blank" rel="noopener">http://galaxy.agh.edu.pl/~vlsi/AI/backp_t_en/backprop.html</a></li><li><a href="https://en.wikipedia.org/wiki/Backpropagation" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Backpropagation</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;几种微分求解的方法&quot;&gt;&lt;a href=&quot;#几种微分求解的方法&quot; class=&quot;headerlink&quot; title=&quot;几种微分求解的方法&quot;&gt;&lt;/a&gt;几种微分求解的方法&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;手动求解法(Manual Differentiation)&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="数学" scheme="https://loopvoid.github.io/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="自动微分" scheme="https://loopvoid.github.io/tags/%E8%87%AA%E5%8A%A8%E5%BE%AE%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>Jacobian矩阵与Hessian矩阵与最小二乘</title>
    <link href="https://loopvoid.github.io/2018/04/28/Jacobian%E7%9F%A9%E9%98%B5%E4%B8%8EHessian%E7%9F%A9%E9%98%B5%E4%B8%8E%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98/"/>
    <id>https://loopvoid.github.io/2018/04/28/Jacobian矩阵与Hessian矩阵与最小二乘/</id>
    <published>2018-04-28T08:15:17.000Z</published>
    <updated>2019-08-06T06:49:50.751Z</updated>
    
    <content type="html"><![CDATA[<h1 id="雅可比矩阵-Jacobian-matrix"><a href="#雅可比矩阵-Jacobian-matrix" class="headerlink" title="雅可比矩阵 (Jacobian matrix)"></a>雅可比矩阵 (Jacobian matrix)</h1><p>在向量分析中, 雅可比矩阵是<strong>一阶偏导</strong>数以一定方式排列成的<strong>矩阵</strong>, 其行列式称为雅可比行列式. 还有, 在代数几何中, 代数曲线的雅可比量表示雅可比簇：伴随该曲线的一个代数群, 曲线可以嵌入其中. 它们全部都以数学家卡尔·雅可比(Carl Jacob, 1804年10月4日－1851年2月18日)命名；英文雅可比量”Jacobian”可以发音为[ja ˈko bi ən]或者[ʤə ˈko bi ən].</p><p>雅可比矩阵的重要性在于它体现了一个可微方程与给出点的<strong>最优线性逼近</strong>. 因此, 雅可比矩阵类似于<strong>多元函数的导数</strong>.</p><p>假设$F:R_n→R_m$是一个从欧式n维空间转换到欧式m维空间的函数。这个函数由m个实函数组成:$ y_1(x_1,…,x_n), …, y_m(x_1,…,x_n)$. 这些函数的偏导数(如果存在)可以组成一个m行n列的矩阵，这就是所谓的雅可比矩阵：<br>$$\begin{bmatrix} \frac{\partial y_1}{\partial x_1} &amp;  \cdots &amp; \frac{\partial y_1}{\partial x_n}\ \vdots &amp;  \ddots &amp; \vdots  \ \frac{\partial y_n}{\partial x_1} &amp;  \cdots &amp; \frac{\partial y_n}{\partial x_n} \end{bmatrix}$$</p><p>此矩阵表示为：$J_F(x_1,\cdots ,x_2)$，或者:$\frac{\partial (y_1,\cdots,y_n)}{\partial (x_1, \cdots ,x_n)}$</p><p>这个矩阵的第$i$行是由梯度函数的转置$y_i(i=1,…,m)$表示的。</p><p>如果$p$是$R_n$中的一点, $F$在$p$点可<strong>微分</strong>, 那么在$p$这一点的导数由$J_{F(p)}$给出(这是求该点导数最简便的方法). 在此情况下, 由$F_(p)$描述的<strong>线性算子</strong>即接近点$p$的$F$的<strong>最优线性逼近</strong>, $x$逼近于$p$:$F_(x) \approx F_{(p)} + J_{F(p)} \cdot (x-p)$</p><p>从数学意义上来解释雅可比矩阵，我们可以想象有6个函数，每个函数对应着有6个变量。那么针对每个输入变量$x_i$，就会能够得到对应的$y_i$.<br>$$y_1=f_1(x_1,x_2,x_3,x_4,x_5,x_6)$$<br>$$y_2=f_2(x_1,x_2,x_3,x_4,x_5,x_6)$$<br>$$y_3=f_3(x_1,x_2,x_3,x_4,x_5,x_6)$$<br>$$y_4=f_4(x_1,x_2,x_3,x_4,x_5,x_6)$$<br>$$y_5=f_5(x_1,x_2,x_3,x_4,x_5,x_6)$$<br>$$y_6=f_6(x_1,x_2,x_3,x_4,x_5,x_6)$$<br>因此$y_i$的导数可以被写成：<br>$${\mathrm{d} y_i} = \frac{\partial f_i}{\partial x_1}{\mathrm{d} x_1}+\frac{\partial f_i}{\partial x_2}{\mathrm{d} x_2}+\frac{\partial f_i}{\partial x_3}{\mathrm{d} x_3}+\frac{\partial f_i}{\partial x_4}{\mathrm{d} x_4}+\frac{\partial f_i}{\partial x_5}{\mathrm{d} x_5}+\frac{\partial f_i}{\partial x_6}{\mathrm{d} x_6}$$<br>因此结合上面的方程，我们可以将上面的方程写为向量的形式：<br>$${\mathrm{d} Y}=\frac{\partial F}{\partial X}{\mathrm{d} X}$$<br>函数F对于X的偏导数矩阵，就被称为雅可比矩阵(Jacobian)。</p><p>换句话说，雅可比矩阵就是X的速度到Y的速度的映射：$\dot{Y}=J(X)\dot{X}$<br>在某个时间步长，雅可比矩阵其实也就是针对于$x_i$的函数。在下一个时间步长的时候，$x$改变了，因此雅可比矩阵也进行了改变。</p><p>在某个给定点的雅可比行列式提供了<strong>在接近该点时的表现的重要信息</strong>. 例如, 如果连续可微函数$F$在$p$点的雅可比行列式不是零, 那么它在该点附近具有反函数. 这称为反函数定理. 更进一步, 如果pp点的雅可比行列式是正数, 则$F$在$p$点的取向不变；如果是负数, 则FF的取向相反. 而从雅可比行列式的绝对值, 就可以知道函数$F$在$p$点的缩放因子；这就是为什么它出现在换元积分法中.</p><p>对于取向问题可以这么理解, 例如一个物体在平面上匀速运动, 如果施加一个正方向的力$F$, 即取向相同, 则加速运动, 类比于速度的导数加速度为正；如果施加一个反方向的力$F$, 即取向相反, 则减速运动, 类比于速度的导数加速度为负.</p><p><a href="ttp://jacoxu.com/jacobian%E7%9F%A9%E9%98%B5%E5%92%8Chessian%E7%9F%A9%E9%98%B5/" target="_blank" rel="noopener">Jacobian矩阵和Hessian矩阵</a><br><a href="https://blog.csdn.net/noahzuo/article/details/54314112" target="_blank" rel="noopener">使用雅可比矩阵(Jacobian)来结算IK</a><br><a href="https://www.zhihu.com/question/22586361" target="_blank" rel="noopener">如何理解雅克比矩阵?—知乎</a><br><a href="https://blog.csdn.net/u011494690/article/details/43274301" target="_blank" rel="noopener">雅克比矩阵、海森矩阵与非线性最小二乘间的关系与在SFM和Pose Estimation中的应用</a><br><a href="ttp://jacoxu.com/jacobian%E7%9F%A9%E9%98%B5%E5%92%8Chessian%E7%9F%A9%E9%98%B5/" target="_blank" rel="noopener">acobian矩阵和Hessian矩阵</a><br><a href="https://blog.csdn.net/noahzuo/article/details/54314112" target="_blank" rel="noopener">动画研究 – 使用雅可比矩阵(Jacobian)来结算IK</a></p><h1 id="海森矩阵（Hessian-matrix）"><a href="#海森矩阵（Hessian-matrix）" class="headerlink" title="海森矩阵（Hessian matrix）"></a>海森矩阵（Hessian matrix）</h1><p><strong>海森矩阵</strong>是一个自变量为向量的实值函数的<strong>二阶偏导数</strong>组成的<strong>方块矩阵</strong>.</p><p>此函数如下：$$f(x_1,\cdots,x_n)$$</p><p>如果 <em>f</em> 所有的二阶导数都存在，那么 <em>f</em> 的海森矩阵即：$H(f)_{ij}(x)=D_iD_jf(x)$其中$x=(x_1,x_2,\cdots,x_n)$，即是：</p><p>$$H(f)=\begin{bmatrix} \frac{\partial^2 f}{\partial x_1^2} &amp;\frac{\partial^2 f}{\partial x_1\partial x_2}  &amp;\cdots &amp;\frac{\partial^2 f}{\partial x_1\partial x_n} \ \frac{\partial^2 f}{\partial x_2\partial x_1} &amp;\frac{\partial^2 f}{\partial x_2^2}  &amp;\cdots &amp;\frac{\partial^2 f}{\partial x_2\partial x_n} \ \vdots  &amp;\vdots   &amp;\ddots   &amp;\vdots  \ \frac{\partial^2 f}{\partial x_n\partial x_1} &amp;\frac{\partial^2 f}{\partial x_n\partial x_2}  &amp;\cdots &amp;\frac{\partial^2 f}{\partial x_n^2} \end{bmatrix}$$</p><p>(也有人把海森定义为以上矩阵的行列式)海森矩阵被应用于牛顿法解决的大规模优化问题.</p><h2 id="海森矩阵在牛顿法中的应用"><a href="#海森矩阵在牛顿法中的应用" class="headerlink" title="海森矩阵在牛顿法中的应用"></a>海森矩阵在牛顿法中的应用</h2><p>一般来说, 牛顿法主要应用在两个方面:</p><ul><li>求方程的根</li><li>最优化</li></ul><h3 id="求根"><a href="#求根" class="headerlink" title="求根"></a>求根</h3><p>并不是所有的方程都有求根公式, 或者求根公式很复杂, 导致求解困难. 利用牛顿法, 可以迭代求解.</p><p>原理是利用泰勒公式, 在$x_0$处展开, 且展开到一阶, 即$f(x)=f(x_0)+(x-x_0)f’(x_0)$</p><p>求解方程$f(x)=0$，即求解$f(x_0)+(x-x_0)f’(x_0) = 0$</p><p>即是求解$$x=x_1=x_0-\frac{f(x_0)}{f’(x_0)}$$</p><p>因为这是利用泰勒公式的一阶展开,$f(x)$的值是近似相等，这里求得的$x_1$，只能让$f(x_1) \approx 0$。于是乎, 迭代求解的想法就很自然了, 可以进而推出：$x_{n+1}=x_n-\frac{f(x_n)}{f’(x_n)}$， 通过迭代, 这个式子必然在$f(x^*)=0$的时候收敛.过程如下图：</p><p><img src="//loopvoid.github.io/2018/04/28/Jacobian矩阵与Hessian矩阵与最小二乘/hessian.jpg" alt="hessian"></p><h3 id="最优化"><a href="#最优化" class="headerlink" title="最优化"></a>最优化</h3><p>在最优化的问题中, 线性最优化至少可以使用单纯形法(或称<strong><a href="https://en.wikipedia.org/wiki/Fixed-point_arithmetic" target="_blank" rel="noopener">不动点算法</a></strong>)求解, 但对于非线性优化问题, 牛顿法提供了一种求解的办法.假设任务是优化一个目标函数$f$,求函数$f$的极大极小问题可以转化为求解函数$f$的导数${f}’=0$的问题。, 这样求可以把优化问题看成方程(${f}’=0$)求解问题。剩下的问题就和前面提到的牛顿法求解很相似了。</p><p>这次为了求解${f}’=0$的根, 首先把$f(x)$在探索点$x_n$处泰勒展开, 展开到2阶形式进行近似：</p><p>$$f(x)=f(x_n)+f’(x_n)(x-x_n)+\frac{f’’(x_n)}{2}(x-x_n)^2$$</p><p>然后用$f(x)$的最小点做为新的探索点$f(x+1)$，据此，令：</p><p>$$f’(x)=f’(x_n)+f’’(x_n)(x-x_n)=0$$</p><p>求得出迭代公式:</p><p>$$x_{n+1}=x_n-\frac{f’(n)}{f’’(n)},n=0,1,…$$</p><p>一般认为牛顿法可以利用到曲线本身的信息, 比梯度下降法更容易收敛（迭代更少次数）, 如下图是一个最小化一个目标方程的例子, 红色曲线是利用牛顿法迭代求解, 绿色曲线是利用梯度下降法求解.</p><p><img src="//loopvoid.github.io/2018/04/28/Jacobian矩阵与Hessian矩阵与最小二乘/optimize.jpg" alt="optimize"></p><p>在上面讨论的是2维情况, 高维情况的牛顿迭代公式是：</p><p>$$x_{n+1}=x_n-[\bigtriangledown ^2f(x_n)]^{-1}\bigtriangledown f(x_n),n\geqslant 0$$</p><p>其中$\bigtriangledown ^2$是<strong>Hessian矩阵</strong>，$\bigtriangledown$为$f$的<strong>梯度向量</strong>，$f$的矢量微分运算。</p><p>高维情况依然可以用牛顿迭代求解, 但是问题是Hessian矩阵引入的复杂性, 使得牛顿迭代求解的难度大大增加, 但是已经有了解决这个问题的办法就是Quasi-Newton method, 不再直接计算Hessian矩阵, 而是每一步的时候使用<strong>梯度向量</strong>更新Hessian矩阵的近似.</p><p><strong>Reference：</strong><br><a href="ttp://jacoxu.com/jacobian%E7%9F%A9%E9%98%B5%E5%92%8Chessian%E7%9F%A9%E9%98%B5/" target="_blank" rel="noopener">Jacobian矩阵和Hessian矩阵</a><br><a href="https://blog.csdn.net/u011494690/article/details/43274301" target="_blank" rel="noopener">雅克比矩阵、海森矩阵与非线性最小二乘间的关系与在SFM和Pose Estimation中的应用</a><br><a href="https://my.oschina.net/u/3579120/blog/1508433" target="_blank" rel="noopener">最优化方法:牛顿迭代法和拟牛顿迭代法</a></p><h1 id="最小二乘"><a href="#最小二乘" class="headerlink" title="最小二乘"></a>最小二乘</h1><p>最小二乘法的本质是最小化系数矩阵所张成的向量空间到观测向量的欧式误差距离.</p><p>最小二乘法的一种常见的描述是残差满足正态分布的最大似然估计</p><p>现行的最小二乘法是勒让德( A. M. Legendre)于1805年在其著作《计算慧星轨道的新方法》中提出的。它的主要思想就是选择未知参数，使得<strong>理论值</strong>与<strong>观测值</strong>之差的平方和达到最小：$H = \sum_{0}^{m}(y-y_i)^2$</p><p>##线性最小二乘问题</p><p>采用线性模型去拟合数据，即$y(x)=Jx$，则目标函数为$f(x)=\frac{1}{2}||Jx-y||^2$，同时$\bigtriangledown f(x)=J^T(Jx-y)$，</p><p>$\bigtriangledown^2 f(x)=J^TJ$。</p><p>根据最优化定理，该问题的最优解满足如下条件：$\bigtriangledown f(x)=0$，即是$J^TJx=J^Ty$。</p><p>求解该方程，有如下方法:</p><ol><li><strong><a href="https://en.wikipedia.org/wiki/Cholesky_decomposition" target="_blank" rel="noopener">Cholesky分解</a></strong>：当m&gt;&gt;n时，并且J比较稀疏时比较实用，但是其精度和条件数的平方相关 </li><li><strong><a href="https://en.wikipedia.org/wiki/QR_decomposition" target="_blank" rel="noopener">QR分解</a></strong>：精度和条件数相关 </li><li><strong><a href="https://en.wikipedia.org/wiki/Singular-value_decomposition" target="_blank" rel="noopener">SVD分解</a></strong>：相对比较鲁棒，同时也可以添加正则项避免J是个病态矩阵。 </li><li><strong>数值迭代算法</strong>：对于大规模数据比较实用。</li></ol><h2 id="非线性最小二乘问题"><a href="#非线性最小二乘问题" class="headerlink" title="非线性最小二乘问题"></a>非线性最小二乘问题</h2><p>采用非线性模型拟合数据，模型本身可能矢量梯度或者Hessian矩阵不容易得到。</p><h3 id="高斯牛顿方法（Gauss-Newton方法）"><a href="#高斯牛顿方法（Gauss-Newton方法）" class="headerlink" title="高斯牛顿方法（Gauss-Newton方法）"></a>高斯牛顿方法（Gauss-Newton方法）</h3><p>根据标准牛顿方程，$\bigtriangledown f(x_k)p=-\bigtriangledown f(x_k) $可以得到该问题的需要满</p><p>足的条件，即$J^TJP^{GN}=-J^Tr_K$</p><p>此时Hessian矩阵用第一项代替，即$\bigtriangledown^2f(x) \approx J^TJ$</p><p>得到搜索方向后，可以使用线搜索的方法得到步长，重复进行可以得到最优解。</p><p><strong>Reference:</strong><br><a href="https://blog.csdn.net/fangqingan_java/article/details/48948487" target="_blank" rel="noopener">最小二乘问题(Least-Squares)</a><br><a href="https://blog.csdn.net/bitcarmanlee/article/details/51589143" target="_blank" rel="noopener">最小二乘法 来龙去脉</a><br><a href="http://lanbing510.info/2016/03/28/Least-Squares-Parameter-Estimation.html" target="_blank" rel="noopener">最小二乘法的参数估计</a><br><a href="https://blog.csdn.net/qll125596718/article/details/8248249" target="_blank" rel="noopener">一元线性回归模型与最小二乘法及其C++实现</a><br><a href="http://blog.sciencenet.cn/home.php?mod=space&uid=465130&do=blog&id=1001688" target="_blank" rel="noopener">机器视觉中的非线性最小二乘法</a><br><a href="https://blog.csdn.net/ivysister/article/details/45438413" target="_blank" rel="noopener">最小二乘法，牛顿法，梯度下降法以及比较</a><br><a href="https://www.cnblogs.com/iamccme/archive/2013/05/15/3080737.html" target="_blank" rel="noopener">机器学习经典算法之—–最小二乘法</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;雅可比矩阵-Jacobian-matrix&quot;&gt;&lt;a href=&quot;#雅可比矩阵-Jacobian-matrix&quot; class=&quot;headerlink&quot; title=&quot;雅可比矩阵 (Jacobian matrix)&quot;&gt;&lt;/a&gt;雅可比矩阵 (Jacobian matri
      
    
    </summary>
    
      <category term="基础知识" scheme="https://loopvoid.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="基础知识" scheme="https://loopvoid.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
      <category term="最优化" scheme="https://loopvoid.github.io/tags/%E6%9C%80%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>C++并发学习笔记(三)(std::mutex 详解)</title>
    <link href="https://loopvoid.github.io/2018/03/17/C-%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89-std-mutex-%E8%AF%A6%E8%A7%A3/"/>
    <id>https://loopvoid.github.io/2018/03/17/C-并发学习笔记-三-std-mutex-详解/</id>
    <published>2018-03-17T14:51:18.000Z</published>
    <updated>2019-08-06T06:58:19.373Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Mutex</strong>又称为互斥量，C++ 11中与 Mutex 相关的类（包括锁类型）和函数都声明在<code>&lt;mutex&gt;</code> 头文件中，所以如果你需要使用 std::mutex，就必须包含 <code>&lt;mutex&gt;</code>头文件。</p><p>std::mutex 是C++11 中最基本的互斥量，std::mutex 对象提供了独占所有权的特性——即不支持递归地对 std::mutex 对象上锁，而 std::recursive_lock 则可以递归地对互斥量对象上锁。</p><h1 id="mutex头文件介绍"><a href="#mutex头文件介绍" class="headerlink" title="mutex头文件介绍"></a>mutex头文件介绍</h1><p><strong>互斥量基本作用：</strong> 互斥占有一个变量，一段时间内仅一个线程可以访问。即该类可以限制对某物的访问，只有先获得许可才可访问某物，否则一般可设为阻塞等待。能有效避免资源竞争问题。</p><h2 id="Mutexes类（四种）"><a href="#Mutexes类（四种）" class="headerlink" title="Mutexes类（四种）"></a>Mutexes类（四种）</h2><ul><li><code>std::mutex</code>，最基本的 Mutex 类。</li><li><code>std::recursive_mutex</code>，递归 Mutex 类。</li><li><code>std::time_mutex</code>，定时 Mutex 类。</li><li><code>std::recursive_timed_mutex</code>，定时递归 Mutex 类。</li></ul><p>##Lock类（两种）</p><ul><li><a href="http://www.cplusplus.com/reference/mutex/lock_guard/" target="_blank" rel="noopener">std::lock_guard</a>，与 Mutex RAII 相关，方便线程对互斥量上锁。</li><li><a href="http://www.cplusplus.com/reference/mutex/unique_lock/" target="_blank" rel="noopener">std::unique_lock</a>，与 Mutex RAII 相关，方便线程对互斥量上锁，但提供了更好的上锁和解锁控制。</li></ul><p>##其他类型</p><ul><li><a href="http://www.cplusplus.com/reference/mutex/once_flag/" target="_blank" rel="noopener">std::once_flag</a></li><li><a href="http://www.cplusplus.com/reference/mutex/adopt_lock_t/" target="_blank" rel="noopener">std::adopt_lock_t</a></li><li><a href="http://www.cplusplus.com/reference/mutex/defer_lock_t/" target="_blank" rel="noopener">std::defer_lock_t</a></li><li><a href="http://www.cplusplus.com/reference/mutex/try_to_lock_t/" target="_blank" rel="noopener">std::try_to_lock_t</a></li></ul><p>##函数</p><ul><li><a href="http://www.cplusplus.com/reference/mutex/try_lock/" target="_blank" rel="noopener">std::try_lock</a>，尝试同时对多个互斥量上锁。</li><li><a href="http://www.cplusplus.com/reference/mutex/lock/" target="_blank" rel="noopener">std::lock</a>，可以同时对多个互斥量上锁。</li><li><a href="http://www.cplusplus.com/reference/mutex/call_once/" target="_blank" rel="noopener">std::call_once</a>，如果多个线程需要同时调用某个函数，call_once 可以保证多个线程对该函数只调用一次。</li></ul><h1 id="std-mutex-介绍"><a href="#std-mutex-介绍" class="headerlink" title="std::mutex 介绍"></a>std::mutex 介绍</h1><ul><li><p><strong>构造函数</strong>，std::mutex不允许拷贝构造，也不允许 move 拷贝，最初产生的 mutex 对象是处于 <strong>unlocked</strong> 状态的。</p></li><li><p><strong>lock()</strong>，调用线程将锁住该互斥量。线程调用该函数会发生下面 3 种情况：</p><p>(1). 如果该互斥量当前没有被锁住，则调用线程将该互斥量锁住，直到调用 unlock之前，该线程一直拥有该锁。</p><p>(2). 如果当前互斥量被其他线程锁住，则当前的调用线程被阻塞住。</p><p>(3). 如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)。</p></li><li><p><strong>unlock()</strong>， 解锁，释放对互斥量的所有权。</p></li><li><p><strong>try_lock()</strong>，尝试锁住互斥量，如果互斥量被其他线程占有，则当前线程也不会被阻塞。线程调用该函数也会出现下面 3 种情况，</p><p>(1). 如果当前互斥量没有被其他线程占有，则该线程锁住互斥量，直到该线程调用 unlock 释放互斥量。</p><p>(2). 如果当前互斥量被其他线程锁住，则当前调用线程返回 false，而并不会被阻塞掉。</p><p>(3). 如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)。</p></li></ul><p>*<em>mutex::lock     *</em>Example(<a href="http://www.cplusplus.com/reference/mutex/mutex/lock/" target="_blank" rel="noopener">reference</a>):</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mutex::lock/unlock</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;       // std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;         // std::thread</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;          // std::mutex</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::mutex mtx;           <span class="comment">// mutex for critical section</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_thread_id</span> <span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// critical section (exclusive access to std::cout signaled by locking mtx):</span></span><br><span class="line">  mtx.lock();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"thread #"</span> &lt;&lt; id &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  mtx.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::thread threads[<span class="number">10</span>];</span><br><span class="line">  <span class="comment">// spawn 10 threads:</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i)</span><br><span class="line">    threads[i] = <span class="built_in">std</span>::thread(print_thread_id,i+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; th : threads) th.join();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">thread #1</span><br><span class="line">thread #2</span><br><span class="line">thread #3</span><br><span class="line">thread #4</span><br><span class="line">thread #5</span><br><span class="line">thread #6</span><br><span class="line">thread #7</span><br><span class="line">thread #8</span><br><span class="line">thread #9</span><br><span class="line">thread #10</span><br></pre></td></tr></table></figure><p>*<em>mutex::try_lock     *</em>Example(<a href="http://www.cplusplus.com/reference/mutex/mutex/try_lock/" target="_blank" rel="noopener">reference</a>):</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mutex::try_lock example</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;       // std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;         // std::thread</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;          // std::mutex</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">volatile</span> <span class="keyword">int</span> <span class="title">counter</span> <span class="params">(<span class="number">0</span>)</span></span>; <span class="comment">// non-atomic counter</span></span><br><span class="line"><span class="built_in">std</span>::mutex mtx;           <span class="comment">// locks access to counter</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attempt_10k_increases</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10000</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mtx.try_lock()) &#123;   <span class="comment">// only increase if currently not locked:</span></span><br><span class="line">      ++counter;</span><br><span class="line">      mtx.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::thread threads[<span class="number">10</span>];</span><br><span class="line">  <span class="comment">// spawn 10 threads:</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i)</span><br><span class="line">    threads[i] = <span class="built_in">std</span>::thread(attempt_10k_increases);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; th : threads) th.join();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; counter &lt;&lt; <span class="string">" successful increases of the counter.\n"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Possible output (any count between 1 and 100000 possible):</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">17987 successful increases of the counter.</span><br></pre></td></tr></table></figure><p>#std::recursive_mutex 介绍</p><p><code>std::recursive_mutex</code> 与<code>std::mutex</code> 一样，也是一种可以被上锁的对象，但和 <code>std::mutex</code> 不同的是，<code>std::recursive_mutex</code> <strong>允许同一个线程对互斥量多次上锁（即递归上锁）</strong>，来获得对互斥量对象的<strong>多层所有权</strong>，<code>std::recursive_mutex</code> 释放互斥量时需要调用与该锁层次深度相同次数的 <code>unlock()</code>，可理解为 <code>lock()</code> 次数和<code>unlock()</code>次数相同，除此之外，<code>std::recursive_mutex</code> 的特性和 <code>std::mutex</code> 大致相同。</p><p>如果<strong>一个线程中可能在执行中需要再次获得锁</strong>的情况，按常规的做法会出现<strong>死锁</strong>。此时就需要使用递归式互斥量<code>std::recursive_mutex</code>来避免这个问题。<code>std::recursive_mutex</code>不会产生上述的死锁问题，只是是增加锁的计数,但必须确保你unlock和lock的次数相同，其他线程才可能锁这个mutex。</p><h1 id="std-time-mutex-介绍"><a href="#std-time-mutex-介绍" class="headerlink" title="std::time_mutex 介绍"></a>std::time_mutex 介绍</h1><p><code>std::time_mutex</code> 比 <code>std::mutex</code> 多了两个成员函数，<code>try_lock_for()，try_lock_until()</code>。</p><h2 id="try-lock-for"><a href="#try-lock-for" class="headerlink" title="try_lock_for()"></a>try_lock_for()</h2><p><code>try_lock_for</code> 函数接受一个时间范围，表示在这一段时间范围之内线程如果没有获得锁则被阻塞住（与 std::mutex 的 try_lock() 不同，try_lock 如果被调用时没有获得锁则直接返回 false），如果在此期间其他线程释放了锁，则该线程可以获得对互斥量的锁，如果超时（即在指定时间内还是没有获得锁），则返回 false。</p><p><strong>try_lock_for() —</strong>Example(<a href="http://www.cplusplus.com/reference/mutex/timed_mutex/try_lock_for/" target="_blank" rel="noopener">reference</a>) </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;       // std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;         // std::chrono::milliseconds</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;         // std::thread</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;          // std::timed_mutex</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::timed_mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fireworks</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// waiting to get a lock: each thread prints "-" every 200ms:</span></span><br><span class="line">  <span class="keyword">while</span> (!mtx.try_lock_for(<span class="built_in">std</span>::chrono::milliseconds(<span class="number">200</span>))) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"-"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// got a lock! - wait for 1s, then this thread prints "*"</span></span><br><span class="line">  <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::milliseconds(<span class="number">1000</span>));</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"*\n"</span>;</span><br><span class="line">  mtx.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::thread threads[<span class="number">5</span>];</span><br><span class="line">  <span class="comment">// spawn 5 threads:</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i)</span><br><span class="line">    threads[i] = <span class="built_in">std</span>::thread(fireworks);</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; th : threads) th.join();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">----------------*</span><br><span class="line">---------------*</span><br><span class="line">----------*</span><br><span class="line">-----*</span><br><span class="line">*</span><br></pre></td></tr></table></figure><h2 id="try-lock-until"><a href="#try-lock-until" class="headerlink" title="try_lock_until()"></a>try_lock_until()</h2><p><code>try_lock_until</code> 函数则接受一个时间点作为参数，在指定时间点未到来之前线程如果没有获得锁则被阻塞住，如果在此期间其他线程释放了锁，则该线程可以获得对互斥量的锁，如果超时（即在指定时间内还是没有获得锁），则返回 false。</p><h1 id="std-lock-guard-介绍"><a href="#std-lock-guard-介绍" class="headerlink" title="std::lock_guard 介绍"></a>std::lock_guard 介绍</h1><p>与 Mutex RAII 相关，方便线程对互斥量上锁。</p><p>Example(<a href="http://www.cplusplus.com/reference/mutex/lock_guard/" target="_blank" rel="noopener">reference</a>):</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;       // std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;         // std::thread</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;          // std::mutex, std::lock_guard</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;      // std::logic_error</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_even</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x%<span class="number">2</span>==<span class="number">0</span>) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">" is even\n"</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">throw</span> (<span class="built_in">std</span>::logic_error(<span class="string">"not even"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_thread_id</span> <span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// using a local lock_guard to lock mtx guarantees unlocking on destruction / exception:</span></span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lck (mtx);</span><br><span class="line">        print_even(id);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (<span class="built_in">std</span>::logic_error&amp;) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"[exception caught]\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::thread threads[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">// spawn 10 threads:</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i)</span><br><span class="line">        threads[i] = <span class="built_in">std</span>::thread(print_thread_id,i+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; th : threads) th.join();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[exception caught]</span><br><span class="line">2 is even</span><br><span class="line">[exception caught]</span><br><span class="line">4 is even</span><br><span class="line">[exception caught]</span><br><span class="line">6 is even</span><br><span class="line">[exception caught]</span><br><span class="line">8 is even</span><br><span class="line">[exception caught]</span><br><span class="line">10 is even</span><br></pre></td></tr></table></figure><h1 id="std-unique-lock-介绍"><a href="#std-unique-lock-介绍" class="headerlink" title="std::unique_lock 介绍"></a>std::unique_lock 介绍</h1><p>与 Mutex RAII 相关，方便线程对互斥量上锁，但提供了更好的上锁和解锁控制。</p><p>Example(<a href="http://www.cplusplus.com/reference/mutex/unique_lock/" target="_blank" rel="noopener">reference</a>):</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;       // std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;         // std::thread</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;          // std::mutex, std::unique_lock</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::mutex mtx;           <span class="comment">// mutex for critical section</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_block</span> <span class="params">(<span class="keyword">int</span> n, <span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// critical section (exclusive access to std::cout signaled by lifetime of lck):</span></span><br><span class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lck (mtx);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; ++i) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">th1</span> <span class="params">(print_block,<span class="number">50</span>,<span class="string">'*'</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">th2</span> <span class="params">(print_block,<span class="number">50</span>,<span class="string">'$'</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    th1.join();</span><br><span class="line">    th2.join();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">**************************************************</span><br><span class="line"><span class="meta">$</span><span class="bash">$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$</span></span><br></pre></td></tr></table></figure><h1 id="std-lock-介绍"><a href="#std-lock-介绍" class="headerlink" title="std::lock 介绍"></a>std::lock 介绍</h1><p>Example(<a href="http://www.cplusplus.com/reference/mutex/lock/" target="_blank" rel="noopener">reference</a>):</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// std::lock example</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;       // std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;         // std::thread</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;          // std::mutex, std::lock</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::mutex foo,bar;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task_a</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// foo.lock(); bar.lock(); // replaced by:</span></span><br><span class="line">  <span class="built_in">std</span>::lock (foo,bar);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"task a\n"</span>;</span><br><span class="line">  foo.unlock();</span><br><span class="line">  bar.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task_b</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// bar.lock(); foo.lock(); // replaced by:</span></span><br><span class="line">  <span class="built_in">std</span>::lock (bar,foo);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"task b\n"</span>;</span><br><span class="line">  bar.unlock();</span><br><span class="line">  foo.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="function">thread <span class="title">th1</span> <span class="params">(task_a)</span></span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="function">thread <span class="title">th2</span> <span class="params">(task_b)</span></span>;</span><br><span class="line"></span><br><span class="line">  th1.join();</span><br><span class="line">  th2.join();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Possible output (order of lines may vary):</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">task a</span><br><span class="line">task b</span><br></pre></td></tr></table></figure><h1 id="std-try-lock-介绍"><a href="#std-try-lock-介绍" class="headerlink" title="std::try_lock 介绍"></a>std::try_lock 介绍</h1><p>尝试lock，若线程不可被lock返回false，否则进行lock。</p><p>Example(<a href="http://www.cplusplus.com/reference/mutex/try_lock/" target="_blank" rel="noopener">reference</a>):</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;       // std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;         // std::thread</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;          // std::mutex, std::try_lock</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::mutex foo,bar;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task_a</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  foo.lock();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"task a\n"</span>;</span><br><span class="line">  bar.lock();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  foo.unlock();</span><br><span class="line">  bar.unlock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task_b</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> x = try_lock(bar,foo);</span><br><span class="line">  <span class="keyword">if</span> (x==<span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"task b\n"</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    bar.unlock();</span><br><span class="line">    foo.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"[task b failed: mutex "</span> &lt;&lt; (x?<span class="string">"foo"</span>:<span class="string">"bar"</span>) &lt;&lt; <span class="string">" locked]\n"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="function">thread <span class="title">th1</span> <span class="params">(task_a)</span></span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="function">thread <span class="title">th2</span> <span class="params">(task_b)</span></span>;</span><br><span class="line"></span><br><span class="line">  th1.join();</span><br><span class="line">  th2.join();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">task a</span><br><span class="line">[task b failed: mutex foo locked]</span><br></pre></td></tr></table></figure><h1 id="std-call-once-介绍"><a href="#std-call-once-介绍" class="headerlink" title="std::call_once 介绍"></a>std::call_once 介绍</h1><p>call_once可以很好的满足，某些场景下，我们需要代码只被执行一次，比如单例类的初始化，考虑到多线程安全，需要进行加锁控制。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Fn</span>, <span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">call_once</span> (<span class="title">once_flag</span>&amp; <span class="title">flag</span>, <span class="title">Fn</span>&amp;&amp; <span class="title">fn</span>, <span class="title">Args</span>&amp;&amp;... <span class="title">args</span>);</span></span><br></pre></td></tr></table></figure><ul><li><p>第一个参数是<code>std::once_flag</code>的对象(once_flag是不允许修改的，其拷贝构造函数和operator=函数都声明为delete)，</p></li><li><p>第二个参数可调用实体，即要求只执行一次的代码，后面可变参数是其参数列表。</p></li></ul><p>call_once保证函数fn只被执行一次，如果有多个线程同时执行函数fn调用，则只有一个活动线程(active call)会执行函数，其他的线程在这个线程执行返回之前会处于”passive execution”(被动执行状态)——不会直接返回，直到活动线程对fn调用结束才返回。对于所有调用函数fn的并发线程，数据可见性都是同步的(一致的)。</p><p>如果活动线程在执行fn时抛出异常，则会从处于”passive execution”状态的线程中挑一个线程成为活动线程继续执行fn，依此类推。一旦活动线程返回，所有”passive execution”状态的线程也返回,不会成为活动线程。(实际上once_flag相当于一个锁，使用它的线程都会在上面等待，只有一个线程允许执行。如果该线程抛出异常，那么从等待中的线程中选择一个，重复上面的流程)。</p><p>还有一个要注意的地方是 once_flag的生命周期，它必须要比使用它的线程的生命周期要长。所以通常定义成全局变量比较好。</p><p>Example(<a href="http://www.cplusplus.com/reference/mutex/call_once/" target="_blank" rel="noopener">reference</a>)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// call_once example</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;       // std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;         // std::thread, std::this_thread::sleep_for</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;         // std::chrono::milliseconds</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;          // std::call_once, std::once_flag</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> winner;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_winner</span> <span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; winner = x; &#125;</span><br><span class="line"><span class="built_in">std</span>::once_flag winner_flag;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait_1000ms</span> <span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// count to 1000, waiting 1ms between increments:</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; ++i)</span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::milliseconds(<span class="number">1</span>));</span><br><span class="line">  <span class="comment">// claim to be the winner (only the first such call is executed):</span></span><br><span class="line">  <span class="built_in">std</span>::call_once (winner_flag,set_winner,id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::thread threads[<span class="number">10</span>];</span><br><span class="line">  <span class="comment">// spawn 10 threads:</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i)</span><br><span class="line">    threads[i] = <span class="built_in">std</span>::thread(wait_1000ms,i+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"waiting for the first among 10 threads to count 1000 ms...\n"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; th : threads) th.join();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"winner thread: "</span> &lt;&lt; winner &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">waiting for the first among 10 threads to count 1000 ms...</span><br><span class="line">winner thread: 2</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Mutex&lt;/strong&gt;又称为互斥量，C++ 11中与 Mutex 相关的类（包括锁类型）和函数都声明在&lt;code&gt;&amp;lt;mutex&amp;gt;&lt;/code&gt; 头文件中，所以如果你需要使用 std::mutex，就必须包含 &lt;code&gt;&amp;lt;mutex&amp;
      
    
    </summary>
    
      <category term="Cpp" scheme="https://loopvoid.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://loopvoid.github.io/tags/Cpp/"/>
    
      <category term="Thread" scheme="https://loopvoid.github.io/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>C++并发学习笔记(二)(std::thread 详解)</title>
    <link href="https://loopvoid.github.io/2018/03/17/C-%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C-std-thread-%E8%AF%A6%E8%A7%A3/"/>
    <id>https://loopvoid.github.io/2018/03/17/C-并发学习笔记-二-std-thread-详解/</id>
    <published>2018-03-17T07:01:18.000Z</published>
    <updated>2019-08-06T06:59:03.700Z</updated>
    
    <content type="html"><![CDATA[<h1 id="std-thread-构造"><a href="#std-thread-构造" class="headerlink" title="std::thread 构造"></a>std::thread 构造</h1><p>std::thread 在<code>&lt;thread&gt;</code> 头文件中声明，因此使用 <code>std::thread</code>时需要包含<code>&lt;thread&gt;</code>头文件。</p><table><thead><tr><th align="left">default</th><th align="left">thread() noexcept;</th><th align="left">默认构造函数，创建一个空的 thread 执行对象</th></tr></thead><tbody><tr><td align="left">initialization</td><td align="left">template &lt;class Fn, class… Args&gt; explicit thread (Fn&amp;&amp; fn, Args&amp;&amp;… args);</td><td align="left">初始化构造函数，创建一个 thread对象，该 thread对象可被 joinable，新产生的线程会调用 fn 函数，该函数的参数由 args 给出。</td></tr><tr><td align="left">copy [deleted]</td><td align="left">thread (const thread&amp;) = delete;</td><td align="left">拷贝构造函数(被禁用)，意味着 thread 不可被拷贝构造。</td></tr><tr><td align="left">move</td><td align="left">thread (thread&amp;&amp; x) noexcept;</td><td align="left">move 构造函数，move 构造函数，调用成功之后 x 不代表任何 thread 执行对象</td></tr></tbody></table><p>注意：可被 joinable 的 thread 对象必须在他们销毁之前被主线程 join 或者将其设置为 detached.</p><p>Example (<a href="http://en.cppreference.com/w/cpp/thread/thread/thread" target="_blank" rel="noopener">reference</a>)：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Thread 1 executing\n"</span>;</span><br><span class="line">        ++n;</span><br><span class="line">        <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::milliseconds(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span>&amp; n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Thread 2 executing\n"</span>;</span><br><span class="line">        ++n;</span><br><span class="line">        <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::milliseconds(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">std</span>::thread t1; <span class="comment">// t1 is not a thread</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t2</span><span class="params">(f1, n + <span class="number">1</span>)</span></span>; <span class="comment">// pass by value</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t3</span><span class="params">(f2, <span class="built_in">std</span>::ref(n))</span></span>; <span class="comment">// pass by reference</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t4</span><span class="params">(<span class="built_in">std</span>::move(t3))</span></span>; <span class="comment">// t4 is now running f2(). t3 is no longer a thread</span></span><br><span class="line">    t2.join();</span><br><span class="line">    t4.join();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Final value of n is "</span> &lt;&lt; n &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Thread 1 executing</span><br><span class="line">Thread 2 executing</span><br><span class="line">Thread 1 executing</span><br><span class="line">Thread 2 executing</span><br><span class="line">Thread 1 executing</span><br><span class="line">Thread 2 executing</span><br><span class="line">Thread 1 executing</span><br><span class="line">Thread 2 executing</span><br><span class="line">Thread 1 executing</span><br><span class="line">Thread 2 executing</span><br><span class="line">Final value of n is 5</span><br></pre></td></tr></table></figure><h1 id="move-赋值操作"><a href="#move-赋值操作" class="headerlink" title="move 赋值操作"></a>move 赋值操作</h1><table><thead><tr><th>move</th><th><code>thread&amp; operator= (thread&amp;&amp; rhs) noexcept;</code></th><th>move 赋值操作，如果当前对象不可 joinable，需要传递一个右值引用(rhs)给 move 赋值操作；如果当前对象可被 joinable，则 terminate() 报错。</th></tr></thead><tbody><tr><td>copy [deleted]</td><td><code>thread&amp; operator= (const thread&amp;) = delete;</code></td><td>拷贝赋值操作被禁用，thread 对象不可被拷贝。</td></tr></tbody></table><p>Example :</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sub_task</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::milliseconds(n));</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello world "</span> </span><br><span class="line">&lt;&lt; <span class="built_in">std</span>::this_thread::get_id()</span><br><span class="line">&lt;&lt; <span class="string">" paused "</span> &lt;&lt; n &lt;&lt; <span class="string">" milliseconds"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::thread threads[<span class="number">5</span>];</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Spawning 5 threads...\n"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">threads[i] = <span class="built_in">std</span>::thread(sub_task, i);</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Done spawning threads! Now wait for them to join\n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;t : threads)</span><br><span class="line">t.join();</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"All threads joined.\n"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="其他成员函数"><a href="#其他成员函数" class="headerlink" title="其他成员函数"></a>其他成员函数</h1><h2 id="get-id"><a href="#get-id" class="headerlink" title="get_id"></a>get_id</h2><p><a href="http://www.cplusplus.com/reference/thread/thread/get_id/" target="_blank" rel="noopener"><strong>get_id</strong></a>获取线程 ID<br>若该线程是joinable的，该函数返回该线程ID<br>若该线程不是joinable的，该函数返回成员默认类型<a href="http://www.cplusplus.com/thread::id" target="_blank" rel="noopener"><strong>thread::id</strong></a></p><p>Example：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// thread::get_id / this_thread::get_id</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;       // std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;         // std::thread, std::thread::id, std::this_thread::get_id</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;         // std::chrono::seconds</span></span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::thread::id main_thread_id = <span class="built_in">std</span>::this_thread::get_id();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">is_main_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( main_thread_id == <span class="built_in">std</span>::this_thread::get_id() )</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"This is the main thread.\n"</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"This is not the main thread.\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  is_main_thread();</span><br><span class="line">  <span class="built_in">std</span>::<span class="function">thread <span class="title">th</span> <span class="params">(is_main_thread)</span></span>;</span><br><span class="line">  th.join();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">This is the main thread.</span><br><span class="line">This is not the main thread.</span><br></pre></td></tr></table></figure><h2 id="joinable"><a href="#joinable" class="headerlink" title="joinable"></a>joinable</h2><p><a href="http://www.cplusplus.com/reference/thread/thread/joinable/" target="_blank" rel="noopener"><strong>joinable</strong></a>    检查线程是否可被 join</p><p>线程可被join：当其为可执行线程时。</p><p>线程不可被join：</p><ul><li>1、线程是<strong><a href="http://www.cplusplus.com/thread::thread" target="_blank" rel="noopener">default-constructed</a></strong>(默认构造)</li><li>2、当其被moved</li><li>3、当其成员<strong>join</strong>或<strong>detach</strong>被调用时</li></ul><p>当去销毁一个仍然可以“joinable”的C++线程对象会被认为是一种错误。为了销毁一个C++线程对象，约么join()函数需要被调用（并结束），要么detach()函数被调用。如果一个C++线程对象当销毁时仍然可以被join，异常会被抛出。</p><p>Example:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;       // std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;         // std::thread</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mythread</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// do stuff...</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::thread foo;</span><br><span class="line">  <span class="built_in">std</span>::<span class="function">thread <span class="title">bar</span><span class="params">(mythread)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Joinable after construction:\n"</span> &lt;&lt; <span class="built_in">std</span>::boolalpha;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"foo: "</span> &lt;&lt; foo.joinable() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"bar: "</span> &lt;&lt; bar.joinable() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (foo.joinable()) foo.join();</span><br><span class="line">  <span class="keyword">if</span> (bar.joinable()) bar.join();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Joinable after joining:\n"</span> &lt;&lt; <span class="built_in">std</span>::boolalpha;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"foo: "</span> &lt;&lt; foo.joinable() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"bar: "</span> &lt;&lt; bar.joinable() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output(after 3 seconds):</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Joinable after construction:</span><br><span class="line">foo: false</span><br><span class="line">bar: true</span><br><span class="line">Joinable after joining:</span><br><span class="line">foo: false</span><br><span class="line">bar: false</span><br></pre></td></tr></table></figure><h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><p><a href="http://www.cplusplus.com/reference/thread/thread/join/" target="_blank" rel="noopener"><strong>join</strong></a>Join线程</p><p>当thread::join()函数被调用后，调用它的线程会被block，直到线程的执行被完成。基本上，这是一种可以用来知道一个线程已结束的机制。当thread::join()返回时，OS的执行的线程已经完成，C++线程对象可以被销毁。</p><p>Exapmle:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;       // std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;         // std::thread, std::this_thread::sleep_for</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;         // std::chrono::seconds</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pause_thread</span><span class="params">(<span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::this_thread::sleep_for (<span class="built_in">std</span>::chrono::seconds(n));</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"pause of "</span> &lt;&lt; n &lt;&lt; <span class="string">" seconds ended\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Spawning 3 threads...\n"</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="function">thread <span class="title">t1</span> <span class="params">(pause_thread,<span class="number">1</span>)</span></span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="function">thread <span class="title">t2</span> <span class="params">(pause_thread,<span class="number">2</span>)</span></span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="function">thread <span class="title">t3</span> <span class="params">(pause_thread,<span class="number">3</span>)</span></span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Done spawning threads. Now waiting for them to join:\n"</span>;</span><br><span class="line">  t1.join();</span><br><span class="line">  t2.join();</span><br><span class="line">  t3.join();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"All threads joined!\n"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output (after 3 seconds):</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Spawning 3 threads...</span><br><span class="line">Done spawning threads. Now waiting for them to join:</span><br><span class="line">pause of 1 seconds ended</span><br><span class="line">pause of 2 seconds ended</span><br><span class="line">pause of 3 seconds ended</span><br><span class="line">All threads joined!</span><br></pre></td></tr></table></figure><h2 id="detach"><a href="#detach" class="headerlink" title="detach"></a>detach</h2><p><a href="http://www.cplusplus.com/reference/thread/thread/detach/" target="_blank" rel="noopener"><strong>detach</strong></a>Detach线程</p><p>detach允许线程独立运行，线程结束，资源会释放。</p><p>当thread::detach()函数被调用后，执行的线程从线程对象中被分离，已不再被一个线程对象所表达–这是两个独立的事情。C++线程对象可以被销毁，同时OS执行的线程可以继续。如果程序想要知道执行的线程何时结束，就需要一些其它的机制。join()函数在那个thread对象上不能再被调用，因为它已经不再和一个执行的线程相关联。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;       // std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;         // std::thread, std::this_thread::sleep_for</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;         // std::chrono::seconds</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pause_thread</span><span class="params">(<span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::this_thread::sleep_for (<span class="built_in">std</span>::chrono::seconds(n));</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"pause of "</span> &lt;&lt; n &lt;&lt; <span class="string">" seconds ended\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Spawning and detaching 3 threads...\n"</span>;</span><br><span class="line">  <span class="built_in">std</span>::thread (pause_thread,<span class="number">1</span>).detach();</span><br><span class="line">  <span class="built_in">std</span>::thread (pause_thread,<span class="number">2</span>).detach();</span><br><span class="line">  <span class="built_in">std</span>::thread (pause_thread,<span class="number">3</span>).detach();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Done spawning threads.\n"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"(the main thread will now pause for 5 seconds)\n"</span>;</span><br><span class="line">  <span class="comment">// give the detached threads time to finish (but not guaranteed!):</span></span><br><span class="line">  pause_thread(<span class="number">5</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Spawning and detaching 3 threads...</span><br><span class="line">Done spawning threads.</span><br><span class="line">(the main thread will now pause for 5 seconds)</span><br><span class="line">pause of 1 seconds ended</span><br><span class="line">pause of 2 seconds ended</span><br><span class="line">pause of 3 seconds ended</span><br><span class="line">pause of 5 seconds ended</span><br></pre></td></tr></table></figure><h2 id="swap"><a href="#swap" class="headerlink" title="swap"></a>swap</h2><p><a href="http://www.cplusplus.com/reference/thread/thread/swap/" target="_blank" rel="noopener"><strong>swap</strong></a>Swap线程</p><p>互换两个 thread 对象的底层句柄</p><p>Example:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t1</span><span class="params">(foo)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t2</span><span class="params">(bar)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"thread 1 id: "</span> &lt;&lt; t1.get_id() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"thread 2 id: "</span> &lt;&lt; t2.get_id() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::swap(t1, t2);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"after std::swap(t1, t2):"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"thread 1 id: "</span> &lt;&lt; t1.get_id() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"thread 2 id: "</span> &lt;&lt; t2.get_id() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    t1.swap(t2);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"after t1.swap(t2):"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"thread 1 id: "</span> &lt;&lt; t1.get_id() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"thread 2 id: "</span> &lt;&lt; t2.get_id() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">thread 1 id: 1892</span><br><span class="line">thread 2 id: 2584</span><br><span class="line">after std::swap(t1, t2):</span><br><span class="line">thread 1 id: 2584</span><br><span class="line">thread 2 id: 1892</span><br><span class="line">after t1.swap(t2):</span><br><span class="line">thread 1 id: 1892</span><br><span class="line">thread 2 id: 2584</span><br></pre></td></tr></table></figure><h2 id="native-handle"><a href="#native-handle" class="headerlink" title="native_handle"></a>native_handle</h2><p><a href="http://www.cplusplus.com/reference/thread/thread/native_handle/" target="_blank" rel="noopener"><strong>native_handle</strong></a>返回 native handle 表示线程的实现定义句柄类型</p><p>Example: 在 POSIX 系统上用 native_handle 启用 C++ 线程的实时调度</p><p>只有库函数支持该函数时该方法才会有效，用于获得与操作系统相关的原生线程句柄</p><p>Example:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;  </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"n="</span>&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="function">thread <span class="title">t</span><span class="params">(show,<span class="number">18</span>)</span></span>;  </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"t.get_id="</span>&lt;&lt;t.get_id()&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">    <span class="keyword">auto</span> tn=t.native_handle();  </span><br><span class="line">    t.join();  </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"tn="</span>&lt;&lt;tn&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t.get_id=n=2</span><br><span class="line">18</span><br><span class="line">tn=2</span><br></pre></td></tr></table></figure><h2 id="hardware-concurrency-static"><a href="#hardware-concurrency-static" class="headerlink" title="hardware_concurrency [static]"></a>hardware_concurrency [static]</h2><p><a href="http://www.cplusplus.com/reference/thread/thread/hardware_concurrency/" target="_blank" rel="noopener"><strong>hardware_concurrency (static)</strong></a>检测硬件并发特性</p><p>公共静态成员函数、检测硬件的并发特性、返回硬件线程上下文的数量</p><p>返回值：支持的并发线程数。若值不可计算，则返回 0；</p><p>Example:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> n = <span class="built_in">std</span>::thread::hardware_concurrency();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">" concurrent threads are supported.\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8 concurrent threads are supported.</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;std-thread-构造&quot;&gt;&lt;a href=&quot;#std-thread-构造&quot; class=&quot;headerlink&quot; title=&quot;std::thread 构造&quot;&gt;&lt;/a&gt;std::thread 构造&lt;/h1&gt;&lt;p&gt;std::thread 在&lt;code&gt;&amp;lt;t
      
    
    </summary>
    
      <category term="Cpp" scheme="https://loopvoid.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://loopvoid.github.io/tags/Cpp/"/>
    
      <category term="Thread" scheme="https://loopvoid.github.io/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>C++并发学习笔记(一)</title>
    <link href="https://loopvoid.github.io/2018/03/17/C-%E5%B9%B6%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/"/>
    <id>https://loopvoid.github.io/2018/03/17/C-并发学习笔记-一/</id>
    <published>2018-03-17T06:47:18.000Z</published>
    <updated>2019-08-06T06:57:39.128Z</updated>
    
    <content type="html"><![CDATA[<h1 id="资料汇总"><a href="#资料汇总" class="headerlink" title="资料汇总"></a>资料汇总</h1><p><a href="http://www.open-std.org/jtc1/sc22/wg21/" target="_blank" rel="noopener">http://www.open-std.org/jtc1/sc22/wg21/</a></p><p>C++0x/C++11 Support in GCC：<a href="http://gcc.gnu.org/projects/cxx0x.html" target="_blank" rel="noopener">http://gcc.gnu.org/projects/cxx0x.html</a></p><p>What is C++0x：<a href="https://www2.research.att.com/~bs/what-is-2009.pdf" target="_blank" rel="noopener">https://www2.research.att.com/~bs/what-is-2009.pdf</a></p><p>Overview of the New C++：<a href="http://www.artima.com/shop/overview_of_the_new_cpp" target="_blank" rel="noopener">http://www.artima.com/shop/overview_of_the_new_cpp</a></p><p>Overview of the New C++ (C++0x).pdf：<a href="http://ishare.iask.sina.com.cn/f/20120005.html?from=like" target="_blank" rel="noopener">http://ishare.iask.sina.com.cn/f/20120005.html?from=like</a></p><p>A Brief Look at C++0x：<a href="http://www.artima.com/cppsource/cpp0x.html" target="_blank" rel="noopener">http://www.artima.com/cppsource/cpp0x.html</a></p><p>Summary of C++11 Feature Availability in gcc and MSVC：<a href="http://www.aristeia.com/C++11/C++11FeatureAvailability.htm" target="_blank" rel="noopener">http://www.aristeia.com/C++11/C++11FeatureAvailability.htm</a></p><p>C++ 11: Come Closer：<a href="http://www.codeproject.com/Articles/344282/Cplusplus-11-Come-Closer" target="_blank" rel="noopener">http://www.codeproject.com/Articles/344282/Cplusplus-11-Come-Closer</a></p><p>C++11 threads, locks and condition variables： <a href="http://www.codeproject.com/Articles/598695/Cplusplus11-threads-locks-and-condition-variables" target="_blank" rel="noopener">http://www.codeproject.com/Articles/598695/Cplusplus11-threads-locks-and-condition-variables</a></p><p>Move Semantics and Perfect Forwarding in C++11：<a href="http://www.codeproject.com/Articles/397492/Move-Semantics-and-Perfect-Forwarding-in-Cplusplus" target="_blank" rel="noopener">http://www.codeproject.com/Articles/397492/Move-Semantics-and-Perfect-Forwarding-in-Cplusplus</a></p><p><a href="http://solarianprogrammer.com/categories/C++11/" target="_blank" rel="noopener">http://solarianprogrammer.com/categories/C++11/</a></p><p>C++11 Concurrency：<a href="http://www.baptiste-wicht.com/2012/03/cpp11-concurrency-part1-start-threads/" target="_blank" rel="noopener">http://www.baptiste-wicht.com/2012/03/cpp11-concurrency-part1-start-threads/</a></p><p><a href="http://www.hpl.hp.com/personal/Hans_Boehm/misc_slides/sfacm-cleaned.pdf" target="_blank" rel="noopener">http://www.hpl.hp.com/personal/Hans_Boehm/misc_slides/sfacm-cleaned.pdf</a></p><p><a href="http://en.cppreference.com/w/cpp/thread" target="_blank" rel="noopener">http://en.cppreference.com/w/cpp/thread</a></p><p><a href="http://isocpp.org/blog/2012/12/c11-a-cheat-sheet-alex-sinyakov" target="_blank" rel="noopener">http://isocpp.org/blog/2012/12/c11-a-cheat-sheet-alex-sinyakov</a></p><p>The Biggest Changes in C++11：<a href="http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/" target="_blank" rel="noopener">http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/</a></p><p>Ten C++11 Features Every C++ Developer Should Use：<a href="http://www.codeproject.com/Articles/570638/Ten-Cplusplus11-Features-Every-Cplusplus-Developer" target="_blank" rel="noopener">http://www.codeproject.com/Articles/570638/Ten-Cplusplus11-Features-Every-Cplusplus-Developer</a></p><p> C++11 – A Glance [part 1 of n]：<a href="http://www.codeproject.com/Articles/312029/Cplusplus11-A-Glance-part-1-of-n" target="_blank" rel="noopener">http://www.codeproject.com/Articles/312029/Cplusplus11-A-Glance-part-1-of-n</a></p><p> C++11 – A Glance [part 2 of n]：<a href="http://www.codeproject.com/Articles/314415/Cplusplus11-A-Glance-part-2-of-n" target="_blank" rel="noopener">http://www.codeproject.com/Articles/314415/Cplusplus11-A-Glance-part-2-of-n</a></p><p>C++11（及现代C++风格）和快速迭代式开发：<a href="http://mindhacks.cn/2012/08/27/modern-cpp-practices/" target="_blank" rel="noopener">http://mindhacks.cn/2012/08/27/modern-cpp-practices/</a></p><p>Lambda Functions in C++11 - the Definitive Guide：<a href="http://www.cprogramming.com/c++11/c++11-lambda-closures.html" target="_blank" rel="noopener">http://www.cprogramming.com/c++11/c++11-lambda-closures.html</a></p><p>Better types in C++11 - nullptr, enum classes (strongly typed enumerations) and cstdint：<a href="http://www.cprogramming.com/c++11/c++11-nullptr-strongly-typed-enum-class.html" target="_blank" rel="noopener">http://www.cprogramming.com/c++11/c++11-nullptr-strongly-typed-enum-class.html</a></p><p>Rvalue-references-and-move-semantics-in-c++11：<a href="http://www.cprogramming.com/c++11/rvalue-references-and-move-semantics-in-c++11.html" target="_blank" rel="noopener">http://www.cprogramming.com/c++11/rvalue-references-and-move-semantics-in-c++11.html</a></p><p><a href="http://www.gotw.ca/publications/index.htm" target="_blank" rel="noopener">http://www.gotw.ca/publications/index.htm</a></p><p><a href="http://www.devx.com/SpecialReports/Door/38865" target="_blank" rel="noopener">http://www.devx.com/SpecialReports/Door/38865</a></p><p>Multi-threading in C++0x：<a href="http://accu.org/index.php/journals/1584" target="_blank" rel="noopener">http://accu.org/index.php/journals/1584</a></p><p>C++ 0X feature summary cheat sheat：<a href="http://www.iesensor.com/blog/2011/05/31/c-0x-feature-summary-cheat-sheat/" target="_blank" rel="noopener">http://www.iesensor.com/blog/2011/05/31/c-0x-feature-summary-cheat-sheat/</a></p><p>Multithreading in C++0x part 1: Starting Threads：<a href="http://www.justsoftwaresolutions.co.uk/threading/multithreading-in-c++0x-part-1-starting-threads.html" target="_blank" rel="noopener">http://www.justsoftwaresolutions.co.uk/threading/multithreading-in-c++0x-part-1-starting-threads.html</a></p><p><a href="http://en.cppreference.com/w/cpp/thread" target="_blank" rel="noopener">http://en.cppreference.com/w/cpp/thread</a></p><p><a href="http://www.cplusplus.com/reference/multithreading/" target="_blank" rel="noopener">http://www.cplusplus.com/reference/multithreading/</a></p><h1 id="与-C-11-多线程相关的头文件"><a href="#与-C-11-多线程相关的头文件" class="headerlink" title="与 C++11 多线程相关的头文件"></a>与 C++11 多线程相关的头文件</h1><p>C++11 新标准中引入了四个头文件来支持多线程编程，他们分别是<code>&lt;atomic&gt;</code> ,<code>&lt;thread&gt;</code>,<code>&lt;mutex&gt;</code>,<code>&lt;condition_variable&gt;</code>和<code>&lt;future&gt;</code>。</p><ul><li><code>&lt;atomic&gt;</code>：该头文主要声明了两个类, <code>std::atomic</code> 和<code>std::atomic_flag</code>，另外还声明了一套 C 风格的原子类型和与 C 兼容的原子操作的函数。</li><li><code>&lt;thread&gt;</code>：该头文件主要声明了 <code>std::thread</code> 类，另外 <code>std::this_thread</code> 命名空间也在该头文件中。</li><li><code>&lt;mutex&gt;</code>：该头文件主要声明了与<strong>互斥量(mutex)</strong>相关的类，包括 <code>std::mutex</code> 系列类，<code>std::lock_guard</code>, <code>std::unique_lock</code>, 以及其他的类型和函数。</li><li><code>&lt;condition_variable&gt;</code>：该头文件主要声明了与条件变量相关的类，包括 <code>std::condition_variable</code> 和 <code>std::condition_variable_any</code>。</li><li><code>&lt;future&gt;</code>：该头文件主要声明了 <code>std::promise</code>, <code>std::package_task</code> 两个 Provider 类，以及 <code>std::future</code> 和 <code>std::shared_future</code> 两个 Future 类，另外还有一些与之相关的类型和函数，<code>std::async()</code> 函数就声明在此头文件中。</li></ul><h1 id="多线程Hello-World"><a href="#多线程Hello-World" class="headerlink" title="多线程Hello World!"></a>多线程Hello World!</h1><p>Example 1：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sub_task</span><span class="params">()</span></span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello world"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">t</span><span class="params">(sub_task)</span></span>;</span><br><span class="line">t.join();</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Example 2：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i+j &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">uint8_t</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">t</span><span class="params">(output, i, i)</span></span>;</span><br><span class="line">t.detach();</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：<a href="http://www.cnblogs.com/haippy/" target="_blank" rel="noopener">256code</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;资料汇总&quot;&gt;&lt;a href=&quot;#资料汇总&quot; class=&quot;headerlink&quot; title=&quot;资料汇总&quot;&gt;&lt;/a&gt;资料汇总&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/&quot; target=&quot;_bla
      
    
    </summary>
    
      <category term="Cpp" scheme="https://loopvoid.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://loopvoid.github.io/tags/Cpp/"/>
    
      <category term="Thread" scheme="https://loopvoid.github.io/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>Cpp回调函数的方式和作用</title>
    <link href="https://loopvoid.github.io/2018/03/17/Cpp%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%9A%84%E6%96%B9%E5%BC%8F%E5%92%8C%E4%BD%9C%E7%94%A8/"/>
    <id>https://loopvoid.github.io/2018/03/17/Cpp回调函数的方式和作用/</id>
    <published>2018-03-17T05:04:18.000Z</published>
    <updated>2019-08-06T06:56:25.140Z</updated>
    
    <content type="html"><![CDATA[<h1 id="指针函数和函数指针"><a href="#指针函数和函数指针" class="headerlink" title="指针函数和函数指针"></a>指针函数和函数指针</h1><p>谈到回调函数得先区分好<strong>指针函数</strong>和<strong>函数指针。</strong></p><p>##指针函数</p><p><strong>指针函数：</strong>是指带指针的函数，本质是一个<strong>函数</strong>，函数的返回类型是某一类型的指针。</p><p><strong>声明格式：</strong><code>类型标识符 *函数名(参数表)</code></p><p><strong>示例：</strong> <code>int *func(x,y)</code></p><p>首先它是一个函数，只不过这个函数的返回值是一个地址值。函数返回值必须用同类型的指针变量来接受，也就是说，指针函数一定有函数返回值，而且，在主调函数中，函数返回值必须赋给同类型的指针变量。由于返回的是一个地址，所以类型说明符一般都是int。</p><p>函数返回的是一个地址值，经常使用在返回数组的某一元素地址上。</p><p>下面是一个简单的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">get_letter</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> arr[]=&#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>&#125;;</span><br><span class="line">    <span class="keyword">return</span> &amp;arr[num<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (<span class="keyword">char</span>) *get_letter(num) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子函数<code>int *get_letter(int num)</code>返回的是数组某元素的地址。输出的是这个地址里的值。</p><p><code>(char) *get_letter(num)</code>其中(char)是将*get_letter(num)返回的数组某元素的地址里的值转换成char类型输出。</p><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p><strong>函数指针</strong>是指向函数的指针变量<strong>，**</strong>本质是一个指针变量。**</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*f_p)(<span class="keyword">int</span> x);<span class="comment">//声明一个函数指针</span></span><br><span class="line">f_p = func;<span class="comment">//将func函数首地址赋值给指针f_P</span></span><br></pre></td></tr></table></figure><p>指向函数的指针包含了函数的地址的入口地址，可以通过它来调用函数。</p><p><strong>声明格式：</strong><code>类型说明符 (*函数名)(参数)</code></p><p>其实这里不能称为函数名，应该叫做指针的变量名。这个特殊的指针指向一个返回整型值的函数。</p><p>指针的声明必须和它指向函数的声明保持一致。</p><p>指针名和指针运算符外面的括号改变了默认的运算符优先级。如果没有圆括号，就变成了一个返回整型指针的函数原型的声明。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (*f_p)();<span class="comment">//声明一个函数指针，参数列表为控</span></span><br><span class="line"><span class="comment">//把函数的地址赋值给函数指针，可以采用下面两种形式：</span></span><br><span class="line">f_p = &amp;Function;</span><br><span class="line">f_p = Function;</span><br></pre></td></tr></table></figure><p>取地址运算符&amp;不是必需的，因为单单一个函数标识符就标号表示了它的地址.<br>如果是函数调用，还必须包含一个圆括号括起来的参数表。</p><p>可以采用如下两种方式来通过指针调用函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = (*f_p)();</span><br><span class="line">x = f_p;</span><br></pre></td></tr></table></figure><p>下面是一个简单的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span>(*f_p)();</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FileFunc</span><span class="params">()</span></span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"FileFunc"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EditFunc</span><span class="params">()</span></span>&#123;<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"EditFunc"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">f_p = FileFunc;</span><br><span class="line">(*f_p)();<span class="comment">//第一种调用方式</span></span><br><span class="line">f_p =EditFunc;</span><br><span class="line">f_p();<span class="comment">//第二种调用方式</span></span><br><span class="line">    </span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FileFunc</span><br><span class="line">EditFunc</span><br><span class="line">请按任意键继续. . .</span><br></pre></td></tr></table></figure><h1 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h1><p>回调函数是通过<strong>函数指针</strong>调用的函数：把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，就称为回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应。</p><p>引用知乎 <a href="https://www.zhihu.com/question/19801131/answer/13005983" target="_blank" rel="noopener">常溪玲</a>一个形象的示例：</p><p>你到一个商店买东西，刚好你要的东西没有货，于是你在店员那里留下了你的电话，过了几天店里有货了，店员就打了你的电话，然后你接到电话后就到店里去取了货。在这个例子里，你的电话号码就叫<strong>回调函数</strong>，你把电话留给店员就叫<strong>登记回调函数</strong>，店里后来有货了叫做<strong>触发回调关联的事件</strong>，店员给你打电话叫做<strong>调用回调函数</strong>，你到店里去取货叫做<strong>响应回调事件</strong>。</p><p>下面是一个简单的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*Fun_p)</span><span class="params">(<span class="keyword">int</span>)</span></span>;<span class="comment">//定义一个函数指针类型  </span></span><br><span class="line">Fun_p p = <span class="literal">NULL</span>;<span class="comment">//用Fun定义一个变量p，它指向一个返回值为空参数为int的函数  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 向外提供的回调函数注册接口，提供注册登记服务 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerFun</span><span class="params">(Fun_p pCallback)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    p = pCallback;  </span><br><span class="line">    </span><br><span class="line">&#125;  </span><br><span class="line"> <span class="comment">//达成某一条件后，通过名片（函数指针p），传回结果 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trigger</span><span class="params">(<span class="keyword">int</span> result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (*p)(result);<span class="comment">//将result传入当前函数指针(*p)所指向的函数(callback函数)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//回调函数 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callback</span><span class="params">(<span class="keyword">int</span> a)</span> </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"callback result = "</span> &lt;&lt; a &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    registerFun(callback);<span class="comment">//注册回调函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">    trigger(result);<span class="comment">//触发回调函数关联事件</span></span><br><span class="line">      </span><br><span class="line">    system(<span class="string">"pause"</span>); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出：callback result = 1</span><br></pre></td></tr></table></figure><p><code>typedef int (* Fun_p)(void);</code>定义了一个新类型 Fun</p><p><code>Fun_p p = NULL;</code>//用Fun_p定义一个变量p，p的类型是<code>void (*Fun_p)(int)</code>这样一个<strong>函数指针</strong>类型。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;指针函数和函数指针&quot;&gt;&lt;a href=&quot;#指针函数和函数指针&quot; class=&quot;headerlink&quot; title=&quot;指针函数和函数指针&quot;&gt;&lt;/a&gt;指针函数和函数指针&lt;/h1&gt;&lt;p&gt;谈到回调函数得先区分好&lt;strong&gt;指针函数&lt;/strong&gt;和&lt;strong&gt;函
      
    
    </summary>
    
      <category term="Cpp" scheme="https://loopvoid.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://loopvoid.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>Linux多线程编程入门笔记</title>
    <link href="https://loopvoid.github.io/2018/03/16/Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"/>
    <id>https://loopvoid.github.io/2018/03/16/Linux多线程编程入门笔记/</id>
    <published>2018-03-16T14:27:18.000Z</published>
    <updated>2019-08-06T06:46:13.973Z</updated>
    
    <content type="html"><![CDATA[<h2 id="最基础，进程同时创建5个线程，各自调用同一个函数"><a href="#最基础，进程同时创建5个线程，各自调用同一个函数" class="headerlink" title="最基础，进程同时创建5个线程，各自调用同一个函数"></a>最基础，进程同时创建5个线程，各自调用同一个函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; //多线程相关操作头文件，可移植众多平台  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_THREADS 5 <span class="comment">//线程数  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">say_hello</span><span class="params">( <span class="keyword">void</span>* args )</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"hello..."</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125; <span class="comment">//函数返回的是函数指针，便于后面作为参数  </span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">pthread_t</span> tids[NUM_THREADS]; <span class="comment">//线程id  </span></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; ++i )  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">int</span> ret = pthread_create( &amp;tids[i], <span class="literal">NULL</span>, say_hello, <span class="literal">NULL</span> ); <span class="comment">//参数：创建的线程id，线程参数，线程运行函数的起始地址，运行函数的参数  </span></span><br><span class="line">        <span class="keyword">if</span>( ret != <span class="number">0</span> ) <span class="comment">//创建线程成功返回0  </span></span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"pthread_create error:error_code="</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    pthread_exit( <span class="literal">NULL</span> ); <span class="comment">//等待各个线程退出后，进程才结束，否则进程强制结束，线程处于未终止的状态 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入命令：<code>g++ pthread_chap1.cpp -o pthread_chap1 -lpthread</code></p><p>注意:</p><blockquote><ul><li>此为c++程序，故用g++来编译生成可执行文件，并且要调用处理多线程操作相关的静态链接库文件pthread。</li><li>-lpthread 编译选项到位置可任意，如g++ -o pthread_chap1 pthread_chap1.cpp -lpthread</li><li>​</li></ul></blockquote><p>测试结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">jack@jack:~/coding/muti_thread$ ./pthread_chap1 </span><br><span class="line">hello...hello...  </span><br><span class="line">hello...  </span><br><span class="line">hello...  </span><br><span class="line">  </span><br><span class="line">hello... </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">jack@jack:~/coding/muti_thread$ ./pthread_chap1 </span><br><span class="line">hello...hello...hello...  </span><br><span class="line">hello...  </span><br><span class="line">  </span><br><span class="line">hello...</span><br></pre></td></tr></table></figure><p>可知，两次运行的结果会有差别，这不是多线程的特点吧？这显然没有同步？还有待进一步探索…<br>多线程的运行是混乱的，混乱就是正常？</p><h2 id="线程调用到函数在一个类中，那必须将该函数声明为静态函数函数"><a href="#线程调用到函数在一个类中，那必须将该函数声明为静态函数函数" class="headerlink" title="线程调用到函数在一个类中，那必须将该函数声明为静态函数函数"></a>线程调用到函数在一个类中，那必须将该函数声明为静态函数函数</h2><p>因为静态成员函数属于静态全局区，线程可以共享这个区域，故可以各自调用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_THREADS 5  </span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">say_hello</span><span class="params">( <span class="keyword">void</span>* args )</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"hello..."</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">pthread_t</span> tids[NUM_THREADS];  </span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; ++i )  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">int</span> ret = pthread_create( &amp;tids[i], <span class="literal">NULL</span>, Hello::say_hello, <span class="literal">NULL</span> );  </span><br><span class="line">        <span class="keyword">if</span>( ret != <span class="number">0</span> )  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"pthread_create error:error_code"</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    pthread_exit( <span class="literal">NULL</span> );  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jack@jack:~/coding/muti_thread$ ./pthread_chap2</span><br><span class="line">hello...hello...hello...  </span><br><span class="line">hello...  </span><br><span class="line">hello... </span><br><span class="line"></span><br><span class="line">jack@jack:~/coding/muti_thread$ ./pthread_chap2</span><br><span class="line">hello...</span><br><span class="line">hello...</span><br><span class="line">hello...  </span><br><span class="line">hello...  </span><br><span class="line">hello...</span><br></pre></td></tr></table></figure><h2 id="如何在线程调用函数时传入参数呢？"><a href="#如何在线程调用函数时传入参数呢？" class="headerlink" title="如何在线程调用函数时传入参数呢？"></a>如何在线程调用函数时传入参数呢？</h2><p>先看下面修改的代码，传入线程编号作为参数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; //多线程相关操作头文件，可移植众多平台  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_THREADS 5 <span class="comment">//线程数  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">say_hello</span><span class="params">( <span class="keyword">void</span>* args )</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i = *( (<span class="keyword">int</span>*)args ); <span class="comment">//对传入的参数进行强制类型转换，由无类型指针转变为整形指针，再用*读取其指向到内容  </span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"hello in "</span> &lt;&lt; i &lt;&lt;  <span class="built_in">endl</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">&#125; <span class="comment">//函数返回的是函数指针，便于后面作为参数  </span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">pthread_t</span> tids[NUM_THREADS]; <span class="comment">//线程id  </span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"hello in main.."</span> &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; ++i )  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">int</span> ret = pthread_create( &amp;tids[i], <span class="literal">NULL</span>, say_hello, (<span class="keyword">void</span>*)&amp;i ); <span class="comment">//传入到参数必须强转为void*类型，即无类型指针，&amp;i表示取i的地址，即指向i的指针  </span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Current pthread id = "</span> &lt;&lt; tids[i] &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//用tids数组打印创建的进程id信息  </span></span><br><span class="line">        <span class="keyword">if</span>( ret != <span class="number">0</span> ) <span class="comment">//创建线程成功返回0  </span></span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"pthread_create error:error_code="</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    pthread_exit( <span class="literal">NULL</span> ); <span class="comment">//等待各个线程退出后，进程才结束，否则进程强制结束，线程处于未终止的状态 </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">jack@jack:~/coding/muti_thread$ ./pthread_chap2 </span><br><span class="line">hello <span class="keyword">in</span> main..  </span><br><span class="line">Current pthread id = 3078458224  </span><br><span class="line">Current pthread id = 3070065520  </span><br><span class="line">hello <span class="keyword">in</span> hello <span class="keyword">in</span> 2  </span><br><span class="line">1  </span><br><span class="line">Current pthread id = hello <span class="keyword">in</span> 2  </span><br><span class="line">3061672816  </span><br><span class="line">Current pthread id = 3053280112  </span><br><span class="line">hello <span class="keyword">in</span> 4  </span><br><span class="line">Current pthread id = hello <span class="keyword">in</span> 4  </span><br><span class="line">3044887408</span><br></pre></td></tr></table></figure><p>显然不是想要的结果，调用顺序很乱，这是为什么呢？<br>这是因为多线程到缘故，主进程还没开始对i赋值，线程已经开始跑了…?<br>修改代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt; //多线程相关操作头文件，可移植众多平台  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_THREADS 5 <span class="comment">//线程数  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">say_hello</span><span class="params">( <span class="keyword">void</span>* args )</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"hello in thread "</span> &lt;&lt; *( (<span class="keyword">int</span> *)args ) &lt;&lt;  <span class="built_in">endl</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125; <span class="comment">//函数返回的是函数指针，便于后面作为参数  </span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">pthread_t</span> tids[NUM_THREADS]; <span class="comment">//线程id  </span></span><br><span class="line">    <span class="keyword">int</span> indexes[NUM_THREADS]; <span class="comment">//用来保存i的值避免被修改  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; ++i )  </span><br><span class="line">    &#123;  </span><br><span class="line">        indexes[i] = i;  </span><br><span class="line">        <span class="keyword">int</span> ret = pthread_create( &amp;tids[i], <span class="literal">NULL</span>, say_hello, (<span class="keyword">void</span>*)&amp;(indexes[i]) );  </span><br><span class="line">        <span class="keyword">if</span>( ret != <span class="number">0</span> ) <span class="comment">//创建线程成功返回0  </span></span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"pthread_create error:error_code="</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; ++i )  </span><br><span class="line">        pthread_join( tids[i], <span class="literal">NULL</span> ); <span class="comment">//pthread_join用来等待一个线程的结束，是一个线程阻塞的函数 </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jack@jack:~/coding/muti_thread$ ./pthread_chap3 </span><br><span class="line">hello <span class="keyword">in</span> thread hello <span class="keyword">in</span> thread hello <span class="keyword">in</span> thread hello <span class="keyword">in</span> thread hello <span class="keyword">in</span> thread 30124</span><br></pre></td></tr></table></figure><p>这是正常的吗？感觉还是有问题…待续</p><p>代码中如果没有pthread_join主线程会很快结束从而使整个进程结束，从而使创建的线程没有机会开始执行就结束了。加入pthread_join后，主线程会一直等待直到等待的线程结束自己才结束，使创建的线程有机会执行。</p><h2 id="线程创建时属性参数的设置pthread-attr-t及join功能的使用"><a href="#线程创建时属性参数的设置pthread-attr-t及join功能的使用" class="headerlink" title="线程创建时属性参数的设置pthread_attr_t及join功能的使用"></a>线程创建时属性参数的设置pthread_attr_t及join功能的使用</h2><p>线程的属性由结构体pthread_attr_t进行管理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span>                           detachstate;     线程的分离状态</span><br><span class="line">    <span class="keyword">int</span>                          schedpolicy;   线程调度策略</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span>      <span class="title">schedparam</span>;</span>   线程的调度参数</span><br><span class="line">    <span class="keyword">int</span> inheritsched; 线程的继承性 </span><br><span class="line">    <span class="keyword">int</span> scope; 线程的作用域 </span><br><span class="line">    <span class="keyword">size_t</span> guardsize; 线程栈末尾的警戒缓冲区大小 </span><br><span class="line">    <span class="keyword">int</span> stackaddr_set; <span class="keyword">void</span> * stackaddr; 线程栈的位置 </span><br><span class="line">    <span class="keyword">size_t</span> stacksize; 线程栈的大小</span><br><span class="line">&#125;<span class="keyword">pthread_attr_t</span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_THREADS 5  </span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">say_hello</span><span class="params">( <span class="keyword">void</span>* args )</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"hello in thread "</span> &lt;&lt; *(( <span class="keyword">int</span> * )args) &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">    <span class="keyword">int</span> status = <span class="number">10</span> + *(( <span class="keyword">int</span> * )args); <span class="comment">//线程退出时添加退出的信息，status供主程序提取该线程的结束信息  </span></span><br><span class="line">    pthread_exit( ( <span class="keyword">void</span>* )status ); </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">pthread_t</span> tids[NUM_THREADS];  </span><br><span class="line">    <span class="keyword">int</span> indexes[NUM_THREADS];  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">pthread_attr_t</span> attr; <span class="comment">//线程属性结构体，创建线程时加入的参数  </span></span><br><span class="line">    pthread_attr_init( &amp;attr ); <span class="comment">//初始化  </span></span><br><span class="line">    pthread_attr_setdetachstate( &amp;attr, PTHREAD_CREATE_JOINABLE ); <span class="comment">//是设置你想要指定线程属性参数，这个参数表明这个线程是可以join连接的，join功能表示主程序可以等线程结束后再去做某事，实现了主程序和线程同步功能  </span></span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; ++i )  </span><br><span class="line">    &#123;  </span><br><span class="line">        indexes[i] = i;  </span><br><span class="line">        <span class="keyword">int</span> ret = pthread_create( &amp;tids[i], &amp;attr, say_hello, ( <span class="keyword">void</span>* )&amp;( indexes[i] ) );  </span><br><span class="line">        <span class="keyword">if</span>( ret != <span class="number">0</span> )  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"pthread_create error:error_code="</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;   </span><br><span class="line">    pthread_attr_destroy( &amp;attr ); <span class="comment">//释放内存   </span></span><br><span class="line">    <span class="keyword">void</span> *status;  </span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; ++i )  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">int</span> ret = pthread_join( tids[i], &amp;status ); <span class="comment">//主程序join每个线程后取得每个线程的退出信息status  </span></span><br><span class="line">        <span class="keyword">if</span>( ret != <span class="number">0</span> )  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"pthread_join error:error_code="</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"pthread_join get status:"</span> &lt;&lt; (<span class="keyword">long</span>)status &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">jack@jack:~/coding/muti_thread$ ./pthread_chap4  </span><br><span class="line">hello in thread hello in thread hello in thread hello in thread <span class="number">0</span>hello in thread <span class="number">321</span>  </span><br><span class="line">  </span><br><span class="line"><span class="number">4</span>  </span><br><span class="line">pthread_join get status:<span class="number">10</span>  </span><br><span class="line">pthread_join get status:<span class="number">11</span>  </span><br><span class="line">pthread_join get status:<span class="number">12</span>  </span><br><span class="line">pthread_join get status:<span class="number">13</span>  </span><br><span class="line">pthread_join get status:<span class="number">14</span></span><br></pre></td></tr></table></figure><h2 id="互斥锁的实现"><a href="#互斥锁的实现" class="headerlink" title="互斥锁的实现"></a>互斥锁的实现</h2><p>互斥锁是实现线程同步的一种机制，只要在临界区前后对资源加锁就能阻塞其他进程的访问。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_THREADS 5  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>; <span class="comment">//定义全局变量，让所有线程同时写，这样就需要锁机制  </span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> sum_mutex; <span class="comment">//互斥锁  </span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">say_hello</span><span class="params">( <span class="keyword">void</span>* args )</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"hello in thread "</span> &lt;&lt; *(( <span class="keyword">int</span> * )args) &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">    pthread_mutex_lock( &amp;sum_mutex ); <span class="comment">//先加锁，再修改sum的值，锁被占用就阻塞，直到拿到锁再修改sum;  </span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"before sum is "</span> &lt;&lt; sum &lt;&lt; <span class="string">" in thread "</span> &lt;&lt; *( ( <span class="keyword">int</span>* )args ) &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">    sum += *( ( <span class="keyword">int</span>* )args );  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"after sum is "</span> &lt;&lt; sum &lt;&lt; <span class="string">" in thread "</span> &lt;&lt; *( ( <span class="keyword">int</span>* )args ) &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">    pthread_mutex_unlock( &amp;sum_mutex ); <span class="comment">//释放锁，供其他线程使用  </span></span><br><span class="line">    pthread_exit( <span class="number">0</span> ); </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">pthread_t</span> tids[NUM_THREADS];  </span><br><span class="line">    <span class="keyword">int</span> indexes[NUM_THREADS];  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">pthread_attr_t</span> attr; <span class="comment">//线程属性结构体，创建线程时加入的参数  </span></span><br><span class="line">    pthread_attr_init( &amp;attr ); <span class="comment">//初始化  </span></span><br><span class="line">    pthread_attr_setdetachstate( &amp;attr, PTHREAD_CREATE_JOINABLE ); <span class="comment">//是设置你想要指定线程属性参数，这个参数表明这个线程是可以join连接的，join功能表示主程序可以等线程结束后再去做某事，实现了主程序和线程同步功能  </span></span><br><span class="line">    pthread_mutex_init( &amp;sum_mutex, <span class="literal">NULL</span> ); <span class="comment">//对锁进行初始化      </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; ++i )  </span><br><span class="line">    &#123;  </span><br><span class="line">        indexes[i] = i;  </span><br><span class="line">        <span class="keyword">int</span> ret = pthread_create( &amp;tids[i], &amp;attr, say_hello, ( <span class="keyword">void</span>* )&amp;( indexes[i] ) ); <span class="comment">//5个进程同时去修改sum  </span></span><br><span class="line">        <span class="keyword">if</span>( ret != <span class="number">0</span> )  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"pthread_create error:error_code="</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;   </span><br><span class="line">    pthread_attr_destroy( &amp;attr ); <span class="comment">//释放内存   </span></span><br><span class="line">    <span class="keyword">void</span> *status;  </span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUM_THREADS; ++i )  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">int</span> ret = pthread_join( tids[i], &amp;status ); <span class="comment">//主程序join每个线程后取得每个线程的退出信息status  </span></span><br><span class="line">        <span class="keyword">if</span>( ret != <span class="number">0</span> )  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"pthread_join error:error_code="</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"finally sum is "</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">    pthread_mutex_destroy( &amp;sum_mutex ); <span class="comment">//注销锁  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">jack@jack:~/coding/muti_thread$ ./pthread_chap5 </span><br><span class="line">hello in thread hello in thread hello in thread <span class="number">410</span>  </span><br><span class="line">before sum is hello in thread <span class="number">0</span> in thread <span class="number">4</span>  </span><br><span class="line">after sum is <span class="number">4</span> in thread <span class="number">4</span>hello in thread   </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="number">2</span>  </span><br><span class="line"><span class="number">3</span>  </span><br><span class="line">before sum is <span class="number">4</span> in thread <span class="number">1</span>  </span><br><span class="line">after sum is <span class="number">5</span> in thread <span class="number">1</span>  </span><br><span class="line">before sum is <span class="number">5</span> in thread <span class="number">0</span>  </span><br><span class="line">after sum is <span class="number">5</span> in thread <span class="number">0</span>  </span><br><span class="line">before sum is <span class="number">5</span> in thread <span class="number">2</span>  </span><br><span class="line">after sum is <span class="number">7</span> in thread <span class="number">2</span>  </span><br><span class="line">before sum is <span class="number">7</span> in thread <span class="number">3</span>  </span><br><span class="line">after sum is <span class="number">10</span> in thread <span class="number">3</span>  </span><br><span class="line">finally sum is <span class="number">10</span></span><br></pre></td></tr></table></figure><p>可知，sum的访问和修改顺序是正常的，这就达到了多线程的目的了，但是线程的运行顺序是混乱的，混乱就是正常？</p><h2 id="信号量的实现"><a href="#信号量的实现" class="headerlink" title="信号量的实现"></a>信号量的实现</h2><p>信号量是线程同步的另一种实现机制，信号量的操作有signal和wait，本例子采用条件信号变量pthread_cond_t tasks_cond;<br>信号量的实现也要给予锁机制。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOUNDARY 5  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span> tasks = <span class="number">10</span>;  </span><br><span class="line"><span class="keyword">pthread_mutex_t</span> tasks_mutex; <span class="comment">//互斥锁  </span></span><br><span class="line"><span class="keyword">pthread_cond_t</span> tasks_cond; <span class="comment">//条件信号变量，处理两个线程间的条件关系，当task&gt;5，hello2处理，反之hello1处理，直到task减为0  </span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">say_hello2</span><span class="params">( <span class="keyword">void</span>* args )</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">pthread_t</span> pid = pthread_self(); <span class="comment">//获取当前线程id  </span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"["</span> &lt;&lt; pid &lt;&lt; <span class="string">"] hello in thread "</span> &lt;&lt;  *( ( <span class="keyword">int</span>* )args ) &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">bool</span> is_signaled = <span class="literal">false</span>; <span class="comment">//sign  </span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">    pthread_mutex_lock( &amp;tasks_mutex ); <span class="comment">//加锁  </span></span><br><span class="line">    <span class="keyword">if</span>( tasks &gt; BOUNDARY )  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"["</span> &lt;&lt; pid &lt;&lt; <span class="string">"] take task: "</span> &lt;&lt; tasks &lt;&lt; <span class="string">" in thread "</span> &lt;&lt; *( (<span class="keyword">int</span>*)args ) &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">        --tasks; <span class="comment">//modify  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( !is_signaled )  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"["</span> &lt;&lt; pid &lt;&lt; <span class="string">"] pthread_cond_signal in thread "</span> &lt;&lt; *( ( <span class="keyword">int</span>* )args ) &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">        pthread_cond_signal( &amp;tasks_cond ); <span class="comment">//signal:向hello1发送信号，表明已经&gt;5  </span></span><br><span class="line">        is_signaled = <span class="literal">true</span>; <span class="comment">//表明信号已发送，退出此线程  </span></span><br><span class="line">    &#125;  </span><br><span class="line">    pthread_mutex_unlock( &amp;tasks_mutex ); <span class="comment">//解锁  </span></span><br><span class="line">    <span class="keyword">if</span>( tasks == <span class="number">0</span> )  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line">    &#125;      </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">say_hello1</span><span class="params">( <span class="keyword">void</span>* args )</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">pthread_t</span> pid = pthread_self(); <span class="comment">//获取当前线程id  </span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"["</span> &lt;&lt; pid &lt;&lt; <span class="string">"] hello in thread "</span> &lt;&lt;  *( ( <span class="keyword">int</span>* )args ) &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        pthread_mutex_lock( &amp;tasks_mutex ); <span class="comment">//加锁  </span></span><br><span class="line">        <span class="keyword">if</span>( tasks &gt; BOUNDARY )  </span><br><span class="line">        &#123;  </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"["</span> &lt;&lt; pid &lt;&lt; <span class="string">"] pthread_cond_signal in thread "</span> &lt;&lt; *( ( <span class="keyword">int</span>* )args ) &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">        pthread_cond_wait( &amp;tasks_cond, &amp;tasks_mutex ); <span class="comment">//wait:等待信号量生效，接收到信号，向hello2发出信号，跳出wait,执行后续   </span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"["</span> &lt;&lt; pid &lt;&lt; <span class="string">"] take task: "</span> &lt;&lt; tasks &lt;&lt; <span class="string">" in thread "</span> &lt;&lt; *( (<span class="keyword">int</span>*)args ) &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">            --tasks;  </span><br><span class="line">    &#125;  </span><br><span class="line">        pthread_mutex_unlock( &amp;tasks_mutex ); <span class="comment">//解锁  </span></span><br><span class="line">        <span class="keyword">if</span>( tasks == <span class="number">0</span> )  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">pthread_attr_t</span> attr; <span class="comment">//线程属性结构体，创建线程时加入的参数  </span></span><br><span class="line">    pthread_attr_init( &amp;attr ); <span class="comment">//初始化  </span></span><br><span class="line">    pthread_attr_setdetachstate( &amp;attr, PTHREAD_CREATE_JOINABLE ); <span class="comment">//是设置你想要指定线程属性参数，这个参数表明这个线程是可以join连接的，join功能表示主程序可以等线程结束后再去做某事，实现了主程序和线程同步功能  </span></span><br><span class="line">    pthread_cond_init( &amp;tasks_cond, <span class="literal">NULL</span> ); <span class="comment">//初始化条件信号量  </span></span><br><span class="line">    pthread_mutex_init( &amp;tasks_mutex, <span class="literal">NULL</span> ); <span class="comment">//初始化互斥量  </span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid1, tid2; <span class="comment">//保存两个线程id  </span></span><br><span class="line">    <span class="keyword">int</span> index1 = <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">int</span> ret = pthread_create( &amp;tid1, &amp;attr, say_hello1, ( <span class="keyword">void</span>* )&amp;index1 );  </span><br><span class="line">    <span class="keyword">if</span>( ret != <span class="number">0</span> )  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"pthread_create error:error_code="</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">int</span> index2 = <span class="number">2</span>;  </span><br><span class="line">    ret = pthread_create( &amp;tid2, &amp;attr, say_hello2, ( <span class="keyword">void</span>* )&amp;index2 );  </span><br><span class="line">    <span class="keyword">if</span>( ret != <span class="number">0</span> )  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"pthread_create error:error_code="</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    pthread_join( tid1, <span class="literal">NULL</span> ); <span class="comment">//连接两个线程  </span></span><br><span class="line">    pthread_join( tid2, <span class="literal">NULL</span> );   </span><br><span class="line">  </span><br><span class="line">    pthread_attr_destroy( &amp;attr ); <span class="comment">//释放内存   </span></span><br><span class="line">    pthread_mutex_destroy( &amp;tasks_mutex ); <span class="comment">//注销锁  </span></span><br><span class="line">    pthread_cond_destroy( &amp;tasks_cond ); <span class="comment">//正常退出  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：<br>先在线程2中执行say_hello2，再跳转到线程1中执行say_hello1，直到tasks减到0为止。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">jack@jack:~/coding/muti_thread$ ./pthread_chap6  </span><br><span class="line">[3069823856] hello <span class="keyword">in</span> thread 2  </span><br><span class="line">[3078216560] hello <span class="keyword">in</span> thread 1[3069823856] take task: 10 <span class="keyword">in</span> thread 2  </span><br><span class="line">  </span><br><span class="line">[3069823856] take task: 9 <span class="keyword">in</span> thread 2  </span><br><span class="line">[3069823856] take task: 8 <span class="keyword">in</span> thread 2  </span><br><span class="line">[3069823856] take task: 7 <span class="keyword">in</span> thread 2  </span><br><span class="line">[3069823856] take task: 6 <span class="keyword">in</span> thread 2  </span><br><span class="line">[3069823856] pthread_cond_signal <span class="keyword">in</span> thread 2  </span><br><span class="line">[3078216560] take task: 5 <span class="keyword">in</span> thread 1  </span><br><span class="line">[3078216560] take task: 4 <span class="keyword">in</span> thread 1  </span><br><span class="line">[3078216560] take task: 3 <span class="keyword">in</span> thread 1  </span><br><span class="line">[3078216560] take task: 2 <span class="keyword">in</span> thread 1  </span><br><span class="line">[3078216560] take task: 1 <span class="keyword">in</span> thread 1</span><br></pre></td></tr></table></figure><p>到此，对多线程编程有了一个初步的了解，当然还有其他实现线程同步的机制，有待进一步探索。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;最基础，进程同时创建5个线程，各自调用同一个函数&quot;&gt;&lt;a href=&quot;#最基础，进程同时创建5个线程，各自调用同一个函数&quot; class=&quot;headerlink&quot; title=&quot;最基础，进程同时创建5个线程，各自调用同一个函数&quot;&gt;&lt;/a&gt;最基础，进程同时创建5个线程
      
    
    </summary>
    
      <category term="Cpp" scheme="https://loopvoid.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://loopvoid.github.io/tags/Cpp/"/>
    
      <category term="Pthread" scheme="https://loopvoid.github.io/tags/Pthread/"/>
    
  </entry>
  
  <entry>
    <title>Opencv基于特征点的图像对齐</title>
    <link href="https://loopvoid.github.io/2018/03/12/Opencv%E5%9F%BA%E4%BA%8E%E7%89%B9%E5%BE%81%E7%82%B9%E7%9A%84%E5%9B%BE%E5%83%8F%E5%AF%B9%E9%BD%90/"/>
    <id>https://loopvoid.github.io/2018/03/12/Opencv基于特征点的图像对齐/</id>
    <published>2018-03-12T10:22:33.000Z</published>
    <updated>2019-08-06T06:43:34.420Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二维图像之间的单应变换"><a href="#二维图像之间的单应变换" class="headerlink" title="二维图像之间的单应变换"></a>二维图像之间的单应变换</h1><p>图像中的2D点(x,y)(x,y)可以被表示成3D向量的形式$(x_1,x_2,x_3)$，其中$x=\frac{x_1}{x_3}$，$y=\frac{x_2}{x_3}$。它被叫做点的齐次表达，位于投影平面$P^2$上。所谓单应就是发生在投影平面$P^2$上的点和线可逆的映射。其它叫法包括射影变换、投影变换和平面投影变换等。</p><p>单应变换矩阵是一个3*3的矩阵H。这个变换可以被任意乘上一个非零常数，而不改变变换本身。它虽然具有9个元素，但是具有8个自由度。这意味这它里面有8个未知参数待求。</p><p>典型地，可以通过图像之间的特征匹配来估计单应矩阵。</p><h2 id="单应和齐次坐标"><a href="#单应和齐次坐标" class="headerlink" title="单应和齐次坐标"></a>单应和齐次坐标</h2><p>一个单应矩阵是大小为3*3的矩阵$H = \begin{bmatrix} h_{11} &amp; h_{12} &amp; h_{13}\ h_{21} &amp; h_{22} &amp; h_{23}\ h_{31} &amp; h_{32} &amp; h_{33}\end{bmatrix}$，满足给定一个点 $P_1 = \left[ \begin{matrix}   x_1 \   y_1 \  w_1  \end{matrix} \right]$ ,矩阵H把点$P_1$变换成一个新的点$P_2 = \left[ \begin{matrix}   x_2 \   y_2 \  w_2  \end{matrix} \right] = \begin{bmatrix} h_{11} &amp; h_{12} &amp; h_{13}\  h_{21} &amp; h_{22} &amp; h_{23}\ h_{31} &amp; h_{32} &amp; h_{33}\end{bmatrix}\cdot  \left[ \begin{matrix}   x_1 \   y_1 \  w_1  \end{matrix} \right]$ 。由于他们都是齐次坐标，对应在图像上的两个点分别是$\left[ \begin{matrix}   \frac{x_1}{w_1}  \  \frac{y_1}{w_1}\end{matrix} \right]$，$\left[ \begin{matrix}   \frac{x_2}{w_2}  \  \frac{y_2}{w_2}\end{matrix} \right]$ 。</p><h2 id="单应的自由度"><a href="#单应的自由度" class="headerlink" title="单应的自由度"></a>单应的自由度</h2><p>如果给定一个单位$H={h_{ij}}$，给H的每个元素乘上a，得到的单应$aH$和$H$作用相同，因为新的单应无非把齐次点$P_1$变成了齐次点$aP_2$，$aP_2$和$P_2$在图像上对应的点是相同的。所以一个单应中只有8个自由度，一般令$h_{33}=1$来归一化。</p><h2 id="求解单应"><a href="#求解单应" class="headerlink" title="求解单应"></a>求解单应</h2><p>8个未知数需要8个方程来求解，之所以4对点能求解，因为他们一个点能提供两个方程。</p><p>假设图像上有两个点$(x_1,y_1)$，$(x_2,y_2)$，他们的齐次坐标为$\left[ \begin{matrix}   x_1 \   y_1 \  1  \end{matrix} \right]$，$\left[ \begin{matrix}   x_2 \   y_2 \  1  \end{matrix} \right]$。</p><p>带入上述的推导可以得到：</p><p>$$<br>x_2=x_1h_{11}+y_1h_{12}+h_{13}<br>$$</p><p>$$<br>y_2=x_1h_{21}+y_1h_{22}+h_{23}<br>$$</p><p>$$<br>1=x_1h_{31}+y_1h_{32}+h_{33}<br>$$</p><p>一般令$h_{33}=1$来归一化，可得到：</p><p>$$<br>x_2=\frac{x_1h_{11}+y_1h_{12}+h_{13}}{x_1h_{31}+y_1h_{32}+1}<br>$$</p><p>$$<br>y_2=\frac{x_1h_{21}+y_1h_{22}+h_{23}}{x_1h_{31}+y_1h_{32}+1}<br>$$</p><p>把这两个式子重新组织一下，得到等价的矩阵形式：</p><p>$$<br>Au=v<br>$$</p><p>$$<br>A = \left[ \begin{matrix}   x_1 \  y_1 \  1 \  0 \  0 \  0  \ -x_1x_2  \  -x_2y_1 \ 0 \ 0 \ 0 \ x_1 \ y_1 \ 1 \ -x_1y_2 \ -y_1y_2  \end{matrix} \right]<br>$$</p><p>$$<br>u=\left[ \begin{matrix}   h_{11} \  h_{12} \  h_{13} \  h_{21} \  h_{22} \  h_{23} \  h_{31} \  h_{32} \  h_{33}  \end{matrix} \right]^T<br>$$</p><p>$$<br>v=\left[ \begin{matrix} x_2 \ y_2  \end{matrix} \right]^T<br>$$</p><p>如果有四对不共线匹配点对，这个方程组就能够垒到8行，存在唯一解。</p><p>如果多于四对点，比如有n对点，方程就垒到2n行，用最小二乘法或SVD分解就可以求解$H$。</p><p>由于点对中可能存在不少错误匹配，一般使用RANSAC算法剔除错误匹配点对。</p><h1 id="Opencv中单应性矩阵H的计算"><a href="#Opencv中单应性矩阵H的计算" class="headerlink" title="Opencv中单应性矩阵H的计算"></a>Opencv中单应性矩阵H的计算</h1><p>如果在两幅对应的图像中已知4个映射点的坐标，就可以使用 <a href="https://docs.opencv.org/3.4.1/d9/d0c/group__calib3d.html#gafd3ef89257e27d5235f4467cbb1b6a63" target="_blank" rel="noopener">findHomography</a>函数如下：</p><p><strong>C++:  ** <code>Mat cv::findHomography(InputArray srcPoints,InputArray dstPoints,OutputArray mask,int method = 0,double ransacReprojThreshold = 3)</code><br>**Python:</strong> <code>retval,mask=cv.findHomography(srcPoints,dstPoints[,method[,ransacReprojThreshold[,mask[,maxIters[,confidence]]]]])</code></p><h1 id="自动寻找对应点-corresponding-points"><a href="#自动寻找对应点-corresponding-points" class="headerlink" title="自动寻找对应点(corresponding points)"></a>自动寻找对应点(corresponding points)</h1><p>由上文知道知道两对对应点(4个映射点)的坐标即可求得单应性矩阵H。</p><p>我们可以使用在OpenCV中的几个关键点检测器（例如SIFT，SURF和ORB）。</p><p>本文将采用ORB关键点检测器，SIFT和SURF已经注册专利。</p><p>一个特征点检测器由两个部分组成：</p><p><strong>定位器(Locator)：</strong>它可以识别图像上在平移（移位），缩放（缩小增大/缩小）和旋转等图像变换下稳定的点。 定位器查找这些点的x，y坐标。 ORB检测器使用的定位器叫做<a href="https://docs.opencv.org/3.0-beta/doc/py_tutorials/py_feature2d/py_fast/py_fast.html" target="_blank" rel="noopener">FAST</a>。<br><strong>描述符(Descriptor)：</strong>上述步骤中的定位器仅告诉我们特征点在哪里。 特征检测器的第二部分是对点的外观进行编码的描述符，以便我们可以从另幅图中指出同一个特征点。 在特征点处评定的描述符只是一个数字数组。 理想情况下，两幅图像中的相同物理点应具有相同的描述符。 ORB使用的是<a href="https://www.robots.ox.ac.uk/~vgg/rg/papers/brisk.pdf" target="_blank" rel="noopener">BRISK</a>特征描述符的修改版本。</p><h1 id="总结：图像对齐思路"><a href="#总结：图像对齐思路" class="headerlink" title="总结：图像对齐思路"></a>总结：图像对齐思路</h1><p>1、读取图像</p><p>2、特征点检测</p><p>3、匹配特征点</p><p>4、计算单应矩阵参数</p><p>5、矫正图像</p><h1 id="C-Code"><a href="#C-Code" class="headerlink" title="C++ Code"></a>C++ Code</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/xfeatures2d.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/features2d.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv::xfeatures2d;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX_FEATURES = <span class="number">500</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">float</span> GOOD_MATCH_PERCENT = <span class="number">0.15f</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">alignImages</span><span class="params">(Mat &amp;im1, Mat &amp;im2, Mat &amp;im1Reg, Mat &amp;h)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Convert images to grayscale</span></span><br><span class="line">  Mat im1Gray, im2Gray;</span><br><span class="line">  cvtColor(im1, im1Gray, CV_BGR2GRAY);</span><br><span class="line">  cvtColor(im2, im2Gray, CV_BGR2GRAY);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Variables to store keypoints and descriptors</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;KeyPoint&gt; keypoints1, keypoints2;</span><br><span class="line">  Mat descriptors1, descriptors2;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Detect ORB features and compute descriptors.</span></span><br><span class="line">  Ptr&lt;Feature2D&gt; orb = ORB::create(MAX_FEATURES);</span><br><span class="line">  orb-&gt;detectAndCompute(im1Gray, Mat(), keypoints1, descriptors1);</span><br><span class="line">  orb-&gt;detectAndCompute(im2Gray, Mat(), keypoints2, descriptors2);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Match features.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;DMatch&gt; matches;</span><br><span class="line">  Ptr&lt;DescriptorMatcher&gt; matcher = DescriptorMatcher::create(<span class="string">"BruteForce-Hamming"</span>);</span><br><span class="line">  matcher-&gt;match(descriptors1, descriptors2, matches, Mat());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Sort matches by score</span></span><br><span class="line">  <span class="built_in">std</span>::sort(matches.begin(), matches.end());</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Remove not so good matches</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> numGoodMatches = matches.size() * GOOD_MATCH_PERCENT;</span><br><span class="line">  matches.erase(matches.begin()+numGoodMatches, matches.end());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Draw top matches</span></span><br><span class="line">  Mat imMatches;</span><br><span class="line">  drawMatches(im1, keypoints1, im2, keypoints2, matches, imMatches);</span><br><span class="line">  imwrite(<span class="string">"matches.jpg"</span>, imMatches);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Extract location of good matches</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Point2f&gt; points1, points2;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>( <span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; matches.size(); i++ )</span><br><span class="line">  &#123;</span><br><span class="line">    points1.push_back( keypoints1[ matches[i].queryIdx ].pt );</span><br><span class="line">    points2.push_back( keypoints2[ matches[i].trainIdx ].pt );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Find homography</span></span><br><span class="line">  h = findHomography( points1, points2, RANSAC );</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Use homography to warp image</span></span><br><span class="line">  warpPerspective(im1, im1Reg, h, im2.size());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// Read reference image</span></span><br><span class="line">  <span class="function"><span class="built_in">string</span> <span class="title">refFilename</span><span class="params">(<span class="string">"form.jpg"</span>)</span></span>; </span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"Reading reference image : "</span> &lt;&lt; refFilename &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">  Mat imReference = imread(refFilename);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Read image to be aligned</span></span><br><span class="line">  <span class="function"><span class="built_in">string</span> <span class="title">imFilename</span><span class="params">(<span class="string">"scanned-form.jpg"</span>)</span></span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"Reading image to align : "</span> &lt;&lt; imFilename &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">  Mat im = imread(imFilename);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Registered image will be resotred in imReg. </span></span><br><span class="line">  <span class="comment">// The estimated homography will be stored in h. </span></span><br><span class="line">  Mat imReg, h;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Align images</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"Aligning images ..."</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">  alignImages(im, imReference, imReg, h);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Write aligned image to disk. </span></span><br><span class="line">  <span class="function"><span class="built_in">string</span> <span class="title">outFilename</span><span class="params">(<span class="string">"aligned.jpg"</span>)</span></span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"Saving aligned image : "</span> &lt;&lt; outFilename &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">  imwrite(outFilename, imReg);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Print estimated homography</span></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"Estimated homography : \n"</span> &lt;&lt; h &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;二维图像之间的单应变换&quot;&gt;&lt;a href=&quot;#二维图像之间的单应变换&quot; class=&quot;headerlink&quot; title=&quot;二维图像之间的单应变换&quot;&gt;&lt;/a&gt;二维图像之间的单应变换&lt;/h1&gt;&lt;p&gt;图像中的2D点(x,y)(x,y)可以被表示成3D向量的形式$(x_
      
    
    </summary>
    
      <category term="Opencv" scheme="https://loopvoid.github.io/categories/Opencv/"/>
    
    
      <category term="Opencv" scheme="https://loopvoid.github.io/tags/Opencv/"/>
    
  </entry>
  
  <entry>
    <title>查找算法</title>
    <link href="https://loopvoid.github.io/2018/03/09/%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
    <id>https://loopvoid.github.io/2018/03/09/查找算法/</id>
    <published>2018-03-09T13:57:31.000Z</published>
    <updated>2019-08-06T05:45:31.597Z</updated>
    
    <content type="html"><![CDATA[<h1 id="顺序查找-Sequential-Search"><a href="#顺序查找-Sequential-Search" class="headerlink" title="顺序查找(Sequential Search)"></a>顺序查找(Sequential Search)</h1><p><strong>说明：顺序查找适合于存储结构为顺序存储或链接存储的线性表</strong></p><p><strong>复杂度：O(n)</strong></p><p><strong>基本思想：</strong>顺序查找也称线性查找(Liner Search)，属于无序查找算法。</p><p>从数据结构线性表的一端开始，顺序扫描，依次比较扫描到的结点，若相等则表示查找成功；</p><p>若扫描结束仍没有找到目标，则查找失败；</p><p>查找失败则需要进行n+1次比较，则时间复杂度为 <strong>O(n)</strong></p><h2 id="C-实现"><a href="#C-实现" class="headerlink" title="C++实现"></a>C++实现</h2><ul><li><p>Code Example 1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> V&gt; <span class="function"><span class="keyword">int</span> <span class="title">sequential_search</span><span class="params">(<span class="keyword">const</span> T *arr, V key, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (key == arr[i])</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr1[] = &#123; <span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">13</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> len1 = (<span class="keyword">int</span>)<span class="keyword">sizeof</span>(arr1) / <span class="keyword">sizeof</span>(*arr1);</span><br><span class="line"><span class="keyword">int</span> key1 = <span class="number">8</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Index: "</span> &lt;&lt; sequential_search(arr1, key1, len1) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> arr2[] = &#123; <span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>,<span class="string">'f'</span>,<span class="string">'g'</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> len2 = (<span class="keyword">int</span>)<span class="keyword">sizeof</span>(arr2) / <span class="keyword">sizeof</span>(*arr2);</span><br><span class="line"><span class="keyword">char</span> key2 = <span class="string">'e'</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Index: "</span> &lt;&lt; sequential_search(arr2, key2, len2) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Code Example 2</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">13</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> key = <span class="number">13</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> elem : arr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (key == elem)</span><br><span class="line">&#123;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"not fund !"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="二分查找-Binary-Search"><a href="#二分查找-Binary-Search" class="headerlink" title="二分查找(Binary Search)"></a>二分查找(Binary Search)</h1><p><strong>说明：元素必须是有序的，若无序则需先排序</strong></p><p><strong>复杂度：O(log2n)</strong></p><p><strong>基本思想：</strong>将n个元素分成大致相等的两部分，取a[n/2]与x做比较，如果x=a[n/2],则找到x,算法中止；</p><p>如果x&lt;a[n/2],则只要在数组a的左半部分继续搜索x</p><p>如果x&gt;a[n/2],则只要在数组a的右半部搜索x.</p><p>时间复杂度无非就是while循环的次数,总共有n个元素，</p><p>渐渐跟下去就是n,n/2,n/4,….n/2^k（接下来操作元素的剩余个数），其中k就是循环的次数</p><p>由于你n/2^k取整后&gt;=1，即令n/2^k=1</p><p>可得k=log2n,（是以2为底，n的对数）</p><p>所以时间复杂度可以表示O(h)=O(log2n)</p><h2 id="C-实现-1"><a href="#C-实现-1" class="headerlink" title="C++实现"></a>C++实现</h2><ul><li>随机数生成</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line">srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;rand()&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">取得(<span class="number">0</span>,x)的随机整数：rand()%x；</span><br><span class="line">取得(a,b)的随机整数：rand()%(b-a)；</span><br><span class="line">取得[a,b)的随机整数：rand()%(b-a)+a；</span><br><span class="line">取得[a,b]的随机整数：rand()%(b-a+<span class="number">1</span>)+a；</span><br><span class="line">取得(a,b]的随机整数：rand()%(b-a)+a+<span class="number">1</span>；</span><br><span class="line">取得<span class="number">0</span><span class="number">-1</span>之间的浮点数：rand()/<span class="keyword">double</span>(RAND_MAX)</span><br></pre></td></tr></table></figure><ul><li>每次都从中间分，完成查找次数相对稳定</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br></pre></td></tr></table></figure><ul><li>每次的mid值由左右界限来生成随机值</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mid = rand() % (right - left + <span class="number">1</span>) + left;</span><br></pre></td></tr></table></figure><ul><li>Code</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> V&gt; <span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(V *arr,T key, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> right = len - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line"><span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//int mid = (left + right) / 2;</span></span><br><span class="line"><span class="keyword">int</span> mid = rand() % (right - left + <span class="number">1</span>) + left;</span><br><span class="line"><span class="keyword">if</span> (arr[mid] == key)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"real times to target:"</span> &lt;&lt; <span class="string">"\t\t"</span> &lt;&lt; count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(key &gt; arr[mid])</span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> key = <span class="string">'a'</span>+ <span class="number">29</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> len = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">char</span> arr[len];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">arr[i] = <span class="string">'a'</span> + i;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"expected times to target:"</span> &lt;&lt; <span class="string">"\t"</span> &lt;&lt; log2(len) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; binary_search(arr, key, len) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="插值查找-Interpolation-Search"><a href="#插值查找-Interpolation-Search" class="headerlink" title="插值查找(Interpolation Search)"></a>插值查找(Interpolation Search)</h1><p>在二分查找的基础上，二分查找是每次都分一办查找。但是我们查字典的时候并不会是一半一半的翻页。</p><p>比如查c开头的单词，我们会从字典的<strong>(c-a)/(z-a)</strong>部分打开。</p><p>这种折半的查找方式并不是每次折半<strong>1/2</strong>，因此我们将二分法的折<strong>1/2</strong>的方式优化为自适应的<strong>(c-a)/(z-a)</strong>的比例。</p><p>二分法：<strong>mid=(left+right )/2, 即mid=left+1/2*(right -left);</strong></p><p>插值法则是： <strong>mid = left+ (key - arr[left])/(arr[right] - key) * (right - left)</strong></p><p><strong>基本思想：基于二分法，改进查找点的自适应性，从而提高效率。插值查找也属于有序查找。</strong></p><p><strong>复杂度：查找成功/失败都是$O(log_2(log_2^n))$。</strong></p><p>注：<strong>对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多。反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择。</strong></p><h2 id="C-实现-2"><a href="#C-实现-2" class="headerlink" title="C++实现"></a>C++实现</h2><ul><li>Code<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> V&gt; <span class="keyword">size_t</span> interpolation_search(V *arr, T key, <span class="keyword">size_t</span> len, <span class="keyword">size_t</span> &amp;count)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> right = len - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((arr[left]!=arr[right]) &amp;&amp; (key&gt;arr[left]) &amp;&amp; (key&lt;arr[right]))</span><br><span class="line">&#123;</span><br><span class="line">count++;</span><br><span class="line">mid = left + (right - left) * (key - arr[left]) / (arr[right] - arr[left]);</span><br><span class="line"><span class="keyword">if</span> (key &gt; arr[mid])</span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">right = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (arr[mid] == key)</span><br><span class="line"><span class="keyword">return</span> mid;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> key = <span class="string">'a'</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> len = <span class="number">29</span>;</span><br><span class="line"><span class="keyword">size_t</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> arr[len];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">arr[i] = <span class="string">'a'</span> + i;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"expected times to target:\t"</span> &lt;&lt; log2(log2(len)) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"position: \t"</span> &lt;&lt; interpolation_search(arr, key, len, count) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"real times to target:\t"</span> &lt;&lt; count &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>*<em>输出： *</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">expected <span class="built_in">times</span> to target:       2.28036</span><br><span class="line">position:       10</span><br><span class="line">real <span class="built_in">times</span> to target:   1</span><br></pre></td></tr></table></figure><h1 id="分块查找-Block-Search"><a href="#分块查找-Block-Search" class="headerlink" title="分块查找(Block Search)"></a>分块查找(Block Search)</h1><p><strong>分块有序：</strong>整个表中的元素未必有序，但若划分为若干块后，每一块中的所有元素均小于（或大于）其后面块中的所有元素。</p><p>分块查找又称<strong>索引顺序查找</strong>，它是顺序查找的一种改进方法。首先须要对数组进行分块，分块查找须要建立一个“索引表”。索引表分为m块，每块含有N/m个元素，块内是无序的，块间是有序的，比如块2中最大元素小于块3中最小元素。先用二分查找索引表。确定须要查找的keyword在哪一块，然后再在对应的块内用顺序查找。</p><p><strong>操作步骤：</strong></p><p>　　step1 先选取各块中的最大关键字构成一个索引表；</p><p>　　step2 查找分两个部分：先对索引表进行二分查找或顺序查找，以确定待查记录在哪一块中；然后，在已确定的块中用顺序法进行查找。</p><p><strong>时间复杂度：</strong>O(log(m)+N/m)</p><h2 id="C-实现-Block-search"><a href="#C-实现-Block-search" class="headerlink" title="C++实现(Block search)"></a>C++实现(Block search)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//索引表--结构体模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">struct</span> <span class="title">Index_table</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">T key;</span><br><span class="line"><span class="keyword">int</span> link;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index_able为索引表,x为原数组,N为数组大小，m为块大小, keyword为查找目标</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;  <span class="function"><span class="keyword">int</span> <span class="title">index_order_search</span><span class="params">(Index_table&lt;T&gt; *index_able, T *x, <span class="keyword">int</span> N, <span class="keyword">int</span> m, T keyword)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> L = (N + m - <span class="number">1</span>) / m;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; L &amp;&amp; index_able[i].key &lt; keyword)</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">if</span> (i == L)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = index_able[i].link; j &lt; index_able[i].link + m; j++)</span><br><span class="line"><span class="keyword">if</span> (x[j] == keyword)</span><br><span class="line"><span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//block1(22,0)    |block2(48,6)      |block3(86,12)</span></span><br><span class="line"><span class="comment">//22,12,13,8,9,20,|33,42,44,38,24,48,|60,58,74,49,86,53</span></span><br><span class="line"><span class="comment">//0 ,1 ,2 ,3,4,5 ,|6 ,7 ,8 ,9 ,10,11,|12,13,14,15,16,17</span></span><br><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">22</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">20</span>,<span class="number">33</span>,<span class="number">42</span>,<span class="number">44</span>,<span class="number">38</span>,<span class="number">24</span>,<span class="number">48</span>,<span class="number">60</span>,<span class="number">58</span>,<span class="number">74</span>,<span class="number">49</span>,<span class="number">86</span>,<span class="number">53</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> len = (<span class="keyword">unsigned</span>)<span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(*arr);</span><br><span class="line"><span class="keyword">int</span> block_size = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span> target = <span class="number">33</span>;</span><br><span class="line"></span><br><span class="line">Index_table&lt;<span class="keyword">int</span>&gt; index_table[<span class="number">3</span>];</span><br><span class="line">index_table[<span class="number">0</span>].key = <span class="number">22</span>;</span><br><span class="line">index_table[<span class="number">0</span>].link = <span class="number">0</span>;</span><br><span class="line">index_table[<span class="number">1</span>].key = <span class="number">48</span>;</span><br><span class="line">index_table[<span class="number">1</span>].link = <span class="number">6</span>; </span><br><span class="line">index_table[<span class="number">2</span>].key = <span class="number">86</span>;</span><br><span class="line">index_table[<span class="number">2</span>].link = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; index_order_search(index_table, arr, len, block_size, target) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">system(<span class="string">"pause"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;顺序查找-Sequential-Search&quot;&gt;&lt;a href=&quot;#顺序查找-Sequential-Search&quot; class=&quot;headerlink&quot; title=&quot;顺序查找(Sequential Search)&quot;&gt;&lt;/a&gt;顺序查找(Sequential Sea
      
    
    </summary>
    
      <category term="Algorithm" scheme="https://loopvoid.github.io/categories/Algorithm/"/>
    
    
      <category term="Cpp" scheme="https://loopvoid.github.io/tags/Cpp/"/>
    
      <category term="Algorithm" scheme="https://loopvoid.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Google C++ Style Guide</title>
    <link href="https://loopvoid.github.io/2018/03/06/Google-C-Style-Guide/"/>
    <id>https://loopvoid.github.io/2018/03/06/Google-C-Style-Guide/</id>
    <published>2018-03-06T04:46:33.000Z</published>
    <updated>2019-08-06T06:53:45.511Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Google-C-Style-Guide"><a href="#Google-C-Style-Guide" class="headerlink" title="Google C++ Style Guide"></a>Google C++ Style Guide</h1><p>![KalmanModelImg](Google-C-Style-Guide/Google C++ Style Guide.jpg)</p><p><a href="http://blog.csdn.net/voidccc/article/details/37599203" target="_blank" rel="noopener">Reference</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Google-C-Style-Guide&quot;&gt;&lt;a href=&quot;#Google-C-Style-Guide&quot; class=&quot;headerlink&quot; title=&quot;Google C++ Style Guide&quot;&gt;&lt;/a&gt;Google C++ Style Guide&lt;/
      
    
    </summary>
    
      <category term="Cpp" scheme="https://loopvoid.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://loopvoid.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://loopvoid.github.io/2018/01/29/Mat%E5%92%8CIplImage%E8%BD%AC%E6%8D%A2/"/>
    <id>https://loopvoid.github.io/2018/01/29/Mat和IplImage转换/</id>
    <published>2018-01-29T07:14:09.000Z</published>
    <updated>2019-08-06T06:45:42.227Z</updated>
    
    <content type="html"><![CDATA[<p>Mat 是OpenCV和C++的接口矩阵类，ImlImage是OpenCV和C语言的接口的结构体，但是C++程序有时候时候还是要用到ImlImage。</p><p><strong>浅拷贝是不需要释放内存的。</strong></p><p><strong>深拷贝才需要释放内存。</strong></p><h1 id="IplImage-转-Mat"><a href="#IplImage-转-Mat" class="headerlink" title="IplImage 转 Mat"></a>IplImage 转 Mat</h1><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><p>直接使用cvarrToMat函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IplImage* src = cvLoadImage(<span class="string">"./res/tmp.jpg"</span>);  </span><br><span class="line">Mat img;  </span><br><span class="line">img = cvarrToMat(src);</span><br></pre></td></tr></table></figure><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><p>需要在Mat里创建一个新的Mat对象，然后进行数据的复制，再用上述的函数进行数据头的复制（即浅拷贝）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IplImage* src = cvLoadImage(<span class="string">"c://tmp.jpg"</span>);  </span><br><span class="line">Mat img_tmp;  </span><br><span class="line">img_tmp = cvarrToMat(src);  </span><br><span class="line">Mat img = img_tmp.clone();</span><br></pre></td></tr></table></figure><h1 id="Mat-转-IplImage"><a href="#Mat-转-IplImage" class="headerlink" title="Mat 转 IplImage"></a>Mat 转 IplImage</h1><h2 id="浅拷贝-1"><a href="#浅拷贝-1" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mat img = imread(./res/tmp.jpg);</span><br><span class="line">IplImage *src = &amp;IplImage(img);</span><br></pre></td></tr></table></figure><h2 id="深拷贝-即再复制一次数据"><a href="#深拷贝-即再复制一次数据" class="headerlink" title="深拷贝(即再复制一次数据)"></a>深拷贝(即再复制一次数据)</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Mat img = imread(./res/tmp.jpg);</span><br><span class="line">IplImage *src_tmp = &amp;IplImage(img);</span><br><span class="line">IplImage *src = cvCloneImage(src_tmp);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Mat 是OpenCV和C++的接口矩阵类，ImlImage是OpenCV和C语言的接口的结构体，但是C++程序有时候时候还是要用到ImlImage。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;浅拷贝是不需要释放内存的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;深拷贝才需要释放
      
    
    </summary>
    
      <category term="Opencv" scheme="https://loopvoid.github.io/categories/Opencv/"/>
    
    
      <category term="Opencv" scheme="https://loopvoid.github.io/tags/Opencv/"/>
    
  </entry>
  
  <entry>
    <title>Opencv截取屏幕(BitBlt API)</title>
    <link href="https://loopvoid.github.io/2018/01/29/Opencv%E6%88%AA%E5%8F%96%E5%B1%8F%E5%B9%95-BitBlt-API/"/>
    <id>https://loopvoid.github.io/2018/01/29/Opencv截取屏幕-BitBlt-API/</id>
    <published>2018-01-29T07:05:53.000Z</published>
    <updated>2019-08-06T06:40:42.898Z</updated>
    
    <content type="html"><![CDATA[<h1 id="截取整个屏幕"><a href="#截取整个屏幕" class="headerlink" title="截取整个屏幕"></a>截取整个屏幕</h1><p>直接获取整个屏幕当前显示画面，便于后期计算处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _MSC_VER</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment( linker, <span class="meta-string">"/subsystem:\"windows\" /entry:\"mainCRTStartup\""</span> )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _AFXDLL<span class="comment">//为了方便是用mfc类  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;afxwin.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/opencv.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line">LPVOID  screenCaptureData = <span class="literal">NULL</span>;</span><br><span class="line">HBITMAP hBitmap;</span><br><span class="line">HDC hDDC;</span><br><span class="line">HDC hCDC;</span><br><span class="line"><span class="keyword">int</span> nWidth;</span><br><span class="line"><span class="keyword">int</span> nHeight;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initGDI</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">nWidth = GetSystemMetrics(SM_CXSCREEN);<span class="comment">//得到屏幕的分辨率的x  </span></span><br><span class="line">nHeight = GetSystemMetrics(SM_CYSCREEN);<span class="comment">//得到屏幕分辨率的y  </span></span><br><span class="line">screenCaptureData = <span class="keyword">new</span> <span class="keyword">char</span>[nWidth*nHeight * <span class="number">4</span>];</span><br><span class="line"><span class="built_in">memset</span>(screenCaptureData, <span class="number">0</span>, nWidth);</span><br><span class="line"><span class="comment">// Get desktop DC, create a compatible dc, create a comaptible bitmap and select into compatible dc.  </span></span><br><span class="line">hDDC = GetDC(GetDesktopWindow());<span class="comment">//得到屏幕的dc  </span></span><br><span class="line">hCDC = CreateCompatibleDC(hDDC);<span class="comment">//  </span></span><br><span class="line">hBitmap = CreateCompatibleBitmap(hDDC, nWidth, nHeight);<span class="comment">//得到位图  </span></span><br><span class="line">SelectObject(hCDC, hBitmap); <span class="comment">//好像总得这么写。  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gdiScreenCapture</span><span class="params">(LPVOID screenCaptureData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">BitBlt(hCDC, <span class="number">0</span>, <span class="number">0</span>, nWidth, nHeight, hDDC, <span class="number">0</span>, <span class="number">0</span>, SRCCOPY);</span><br><span class="line">GetBitmapBits(hBitmap, nWidth*nHeight * <span class="number">4</span>, screenCaptureData);<span class="comment">//得到位图的数据，并存到screenCaptureData数组中。  </span></span><br><span class="line">IplImage *img_tmp = cvCreateImage(cvSize(nWidth, nHeight), <span class="number">8</span>, <span class="number">4</span>);<span class="comment">//创建一个rgba格式的IplImage,内容为空  </span></span><br><span class="line"><span class="built_in">memcpy</span>(img_tmp-&gt;imageData, screenCaptureData, nWidth*nHeight * <span class="number">4</span>);<span class="comment">//这样比较浪费时间，但写的方便,这里必须得是*4。  </span></span><br><span class="line">IplImage *img2_tmp = cvCreateImage(cvSize(nWidth, nHeight), <span class="number">8</span>, <span class="number">3</span>);<span class="comment">//创建一个bgr格式的IplImage，可以没有这个Img2这个变量。 </span></span><br><span class="line"></span><br><span class="line">cv::Mat img = cv::cvarrToMat(img_tmp);</span><br><span class="line">cv::Mat img2 = cv::cvarrToMat(img2_tmp);</span><br><span class="line"></span><br><span class="line">cvtColor(img, img2, CV_BGRA2BGR);</span><br><span class="line">imwrite(<span class="string">"rgba.jpg"</span>, img);</span><br><span class="line">cv::waitKey();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">initGDI();</span><br><span class="line">gdiScreenCapture(screenCaptureData);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;截取整个屏幕&quot;&gt;&lt;a href=&quot;#截取整个屏幕&quot; class=&quot;headerlink&quot; title=&quot;截取整个屏幕&quot;&gt;&lt;/a&gt;截取整个屏幕&lt;/h1&gt;&lt;p&gt;直接获取整个屏幕当前显示画面，便于后期计算处理。&lt;/p&gt;
&lt;figure class=&quot;highlight 
      
    
    </summary>
    
      <category term="Opencv" scheme="https://loopvoid.github.io/categories/Opencv/"/>
    
    
      <category term="Opencv" scheme="https://loopvoid.github.io/tags/Opencv/"/>
    
  </entry>
  
  <entry>
    <title>C++文件重定向</title>
    <link href="https://loopvoid.github.io/2018/01/02/C-%E6%96%87%E4%BB%B6%E9%87%8D%E5%AE%9A%E5%90%91/"/>
    <id>https://loopvoid.github.io/2018/01/02/C-文件重定向/</id>
    <published>2018-01-02T02:47:31.000Z</published>
    <updated>2019-08-06T06:56:59.891Z</updated>
    
    <content type="html"><![CDATA[<h1 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h1><p><strong>命令行使用 &lt; 和 &gt;</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func.exe &lt; infile.txt &gt; outfile.txt</span><br></pre></td></tr></table></figure><h1 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h1><p><strong>C++实现</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;ostream&gt; </span><br><span class="line">#include &lt;fstream&gt;   </span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123; </span><br><span class="line">    ifstream fin(&quot;input.txt&quot;);  // 已有输入文件</span><br><span class="line">    ofstream fout(&quot;output.txt&quot;);  //输出文件</span><br><span class="line"></span><br><span class="line">    streambuf *cinbackup;  </span><br><span class="line">    streambuf *coutbackup; </span><br><span class="line"></span><br><span class="line">    coutbackup= cout.rdbuf(fout.rdbuf());  //用 rdbuf() 重新定向</span><br><span class="line">    cinbackup= cin.rdbuf(fin.rdbuf());  //用 rdbuf() 重新定向</span><br><span class="line">    cout&lt;&lt;&quot;Hello world&quot;&lt;&lt;endl;   //去文件也</span><br><span class="line"></span><br><span class="line">    char line[100];  </span><br><span class="line">    cin&gt;&gt;line;  //从input.txt文件读入d</span><br><span class="line">    cout&lt;&lt;line&lt;&lt;endl;  //写入 output.txt</span><br><span class="line">    //恢复标准流缓冲区 </span><br><span class="line">    cin.rdbuf(cinbackup);  // 取消，恢复键盘输入</span><br><span class="line">    cout.rdbuf(coutbackup);  //取消，恢复屏幕输出</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;方法一&quot;&gt;&lt;a href=&quot;#方法一&quot; class=&quot;headerlink&quot; title=&quot;方法一&quot;&gt;&lt;/a&gt;方法一&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;命令行使用 &amp;lt; 和 &amp;gt;&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight c+
      
    
    </summary>
    
      <category term="Cpp" scheme="https://loopvoid.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://loopvoid.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://loopvoid.github.io/2017/11/29/G-%E7%BC%96%E8%AF%91%E6%A8%A1%E6%9D%BF%E7%B1%BB%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://loopvoid.github.io/2017/11/29/G-编译模板类的问题/</id>
    <published>2017-11-29T04:36:45.000Z</published>
    <updated>2019-08-06T06:55:16.348Z</updated>
    
    <content type="html"><![CDATA[<p><strong>g++目前不支持c++模板类 声明与实现分离，都要写到.h文件里面。</strong></p><p>以后记住了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;g++目前不支持c++模板类 声明与实现分离，都要写到.h文件里面。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以后记住了。&lt;/p&gt;

      
    
    </summary>
    
      <category term="Cpp" scheme="https://loopvoid.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://loopvoid.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>G++简单的编译生成动态链接文件</title>
    <link href="https://loopvoid.github.io/2017/11/08/G-%E7%AE%80%E5%8D%95%E7%9A%84%E7%BC%96%E8%AF%91%E7%94%9F%E6%88%90%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E6%96%87%E4%BB%B6/"/>
    <id>https://loopvoid.github.io/2017/11/08/G-简单的编译生成动态链接文件/</id>
    <published>2017-11-08T10:19:58.000Z</published>
    <updated>2019-08-06T06:54:40.350Z</updated>
    
    <content type="html"><![CDATA[<p>一个最简单的动态链接库程序，使用g++命令行编译。便于回忆，就把它记到Blog中。</p><h1 id="动态库建立"><a href="#动态库建立" class="headerlink" title="动态库建立"></a><em>动态库建立</em></h1><p>编译成obj文件：</p><p><em>g++ -c -o dll.obj dll.cpp</em></p><p>链接obj，生成dll: </p><p><em>g++ -shared -o dll.so dll.obj</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* file: dll.h */</span> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __dll_h__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __dll_h__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __MY_DLL_LIB__</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> DLL_EXPORT extern <span class="meta-string">"C"</span> __declspec(dllexport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span>     </span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> DLL_EXPORT extern <span class="meta-string">"C"</span> __declspec(dllimport)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">DLL_EXPORT <span class="keyword">int</span> <span class="title">mymax</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* file: dll.cpp */</span> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __MY_DLL_LIB__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"dll.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mymax</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y ? x : y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="动态库调用"><a href="#动态库调用" class="headerlink" title="动态库调用"></a><em>动态库调用</em></h1><p>调用动态库：<br>直接编译成exe: </p><p><em>g++ main.cpp dll.so -o main.exe</em></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* file: main.cpp */</span> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"dll.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; mymax(a, b) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一个最简单的动态链接库程序，使用g++命令行编译。便于回忆，就把它记到Blog中。&lt;/p&gt;
&lt;h1 id=&quot;动态库建立&quot;&gt;&lt;a href=&quot;#动态库建立&quot; class=&quot;headerlink&quot; title=&quot;动态库建立&quot;&gt;&lt;/a&gt;&lt;em&gt;动态库建立&lt;/em&gt;&lt;/h1&gt;&lt;p&gt;
      
    
    </summary>
    
      <category term="Cpp" scheme="https://loopvoid.github.io/categories/Cpp/"/>
    
    
      <category term="Cpp" scheme="https://loopvoid.github.io/tags/Cpp/"/>
    
  </entry>
  
  <entry>
    <title>Linux多线程编程</title>
    <link href="https://loopvoid.github.io/2017/07/05/Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
    <id>https://loopvoid.github.io/2017/07/05/Linux多线程编程/</id>
    <published>2017-07-05T07:37:18.000Z</published>
    <updated>2019-08-06T06:47:22.088Z</updated>
    
    <content type="html"><![CDATA[<h1 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h1><p>使用<strong>pthread_create</strong>函数创建线程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span> <span class="params">(<span class="keyword">pthread_t</span> *__restrict __newthread,<span class="comment">//新创建的线程ID</span></span></span></span><br><span class="line"><span class="function"><span class="params">              __const <span class="keyword">pthread_attr_t</span> *__restrict __attr,<span class="comment">//线程属性</span></span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">void</span> *(*__start_routine) (<span class="keyword">void</span> *),<span class="comment">//新创建的线程从start_routine开始执行</span></span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">void</span> *__restrict __arg)</span><span class="comment">//执行函数的参数</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//返回值：成功-0，失败-返回错误编号</span></span></span><br><span class="line"><span class="function"><span class="comment">//用strerror(errno)函数得到错误信息。</span></span></span><br></pre></td></tr></table></figure><p>例程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> err; </span><br><span class="line"><span class="keyword">pthread_t</span> tid1;</span><br><span class="line">err = pthread_create(&amp;tid1, <span class="literal">NULL</span>, thread_func, <span class="literal">NULL</span>);<span class="comment">//创建线程</span></span><br></pre></td></tr></table></figure><h1 id="终止线程"><a href="#终止线程" class="headerlink" title="终止线程"></a>终止线程</h1><p>​    三种方式线程从执行函数返回，返回值是线程的退出码线程被同一进程的其他线程取消调用<strong>pthread_exit()</strong>函数退出。这里不是调用exit，因为线程调用exit函数，会导致线程所在的进程退出。</p><h1 id="例程一"><a href="#例程一" class="headerlink" title="例程一"></a>例程一</h1><p>​   启动两个线程，一个线程对全局变量num执行加1操作，执行五百次，一个线程对全局变量执行减1操作，同样执行五次。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">add</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//线程执行函数，执行5次加法</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, tmp;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = num + <span class="number">1</span>;</span><br><span class="line">        num = tmp;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"add+1,result is:%d\n"</span>, num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">void</span> *)<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">sub</span><span class="params">(<span class="keyword">void</span> *arg)</span><span class="comment">//线程执行函数，执行5次减法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, tmp;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = num - <span class="number">1</span>;</span><br><span class="line">        num = tmp;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"sub-1,result is:%d\n"</span>, num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">void</span> *)<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid1, tid2;</span><br><span class="line">    <span class="keyword">int</span> err;</span><br><span class="line">    <span class="keyword">void</span> *tret;</span><br><span class="line">    err = pthread_create(&amp;tid1, <span class="literal">NULL</span>, add, <span class="literal">NULL</span>);<span class="comment">//创建线程</span></span><br><span class="line">    <span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"pthread_create error:%s\n"</span>, strerror(err));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    err = pthread_create(&amp;tid2, <span class="literal">NULL</span>, sub, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"pthread_create error:%s\n"</span>, strerror(err));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    err = pthread_join(tid1, &amp;tret);<span class="comment">//阻塞等待线程id为tid1的线程，直到该线程退出</span></span><br><span class="line">    <span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"can not join with thread1:%s\n"</span>, strerror(err));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"thread 1 exit code %d\n"</span>, (<span class="keyword">int</span>)(<span class="keyword">intptr_t</span>)tret);</span><br><span class="line">    err = pthread_join(tid2, &amp;tret);</span><br><span class="line">    <span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"can not join with thread1:%s\n"</span>, strerror(err));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"thread 2 exit code %d\n"</span>, (<span class="keyword">int</span>)(<span class="keyword">intptr_t</span>)tret);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译命令: g++ -o 1_example 1_example.cpp -lpthread</strong></p><p><strong>问题</strong>: 两个线程可以对同一变量进行修改。假如线程1执行tmp=4+1后，被系统中断，此时线程2对num=5执行了减一操作，当线程1恢复，在执行num=tmp=5。而正确结果应为4。所以当多个线程对共享区域进行修改时，应该采用<strong>同步</strong>的方式。</p><h1 id="线程同步-三种方式"><a href="#线程同步-三种方式" class="headerlink" title="线程同步(三种方式)"></a>线程同步(三种方式)</h1><h2 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h2><p>互斥量用pthread_mutex_t数据类型来表示。</p><blockquote><p>第一种：赋值为常量<strong>PTHREAD_MUTEX_INITIALIZER</strong>；<br>第二种，当互斥量为动态分配是，使用<strong>pthread_mutex_init</strong>函数进行初始化，使用<strong>pthread_mutex_destroy</strong>函数销毁。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span> <span class="params">(<span class="keyword">pthread_mutex_t</span> *__mutex,</span></span></span><br><span class="line"><span class="function"><span class="params">                __const <span class="keyword">pthread_mutexattr_t</span> *__mutexattr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span> <span class="params">(<span class="keyword">pthread_mutex_t</span> *__mutex)</span></span>;</span><br><span class="line"><span class="comment">//返回值：成功-0，失败-错误编号</span></span><br></pre></td></tr></table></figure><p>加解锁加锁调用<strong>pthread_mutex_lock</strong><br>解锁调用<strong>pthread_mutex_unlock</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line">int pthread_mutex_lock (pthread_mutex_t *__mutex)；</span><br><span class="line">int pthread_mutex_unlock (pthread_mutex_t *__mutex)；</span><br></pre></td></tr></table></figure><p>使用互斥修改程序的<strong>add</strong>和<strong>sub</strong>两个函数:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_mutex_t</span> mylock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">add</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, tmp;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; <span class="number">500</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mylock);</span><br><span class="line">        tmp = num + <span class="number">1</span>;</span><br><span class="line">        num = tmp;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"+1,result is:%d\n"</span>, num);</span><br><span class="line">        pthread_mutex_unlock(&amp;mylock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">void</span> *)<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">sub</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, tmp;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; <span class="number">500</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mylock);</span><br><span class="line">        tmp = num - <span class="number">1</span>;</span><br><span class="line">        num = tmp;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"-1,result is:%d\n"</span>, num);</span><br><span class="line">        pthread_mutex_unlock(&amp;mylock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">void</span> *)<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>允许多个线程同时读，只能有一个线程同时写。适用于读的次数远大于写的情况。  </p><p>读写锁初始化： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_init</span> <span class="params">(<span class="keyword">pthread_rwlock_t</span> *__restrict __rwlock,</span></span></span><br><span class="line"><span class="function"><span class="params">                __const <span class="keyword">pthread_rwlockattr_t</span> *__restrict__attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_destroy</span> <span class="params">(<span class="keyword">pthread_rwlock_t</span> *__rwlock)</span></span>;</span><br><span class="line"><span class="comment">//返回值：成功--0，失败-错误编号</span></span><br></pre></td></tr></table></figure><p><strong>加锁</strong>，分为<strong>读加锁</strong>和<strong>写加锁</strong>。</p><p><strong>解锁</strong>使用同一个函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读加锁：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_rdlock</span> <span class="params">(<span class="keyword">pthread_rwlock_t</span> *__rwlock)</span></span></span><br><span class="line"><span class="function"><span class="comment">//写加锁：</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_wrlock</span> <span class="params">(<span class="keyword">pthread_rwlock_t</span> *__rwlock)</span></span></span><br><span class="line"><span class="function"><span class="comment">//解锁用同一个函数：</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_unlock</span> <span class="params">(<span class="keyword">pthread_rwlock_t</span> *__rwlock)</span></span></span><br></pre></td></tr></table></figure><h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><p>条件变量用pthread_cond_t数据类型表示。</p><p>条件变量本身由互斥量保护，所以在改变条件状态前必须锁住互斥量。</p><h3 id="条件变量初始化"><a href="#条件变量初始化" class="headerlink" title="条件变量初始化"></a>条件变量初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一种，赋值常量PTHREAD_COND_INITIALIZER；</span></span><br><span class="line"><span class="comment">//第二种，使用pthread_cond_init函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span> <span class="params">(<span class="keyword">pthread_cond_t</span> *__restrict __cond,</span></span></span><br><span class="line"><span class="function"><span class="params">   __const <span class="keyword">pthread_condattr_t</span> *__restrict__cond_attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_destroy</span> <span class="params">(<span class="keyword">pthread_cond_t</span> *__cond)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="条件等待"><a href="#条件等待" class="headerlink" title="条件等待"></a>条件等待</h3><p>使用pthread_cond_wait等待条件为真。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pthread_cond_wait (<span class="keyword">pthread_cond_t</span> *__restrict __cond,<span class="keyword">pthread_mutex_t</span> *__restrict __mutex)</span><br></pre></td></tr></table></figure><p>这里需要注意的是，调用pthread_cond_wait传递的互斥量已锁定，pthread_cond_wait将调用线程放入等待条件的线程列表，然后释放互斥量，在pthread_cond_wait返回时，再次锁定互斥量。</p><h3 id="唤醒线程"><a href="#唤醒线程" class="headerlink" title="唤醒线程"></a>唤醒线程</h3><p>pthread_cond_signal唤醒等待该条件的某个线程，pthread_cond_broadcast唤醒等待该条件的所有线程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span> <span class="params">(<span class="keyword">pthread_cond_t</span> *__cond)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span> <span class="params">(<span class="keyword">pthread_cond_t</span> *__cond)</span></span></span><br></pre></td></tr></table></figure><h1 id="例程二"><a href="#例程二" class="headerlink" title="例程二"></a>例程二</h1><p>主线程启动4个线程，每个线程有一个参数i（i=生成顺序），无论线程的启动顺序如何，执行顺序只能为，线程0、线程1、线程2、线程3。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEBUG 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mylock = PTHREAD_MUTEX_INITIALIZER;<span class="comment">//互斥量</span></span><br><span class="line"><span class="keyword">pthread_cond_t</span> qready = PTHREAD_COND_INITIALIZER;<span class="comment">//条件变量--本身由互斥量保护，所以在改变条件状态前必须锁住互斥量。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">thread_func</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = (<span class="keyword">int</span>)arg;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    sleep(<span class="number">5</span> - i);<span class="comment">//线程睡眠,然最先生成的线程，最后苏醒</span></span><br><span class="line">    pthread_mutex_lock(&amp;mylock);<span class="comment">//调用pthread_cond_wait前，必须获得互斥锁</span></span><br><span class="line">    <span class="keyword">while</span> (i != num)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"thread %d waiting\n"</span>, i);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        ret = pthread_cond_wait(&amp;qready, &amp;mylock);<span class="comment">//该函数把线程放入等待条件的线程列表，然后对互斥锁进行解锁，这两部都是原子操作。并且在pthread_cond_wait返回时，互斥量再次锁住。</span></span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"thread %d wait success\n"</span>, i);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">#ifdef DEBUG</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"thread %d wait failed:%s\n"</span>, i, strerror(ret));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"thread %d is running \n"</span>, i);</span><br><span class="line">    num++;</span><br><span class="line">    pthread_mutex_unlock(&amp;mylock);<span class="comment">//解锁</span></span><br><span class="line">    pthread_cond_broadcast(&amp;qready);<span class="comment">//唤醒等待该条件的所有线程</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> *)<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, err;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">void</span> *tret;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        err = pthread_create(&amp;tid[i], <span class="literal">NULL</span>, thread_func, (<span class="keyword">void</span> *)i);<span class="comment">//创建线程</span></span><br><span class="line">        <span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"thread_create error:%s\n"</span>, strerror(err));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        err = pthread_join(tid[i], &amp;tret);<span class="comment">//线程阻塞</span></span><br><span class="line">        <span class="keyword">if</span> (err != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"can not join with thread %d:%s\n"</span>, i, strerror(err));</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在非DEBUG模式，执行结果如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">jack@desktop:  g++ -o 1_example 1_example.cpp -lpthread</span><br><span class="line">jack@desktop:  ./1_example</span><br><span class="line">jack@desktop:  thread 0 is running</span><br><span class="line">jack@desktop:  thread 1 is running</span><br><span class="line">jack@desktop:  thread 2 is running</span><br><span class="line">jack@desktop:  thread 3 is running</span><br><span class="line">jack@desktop:  thread 4 is running</span><br></pre></td></tr></table></figure><p>在DEBUG模式，执行结果如下所示:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">jack@desktop:  g++ -o 1example 1example.cpp -lpthread</span><br><span class="line">jack@desktop:  ./1_example</span><br><span class="line">jack@desktop:  thread 3 waiting</span><br><span class="line">jack@desktop:  thread 2 waiting</span><br><span class="line">jack@desktop:  thread 1 waiting</span><br><span class="line">jack@desktop:  thread 0 is running</span><br><span class="line">jack@desktop:  thread 3 wait success</span><br><span class="line">jack@desktop:  thread 3 waiting</span><br><span class="line">jack@desktop:  thread 2 wait success</span><br><span class="line">jack@desktop:  thread 2 waiting</span><br><span class="line">jack@desktop:  thread 1 wait success</span><br><span class="line">jack@desktop:  thread 1 running</span><br><span class="line">jack@desktop:  thread 3 wait success</span><br><span class="line">jack@desktop:  thread 3 waiting</span><br><span class="line">jack@desktop:  thread 2 wait success</span><br><span class="line">jack@desktop:  thread 2 running</span><br><span class="line">jack@desktop:  thread 3 wait success</span><br><span class="line">jack@desktop:  thread 3 running</span><br></pre></td></tr></table></figure><p>​   在DEBUG模式可以看出，线程3先被唤醒，然后执行pthread_cond_wait（输出thread 3 waiting)，此时在pthread_cond_wait中先解锁互斥量，然后进入等待状态。这是thread 2加锁互斥量成功，进入pthread_cond_wait(输出thread 2 waiting） ,同样解锁互斥量，然后进入等待状态。直到线程0，全局变量与线程参数i一致，满足条件，不进入条件等待，输出thread 0 is running。全局变量num执行加1操作，解锁互斥量，然后唤醒所有等待该条件的线程。thread 3 被唤醒，输出thread 3 wait success。但是不满足条件，再次执行pthread_cond_wait。如此执行下去，满足条件的线程执行，不满足条件的线程等待。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;创建线程&quot;&gt;&lt;a href=&quot;#创建线程&quot; class=&quot;headerlink&quot; title=&quot;创建线程&quot;&gt;&lt;/a&gt;创建线程&lt;/h1&gt;&lt;p&gt;使用&lt;strong&gt;pthread_create&lt;/strong&gt;函数创建线程。&lt;/p&gt;
&lt;figure class=&quot;hi
      
    
    </summary>
    
      <category term="Linux" scheme="https://loopvoid.github.io/categories/Linux/"/>
    
    
      <category term="Cpp" scheme="https://loopvoid.github.io/tags/Cpp/"/>
    
      <category term="Pthread" scheme="https://loopvoid.github.io/tags/Pthread/"/>
    
  </entry>
  
  <entry>
    <title>欧氏距离和余弦相似度</title>
    <link href="https://loopvoid.github.io/2017/04/22/%E6%AC%A7%E6%B0%8F%E8%B7%9D%E7%A6%BB%E5%92%8C%E4%BD%99%E5%BC%A6%E7%9B%B8%E4%BC%BC%E5%BA%A6/"/>
    <id>https://loopvoid.github.io/2017/04/22/欧氏距离和余弦相似度/</id>
    <published>2017-04-22T03:28:42.000Z</published>
    <updated>2019-08-06T04:03:03.980Z</updated>
    
    <content type="html"><![CDATA[<p>两者相同的地方，就是在机器学习中都可以用来计算相似度，但是两者的含义有很大差别，以我的理解就是：</p><ul><li>前者是看成坐标系中两个 <strong>点</strong> ，来计算两点之间的 距离 ;</li><li>后者是看成坐标系中两个 <strong>向量</strong> ，来计算两向量之间的 <strong>夹角</strong> 。</li><li>前者因为是 <strong>点</strong> ，所以一般指 <strong>位置</strong> 上的差别，即 <strong>距离</strong> ；</li><li>后者因为是 <strong>向量</strong> ，所以一般指 <strong>方向</strong> 上的差别，即所成 <strong>夹角</strong> 。</li></ul><p>如下图所示：<br><img src="//loopvoid.github.io/2017/04/22/欧氏距离和余弦相似度/01.jpg" alt="01"></p><p>数据项A和B在坐标图中当做点时，两者相似度为距离dist(A,B)，可通过欧氏距离（也叫欧几里得距离）公式计算：</p><p>$$dist(X,Y)=\sqrt{\sum_{i=1}^{n}(X_i-Y_i)^2}$$</p><p>当做向量时，两者相似度为cosθ，可通过余弦公式计算：</p><p>$$cos\theta = \frac{\sum_{i=1}^{n}(A_i \times B_i)}{\sqrt(\sum_{i=1}^{n}(A_i)^2) \times \sqrt(\sum_{i=1}^{n}(B_i)^2)}= \frac{A^T \cdot B}{||A||\times ||B||} $$</p><p>假设$||A||$、$||B||$表示向量A、B的L2范数，例如向量[1,2,3]的2范数为：</p><p>$$\sqrt{1^2+2^2=3^3} = \sqrt{14}$$<br>numpy中提供了范数的计算工具： linalg.norm()</p><p>所以计算$cosθ$起来非常方便（假定A、B均为列向量）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">num = float(A.T * B) <span class="comment">#若为行向量则 A * B.T</span></span><br><span class="line">denom = linalg.norm(A) * linalg.norm(B)</span><br><span class="line">cos = num / denom <span class="comment">#余弦值</span></span><br><span class="line">sim = <span class="number">0.5</span> + <span class="number">0.5</span> * cos <span class="comment">#归一化</span></span><br></pre></td></tr></table></figure><p>因为有了linalg.norm()，欧氏距离公式实现起来更为方便：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dist = linalg.norm(A - B)</span><br><span class="line">sim = <span class="number">1.0</span> / (<span class="number">1.0</span> + dist) <span class="comment">#归一化</span></span><br></pre></td></tr></table></figure><p>关于归一化：</p><p>因为余弦值的范围是 [-1,+1] ，相似度计算时一般需要把值归一化到 [0,1]，一般通过如下方式：</p><p>$$sim = 0.5 + 0.5 * \cosθ $$<br>若在欧氏距离公式中，取值范围会很大，一般通过如下方式归一化：</p><p>$$sim = \frac{1}{1+dist(x,y)}$$</p><p>说完了原理，简单扯下实际意义，举个栗子吧：</p><p>例如某T恤从100块降到了50块（A(100,50)），某西装从1000块降到了500块（B(1000,500)）</p><p>那么T恤和西装都是降价了50%，两者的价格变动趋势一致，余弦相似度为最大值，即两者有很高的 变化趋势相似度</p><p>但是从商品价格本身的角度来说，两者相差了好几百块的差距，欧氏距离较大，即两者有较低的 价格相似度。</p><p>参考:<a href="http://blog.csdn.net/linvo/article/details/9333019?utm_source=tuicool&utm_medium=referral" target="_blank" rel="noopener">欧氏距离和余弦相似度</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;两者相同的地方，就是在机器学习中都可以用来计算相似度，但是两者的含义有很大差别，以我的理解就是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前者是看成坐标系中两个 &lt;strong&gt;点&lt;/strong&gt; ，来计算两点之间的 距离 ;&lt;/li&gt;
&lt;li&gt;后者是看成坐标系中两个 &lt;strong&gt;
      
    
    </summary>
    
      <category term="基础知识" scheme="https://loopvoid.github.io/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="欧氏距离" scheme="https://loopvoid.github.io/tags/%E6%AC%A7%E6%B0%8F%E8%B7%9D%E7%A6%BB/"/>
    
      <category term="余弦相似度" scheme="https://loopvoid.github.io/tags/%E4%BD%99%E5%BC%A6%E7%9B%B8%E4%BC%BC%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>Opencv实现Kalman滤波器</title>
    <link href="https://loopvoid.github.io/2017/03/26/Opencv%E5%AE%9E%E7%8E%B0Kalman%E6%BB%A4%E6%B3%A2%E5%99%A8/"/>
    <id>https://loopvoid.github.io/2017/03/26/Opencv实现Kalman滤波器/</id>
    <published>2017-03-26T02:26:33.000Z</published>
    <updated>2019-08-06T06:10:31.652Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>卡尔曼滤波是一种高效率的<strong>递归滤波器(自回归滤波器)</strong>, 它能够从一系列的不完全及包含噪声的测量中，估计动态系统的状态。卡尔曼滤波的一个典型实例是从一组有限的，包含噪声的，对物体位置的观察序列（可能有偏差）预测出物体的位置的坐标及速度。<br>这种滤波方法以它的发明者<strong>鲁道夫.E.卡尔曼（Rudolph E. Kalman）</strong>命名，但是根据文献可知实际上<strong>Peter Swerling</strong>在更早之前就提出了一种类似的算法。<br><strong>斯坦利.施密特(Stanley Schmidt)</strong>首次实现了卡尔曼滤波器。卡尔曼在<strong>NASA埃姆斯研究中心</strong>访问时，发现他的方法对于解决阿波罗计划的轨道预测很有用，后来阿波罗飞船的导航电脑便使用了这种滤波器。 关于这种滤波器的论文由<strong>Swerling (1958)、Kalman (1960)与 Kalman and Bucy (1961)</strong>发表。<br>目前,卡尔曼滤波已经有很多不同的实现.卡尔曼最初提出的形式现在一般称为简单卡尔曼滤波器。除此以外，还有施密特扩展滤波器、信息滤波器以及很多<strong>Bierman</strong>, <strong>Thornton</strong> 开发的<strong>平方根滤波器</strong>的变种。也许最常见的卡尔曼滤波器是<strong>锁相环</strong>，它在收音机、计算机和几乎任何视频或通讯设备中广泛存在。</p><h1 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h1><h2 id="基本动态系统模型"><a href="#基本动态系统模型" class="headerlink" title="基本动态系统模型"></a>基本动态系统模型</h2><p>卡尔曼滤波建立在<strong>线性代数</strong>和<strong>隐马尔可夫模型</strong>(hidden Markov model)上。其基本动态系统可以用一个<strong>马尔可夫链</strong>表示，该马尔可夫链建立在一个被<strong>高斯噪声(即正态分布的噪声)</strong>干扰的线性算子上的。系统的状态可以用一个元素为实数的<strong>向量</strong>表示。 随着离散时间的每一个增加,这个线性算子就会作用在当前状态上，产生一个新的状态,并也会带入一些噪声,同时系统的一些已知的控制器的控制信息也会被加入。同时，另一个受<strong>噪声干扰</strong>的<strong>线性算子</strong>产生出这些<strong>隐含状态</strong>的可见输出。<br>模型图：<br><img src="//loopvoid.github.io/2017/03/26/Opencv实现Kalman滤波器/KalmanModelImg.png" alt="KalmanModelImg"><br>为了从一系列有噪声的观察数据中用卡尔曼滤波器估计出被观察过程的内部状态，我们必须把这个过程在<strong>卡尔曼滤波</strong>的框架下建立模型。也就是说对于每一步<strong>k</strong>，定义矩阵。<br>例如：<strong>KalmanFilter KF(stateNum, measureNum, 0);</strong></p><p><strong>Fk : KF.transitionMatrix ，Hk : KF.measurementMatrix</strong><br><strong>Qk : KF.processNoiseCov ， Rk  : KF.measurementNoiseCov</strong><br><strong>Pk : KF.errorCovPost ， Bk : KF.ontrolMatrix</strong></p><p>尔曼滤波模型假设k时刻的真实状态是从<strong>(k − 1)</strong>时刻的状态演化而来，符合下式<br>$$ X_k = F_k * X_{k-1} + B_k * u_k + w_k $$</p><p>$F_k$是作用在$X_{k−1}$上的状态变换模型（矩阵，矢量）<br>$B_k$是作用在控制器向量uk上的输入–控制模型（矩阵,矢量）<br>$w_k$是过程噪声，并假定其符合均值为零，<strong>协方差矩阵</strong>为$Q_k$的<strong>多元正态分布</strong>。</p><p>$$ w_{k} - N(0,Q_k) $$<br>时刻<strong>k</strong>，对真实状态 $X_k$的一个测量$Z_k$满足下式<br>$$ Z_k = H_k * X_k + v_k $$<br>其中<strong>Hk</strong> 是<strong>观测模型</strong>,它把<strong>真实状态空间</strong>映射成<strong>观测空间</strong>，<strong>vk</strong>  是<strong>观测噪声</strong>，其均值为零，<strong>协方差矩阵</strong>为<strong>Rk</strong>,且服从<strong>正态分布</strong>。</p><p>$$ w_k - N(0,Q_k) $$<br>初始状态以及每一时刻的噪声${x_0, w_1, …, w_k, v_1 …v_k}$都认为是互相独立的.</p><h2 id="卡尔曼滤波器"><a href="#卡尔曼滤波器" class="headerlink" title="卡尔曼滤波器"></a>卡尔曼滤波器</h2><p>卡尔曼滤波是一种<strong>递归</strong>的估计，即只要获知<strong>上一时刻状态</strong>的<strong>估计值</strong>以及<strong>当前状态</strong>的<strong>观测值</strong>就可以计算出<strong>当前状态的估计值</strong>，因此不需要记录观测或者估计的历史信息。卡尔曼滤波器与大多数滤波器不同之处，在于它是一种纯粹的<strong>时域滤波器</strong>，它不需要像低通滤波器等频域滤波器那样，需要在频域设计再转换到时域实现。<br>卡尔曼滤波器的状态由以下两个变量表示：<br>$X_k|k$：在时刻k 的状态的估计<br>$P_k|k$：误差相关矩阵，度量估计值的精确程度。</p><p>卡尔曼滤波器的操作包括两个阶段：<strong>预测</strong>与<strong>更新</strong>。<br>在预测阶段，滤波器使用上一状态的估计，做出对当前状态的估计。<br>在更新阶段，滤波器利用对当前状态的观测值优化在预测阶段获得的预测值，以获得一个更精确的新估计值。<br><strong>预测 predict：</strong><br><strong>Mat prediction = KF.predict();</strong></p><p>$\hat{X}<em>{k|k-1} = F_k\hat{X}</em>{k-1|k-1}+B_ku_k$(预测状态)<br>$P_{k|k-1} = F_kP_{k-1|k-1}F_k^T+B_ku_k $(预测估计协方差矩阵)<br>可参考：<a href="http://www.cs.unc.edu/~welch/media/pdf/kalman_intro.pdf" target="_blank" rel="noopener">http://www.cs.unc.edu/~welch/media/pdf/kalman_intro.pdf</a></p><p><strong>更新 updata：</strong><br><strong>KF.correct(measurement);</strong><br><strong>测量余量，measurement residual：</strong><br>$$Y_{k} = z_{k}-H_{k}\hat{x}<em>{k|k-1}$$<br><strong>测量余量协方差:</strong><br>$$S</em>{k} = H_{k}P_{k-1|k-1}H_{k}^{T}+R_{k}$$<br><strong>最优卡尔曼增益:</strong><br>$$K_{k} = P_{k|k-1}H_{k}^{T}+S_{k}^{-1}$$<br><strong>更新的状态估计:</strong><br>$$\hat{X}<em>{k|k} = \hat{X}</em>{k|k-1}+K_{k}Y_{k}$$<br><strong>更新的协方差估计:</strong><br>$$P_{k|k} = (I-K_{k}H_{k})P_{k|k-1}$$</p><p>使用上述公式计算$P_k|k$仅在最优卡尔曼增益的时候有效。使用其他增益的话，公式要复杂一些，请参见推导。</p><h2 id="不变量-Invariant"><a href="#不变量-Invariant" class="headerlink" title="不变量(Invariant)"></a>不变量(Invariant)</h2><p>如果模型准确，而且$X_0|0$与$P_0|0$的值准确的反映了最初状态的分布，那么以下不变量就保持不变：所有估计的误差均值为零<br>$$E[X_{k}-\hat{x}<em>{k|k}] =  E[X</em>{k}-\hat{x}<em>{k|k-1}]$$<br>$$E[Y</em>{k}] = 0$$<br>且 <strong>协方差矩阵</strong> 准确的反映了估计的协方差:<br>$$P_{k|k} = cov(X_{k}-\hat{X}<em>{k|k})$$<br>$$P</em>{k|k-1} = cov(X_{k}-\hat{X}<em>{k|k-1})$$<br>$$S</em>{k} = cov(Y_{k})$$</p><p>其中，<strong>E[a]</strong>表示a的期望值,<strong>$$cov(a)=E[aa^T]$$</strong></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><h2 id="class-Kalman"><a href="#class-Kalman" class="headerlink" title="class Kalman"></a>class Kalman</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CV_EXPORTS_W</span> <span class="title">KalmanFilter</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="comment">//! the default constructor  </span></span><br><span class="line">    <span class="function">CV_WRAP <span class="title">KalmanFilter</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="comment">//! the full constructor taking the dimensionality of the state, of the measurement and of the control vector  </span></span><br><span class="line">    <span class="function">CV_WRAP <span class="title">KalmanFilter</span><span class="params">(<span class="keyword">int</span> dynamParams, <span class="keyword">int</span> measureParams, <span class="keyword">int</span> controlParams=<span class="number">0</span>, <span class="keyword">int</span> type=CV_32F)</span></span>;  </span><br><span class="line">    <span class="comment">//! re-initializes Kalman filter. The previous content is destroyed.  </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> dynamParams, <span class="keyword">int</span> measureParams, <span class="keyword">int</span> controlParams=<span class="number">0</span>, <span class="keyword">int</span> type=CV_32F)</span></span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">//! computes predicted state  </span></span><br><span class="line">    <span class="function">CV_WRAP <span class="keyword">const</span> Mat&amp; <span class="title">predict</span><span class="params">(<span class="keyword">const</span> Mat&amp; control=Mat())</span></span>;  </span><br><span class="line">    <span class="comment">//! updates the predicted state from the measurement  </span></span><br><span class="line">    <span class="function">CV_WRAP <span class="keyword">const</span> Mat&amp; <span class="title">correct</span><span class="params">(<span class="keyword">const</span> Mat&amp; measurement)</span></span>;  </span><br><span class="line">  </span><br><span class="line">    Mat statePre;           <span class="comment">//!&lt; predicted state (x'(k)): x(k)=A*x(k-1)+B*u(k)  </span></span><br><span class="line">    Mat statePost;          <span class="comment">//!&lt; corrected state (x(k)): x(k)=x'(k)+K(k)*(z(k)-H*x'(k))  </span></span><br><span class="line">    Mat transitionMatrix;   <span class="comment">//!&lt; state transition matrix (A)  </span></span><br><span class="line">    Mat controlMatrix;      <span class="comment">//!&lt; control matrix (B) (not used if there is no control)  </span></span><br><span class="line">    Mat measurementMatrix;  <span class="comment">//!&lt; measurement matrix (H)  </span></span><br><span class="line">    Mat processNoiseCov;    <span class="comment">//!&lt; process noise covariance matrix (Q)  </span></span><br><span class="line">    Mat measurementNoiseCov;<span class="comment">//!&lt; measurement noise covariance matrix (R)  </span></span><br><span class="line">    Mat errorCovPre;        <span class="comment">//!&lt; priori error estimate covariance matrix (P'(k)): P'(k)=A*P(k-1)*At + Q)*/  </span></span><br><span class="line">    Mat gain;               <span class="comment">//!&lt; Kalman gain matrix (K(k)): K(k)=P'(k)*Ht*inv(H*P'(k)*Ht+R)  </span></span><br><span class="line">    Mat errorCovPost;       <span class="comment">//!&lt; posteriori error estimate covariance matrix (P(k)): P(k)=(I-K(k)*H)*P'(k)  </span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">// temporary matrices  </span></span><br><span class="line">    Mat temp1;  </span><br><span class="line">    Mat temp2;  </span><br><span class="line">    Mat temp3;  </span><br><span class="line">    Mat temp4;  </span><br><span class="line">    Mat temp5;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="sample-kalman-cpp"><a href="#sample-kalman-cpp" class="headerlink" title="sample\kalman.cpp"></a>sample\kalman.cpp</h2><p>1个1维点的运动跟踪，虽然这个点是在2维平面中运动，但由于它是在一个圆弧上运动，只有一个自由度，角度，所以还是1维的。还是一个匀速运动，建立匀速运动模型，设定状态变量x = [ x1, x2 ] = [ 角度，角速度 ]</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/video/tracking.hpp"</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/highgui/highgui.hpp"</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> Point <span class="title">calcPoint</span><span class="params">(Point2f center, <span class="keyword">double</span> R, <span class="keyword">double</span> angle)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> center + Point2f((<span class="keyword">float</span>)<span class="built_in">cos</span>(angle), (<span class="keyword">float</span>)-<span class="built_in">sin</span>(angle))*(<span class="keyword">float</span>)R;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">help</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">"   Tracking of rotating point.\n"</span>  </span><br><span class="line"><span class="string">"   Rotation speed is constant.\n"</span>  </span><br><span class="line"><span class="string">"   Both state and measurements vectors are 1D (a point angle),\n"</span>  </span><br><span class="line"><span class="string">"   Measurement is the real point angle + gaussian noise.\n"</span>  </span><br><span class="line"><span class="string">"   The real and the estimated points are connected with yellow line segment,\n"</span>  </span><br><span class="line"><span class="string">"   the real and the measured points are connected with red line segment.\n"</span>  </span><br><span class="line"><span class="string">"   (if Kalman filter works correctly,\n"</span>  </span><br><span class="line"><span class="string">"    the yellow segment should be shorter than the red one).\n"</span>  </span><br><span class="line">            <span class="string">"\n"</span>  </span><br><span class="line"><span class="string">"   Pressing any key (except ESC) will reset the tracking with a different speed.\n"</span>  </span><br><span class="line"><span class="string">"   Pressing ESC will stop the program.\n"</span>  </span><br><span class="line">            );  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">char</span>**)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    help();  </span><br><span class="line">    <span class="function">Mat <span class="title">img</span><span class="params">(<span class="number">500</span>, <span class="number">500</span>, CV_8UC3)</span></span>;  </span><br><span class="line">    <span class="function">KalmanFilter <span class="title">KF</span><span class="params">(<span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>)</span></span>;  </span><br><span class="line">    <span class="function">Mat <span class="title">state</span><span class="params">(<span class="number">2</span>, <span class="number">1</span>, CV_32F)</span></span>; <span class="comment">/* (phi, delta_phi) */</span>  </span><br><span class="line">    <span class="function">Mat <span class="title">processNoise</span><span class="params">(<span class="number">2</span>, <span class="number">1</span>, CV_32F)</span></span>;  </span><br><span class="line">    Mat measurement = Mat::zeros(<span class="number">1</span>, <span class="number">1</span>, CV_32F);  </span><br><span class="line">    <span class="keyword">char</span> code = (<span class="keyword">char</span>)<span class="number">-1</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span>(;;)  </span><br><span class="line">    &#123;  </span><br><span class="line">        randn( state, Scalar::all(<span class="number">0</span>), Scalar::all(<span class="number">0.1</span>) );<span class="comment">//随机生成一个矩阵，期望是0，标准差为0.1;  </span></span><br><span class="line">        KF.transitionMatrix = *(Mat_&lt;<span class="keyword">float</span>&gt;(<span class="number">2</span>, <span class="number">2</span>) &lt;&lt; <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>);<span class="comment">//元素导入矩阵，按行;  </span></span><br><span class="line">  </span><br><span class="line">        <span class="comment">//setIdentity: 缩放的单位对角矩阵;  </span></span><br><span class="line">        <span class="comment">//!&lt; measurement matrix (H) 观测模型  </span></span><br><span class="line">        setIdentity(KF.measurementMatrix);  </span><br><span class="line">        <span class="comment">//!&lt; process noise covariance matrix (Q)  </span></span><br><span class="line">        <span class="comment">// wk 是过程噪声，并假定其符合均值为零，协方差矩阵为Qk(Q)的多元正态分布;  </span></span><br><span class="line">        setIdentity(KF.processNoiseCov, Scalar::all(<span class="number">1e-5</span>));  </span><br><span class="line">        <span class="comment">//!&lt; measurement noise covariance matrix (R)  </span></span><br><span class="line">        <span class="comment">//vk 是观测噪声，其均值为零，协方差矩阵为Rk,且服从正态分布;  </span></span><br><span class="line">        setIdentity(KF.measurementNoiseCov, Scalar::all(<span class="number">1e-1</span>));  </span><br><span class="line">        <span class="comment">//!&lt; priori error estimate covariance matrix (P'(k)): P'(k)=A*P(k-1)*At + Q)*/  A代表F: transitionMatrix  </span></span><br><span class="line">        <span class="comment">//预测估计协方差矩阵;  </span></span><br><span class="line">        setIdentity(KF.errorCovPost, Scalar::all(<span class="number">1</span>));  </span><br><span class="line">        <span class="comment">//!&lt; corrected state (x(k)): x(k)=x'(k)+K(k)*(z(k)-H*x'(k))  </span></span><br><span class="line">        randn(KF.statePost, Scalar::all(<span class="number">0</span>), Scalar::all(<span class="number">0.1</span>));  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span>(;;)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="function">Point2f <span class="title">center</span><span class="params">(img.cols*<span class="number">0.5f</span>, img.rows*<span class="number">0.5f</span>)</span></span>;  </span><br><span class="line">            <span class="keyword">float</span> R = img.cols/<span class="number">3.f</span>;  </span><br><span class="line">            <span class="keyword">double</span> stateAngle = state.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>);  </span><br><span class="line">            Point statePt = calcPoint(center, R, stateAngle);  </span><br><span class="line">  </span><br><span class="line">            Mat prediction = KF.predict();  </span><br><span class="line">            <span class="keyword">double</span> predictAngle = prediction.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>);  </span><br><span class="line">            Point predictPt = calcPoint(center, R, predictAngle);  </span><br><span class="line">  </span><br><span class="line">            randn( measurement, Scalar::all(<span class="number">0</span>), Scalar::all(KF.measurementNoiseCov.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>)));  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">// generate measurement  </span></span><br><span class="line">            measurement += KF.measurementMatrix*state;  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">double</span> measAngle = measurement.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>);  </span><br><span class="line">            Point measPt = calcPoint(center, R, measAngle);  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">// plot points  </span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">define</span> drawCross( center, color, d )                                 \  </span></span><br><span class="line">                line( img, Point( center.x - d, center.y - d ),                \  </span><br><span class="line">                             Point( center.x + d, center.y + d ), color, <span class="number">1</span>, CV_AA, <span class="number">0</span>); \  </span><br><span class="line">                line( img, Point( center.x + d, center.y - d ),                \  </span><br><span class="line">                             Point( center.x - d, center.y + d ), color, <span class="number">1</span>, CV_AA, <span class="number">0</span> )  </span><br><span class="line">  </span><br><span class="line">            img = Scalar::all(<span class="number">0</span>);  </span><br><span class="line">            drawCross( statePt, Scalar(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>), <span class="number">3</span> );  </span><br><span class="line">            drawCross( measPt, Scalar(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>), <span class="number">3</span> );  </span><br><span class="line">            drawCross( predictPt, Scalar(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>), <span class="number">3</span> );  </span><br><span class="line">            <span class="comment">//line( img, statePt, measPt, Scalar(0,0,255), 3, CV_AA, 0 );  </span></span><br><span class="line">            <span class="comment">//line( img, statePt, predictPt, Scalar(0,255,255), 3, CV_AA, 0 );  </span></span><br><span class="line">  </span><br><span class="line">            KF.correct(measurement);  </span><br><span class="line">  </span><br><span class="line">            randn( processNoise, Scalar(<span class="number">0</span>), Scalar::all(<span class="built_in">sqrt</span>(KF.processNoiseCov.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>, <span class="number">0</span>))));  </span><br><span class="line">            state = KF.transitionMatrix*state + processNoise;  </span><br><span class="line">  </span><br><span class="line">            imshow( <span class="string">"Kalman"</span>, img );  </span><br><span class="line">            code = (<span class="keyword">char</span>)waitKey(<span class="number">100</span>);  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">if</span>( code &gt; <span class="number">0</span> )  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">if</span>( code == <span class="number">27</span> || code == <span class="string">'q'</span> || code == <span class="string">'Q'</span> )  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="//loopvoid.github.io/2017/03/26/Opencv实现Kalman滤波器/out1.JPG" alt="output1"></p><h1 id="鼠标跟踪（详解）"><a href="#鼠标跟踪（详解）" class="headerlink" title="鼠标跟踪（详解）"></a>鼠标跟踪（详解）</h1><h2 id="初始化状态"><a href="#初始化状态" class="headerlink" title="初始化状态"></a>初始化状态</h2><p><code>const int stateNum=4;</code>//状态数，包括（x，y，dx，dy）坐标及速度（每次移动的距离）<br><code>const int measureNum=2;</code>//观测量，能看到的是坐标值，当然也可以自己计算速度，但没必要<br>转移矩阵或者说增益矩阵的值好像有点莫名其妙</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> A[stateNum][stateNum] =&#123;<span class="comment">//transition matrix  </span></span><br><span class="line">        <span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,  </span><br><span class="line">        <span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,  </span><br><span class="line">        <span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,  </span><br><span class="line">        <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>  </span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>即是矩阵:<br>$$<br>\begin{bmatrix}<br>x’\<br>y’\<br>dx’\<br>dy’<br>\end{bmatrix}<br>=<br>\begin{bmatrix}<br>1 &amp; 0 &amp; 1 &amp; 0\<br>0 &amp; 1 &amp; 0 &amp; 1\<br>0 &amp; 0 &amp; 1 &amp; 0\<br>0 &amp; 0 &amp; 1 &amp; 1\<br>\end{bmatrix}<br>\begin{bmatrix}<br>x\<br>y\<br>dx\<br>dy<br>\end{bmatrix}<br>$$</p><p>$X_1=X+dx$，依次类推<br>所以这个矩阵还是很容易却确定的，可以根据自己的实际情况定制转移矩阵<br>同样的方法，三维坐标的转移矩阵可以如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> A[stateNum][stateNum] =&#123;<span class="comment">//transition matrix  </span></span><br><span class="line">        <span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,  </span><br><span class="line">        <span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,  </span><br><span class="line">        <span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,  </span><br><span class="line">        <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,  </span><br><span class="line">        <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,  </span><br><span class="line">        <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>  </span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p>当然并不一定得是1和0</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">KalmanFilter <span class="title">KF</span><span class="params">(stateNum, measureNum, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="comment">//KalmanFilter::KalmanFilter(intdynamParams, intmeasureParams, int controlParams=0, inttype=CV_32F)</span></span><br><span class="line">Parameters: </span><br><span class="line">    * dynamParams – Dimensionality of the state.</span><br><span class="line">    * measureParams – Dimensionality of the measurement.</span><br><span class="line">    * controlParams – Dimensionality of the control <span class="built_in">vector</span>.</span><br><span class="line">    * type – Type of the created matrices that should beCV_32F orCV_64F.</span><br><span class="line"> </span><br><span class="line"><span class="function">Mat <span class="title">state</span> <span class="params">(stateNum, <span class="number">1</span>, CV_32FC1)</span></span>;         <span class="comment">//  state(x,y,detaX,detaY)</span></span><br><span class="line"><span class="function">Mat <span class="title">processNoise</span><span class="params">(stateNum, <span class="number">1</span>, CV_32F)</span></span>; <span class="comment">//  processNoise(x,y,detaX,detaY)</span></span><br><span class="line">Mat measurement = Mat::zeros(measureNum, <span class="number">1</span>, CV_32F); <span class="comment">//measurement(x,y)</span></span><br></pre></td></tr></table></figure><p>需定义的参数矩阵：<br><code>Fk : KF.transitionMatrix</code><br><code>KF.transitionMatrix = *(Mat_&lt;float&gt;(2, 2) &lt;&lt; 1, 0, 1, 0......);</code><br><code>Hk : KF.measurementMatrix</code><br><code>setIdentity(KF.measurementMatrix);</code><br><code>Qk : KF.processNoiseCov</code><br><code>setIdentity(KF.processNoiseCov, Scalar::all(1e-5));</code><br><code>Rk  : KF.measurementNoiseCov</code><br><code>setIdentity(KF.measurementNoiseCov, Scalar::all(1e-1));</code><br><code>Pk : KF.errorCovPost</code><br><code>setIdentity(KF.errorCovPost, Scalar::all(1));</code><br>注意：其中: KF.transitionMatrix  ：<br>​                                         (1,0,1,0,<br>​                                          0,1,0,1,<br>​                                          0,0,1,0,<br>​                                          0,0,0,1 );</p><h2 id="预测predict，读出预测的位置"><a href="#预测predict，读出预测的位置" class="headerlink" title="预测predict，读出预测的位置"></a>预测predict，读出预测的位置</h2><h2 id="更新updata"><a href="#更新updata" class="headerlink" title="更新updata"></a>更新updata</h2><h3 id="更新观测矩阵：updata-generate-measurement"><a href="#更新观测矩阵：updata-generate-measurement" class="headerlink" title="更新观测矩阵：updata/generate measurement"></a>更新观测矩阵：updata/generate measurement</h3><ul><li>对于鼠标跟踪：直接使用鼠标的实际位置更新，真实位置即为观测位置</li><li>对于自动更新：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">randn( measurement, Scalar::all(<span class="number">0</span>), Scalar::all(KF.measurementNoiseCov.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>)));  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// generate measurement  </span></span><br><span class="line">measurement += KF.measurementMatrix*state;</span><br></pre></td></tr></table></figure></li></ul><h3 id="更新KF：KF-correct-measurement"><a href="#更新KF：KF-correct-measurement" class="headerlink" title="更新KF：KF.correct(measurement);"></a>更新KF：KF.correct(measurement);</h3><p>分别显示前一状态的位置：Point statePt = Point( (int)KF.statePost.at<float>(0), (int)KF.statePost.at<float>(1));;<br>预测位置：Point predictPt = Point( (int)prediction.at<float>(0), (int)prediction.at<float>(1));<br>观测位置(真实位置)：mousePosition（由setMouseCallback(“Kalman”, mouseEvent);得到，递归方式通过measurement计算得到）</float></float></float></float></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv/cv.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv/highgui.h&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;  </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> winWidth = <span class="number">800</span>;  </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> winHeight = <span class="number">600</span>;  </span><br><span class="line">  </span><br><span class="line">Point mousePosition = Point(winWidth&gt;&gt;<span class="number">1</span>, winHeight&gt;&gt;<span class="number">1</span>);  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//mouse call back  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mouseEvent</span><span class="params">(<span class="keyword">int</span> event, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> flags, <span class="keyword">void</span> *param)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(event==CV_EVENT_MOUSEMOVE)  </span><br><span class="line">    &#123;  </span><br><span class="line">        mousePosition=Point(x,y);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="comment">//1.kalman filter setup     </span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> stateNum=<span class="number">4</span>;    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> measureNum=<span class="number">2</span>;    </span><br><span class="line">  </span><br><span class="line">    <span class="function">KalmanFilter <span class="title">KF</span><span class="params">(stateNum, measureNum, <span class="number">0</span>)</span></span>;  </span><br><span class="line">    <span class="function">Mat <span class="title">state</span> <span class="params">(stateNum, <span class="number">1</span>, CV_32FC1)</span></span>; <span class="comment">//state(x,y,detaX,detaY)  </span></span><br><span class="line">    <span class="function">Mat <span class="title">processNoise</span><span class="params">(stateNum, <span class="number">1</span>, CV_32F)</span></span>;  </span><br><span class="line">    Mat measurement = Mat::zeros(measureNum, <span class="number">1</span>, CV_32F);    <span class="comment">//measurement(x,y)  </span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">        randn( state, Scalar::all(<span class="number">0</span>), Scalar::all(<span class="number">0.1</span>) ); <span class="comment">//随机生成一个矩阵，期望是0，标准差为0.1;  </span></span><br><span class="line">        KF.transitionMatrix = *(Mat_&lt;<span class="keyword">float</span>&gt;(<span class="number">4</span>, <span class="number">4</span>) &lt;&lt;   </span><br><span class="line">            <span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,   </span><br><span class="line">            <span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,   </span><br><span class="line">            <span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,   </span><br><span class="line">            <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span> );<span class="comment">//元素导入矩阵，按行;  </span></span><br><span class="line">  </span><br><span class="line">        <span class="comment">//setIdentity: 缩放的单位对角矩阵;  </span></span><br><span class="line">        <span class="comment">//!&lt; measurement matrix (H) 观测模型  </span></span><br><span class="line">        setIdentity(KF.measurementMatrix);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//!&lt; process noise covariance matrix (Q)  </span></span><br><span class="line">        <span class="comment">// wk 是过程噪声，并假定其符合均值为零，协方差矩阵为Qk(Q)的多元正态分布;  </span></span><br><span class="line">        setIdentity(KF.processNoiseCov, Scalar::all(<span class="number">1e-5</span>));  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">//!&lt; measurement noise covariance matrix (R)  </span></span><br><span class="line">        <span class="comment">//vk 是观测噪声，其均值为零，协方差矩阵为Rk,且服从正态分布;  </span></span><br><span class="line">        setIdentity(KF.measurementNoiseCov, Scalar::all(<span class="number">1e-1</span>));  </span><br><span class="line">          </span><br><span class="line">        <span class="comment">//!&lt; priori error estimate covariance matrix (P'(k)): P'(k)=A*P(k-1)*At + Q)*/  A代表F: transitionMatrix  </span></span><br><span class="line">        <span class="comment">//预测估计协方差矩阵;  </span></span><br><span class="line">        setIdentity(KF.errorCovPost, Scalar::all(<span class="number">1</span>));  </span><br><span class="line">          </span><br><span class="line">  </span><br><span class="line">        <span class="comment">//!&lt; corrected state (x(k)): x(k)=x'(k)+K(k)*(z(k)-H*x'(k))  </span></span><br><span class="line">        <span class="comment">//initialize post state of kalman filter at random   </span></span><br><span class="line">        randn(KF.statePost, Scalar::all(<span class="number">0</span>), Scalar::all(<span class="number">0.1</span>));  </span><br><span class="line">        <span class="function">Mat <span class="title">showImg</span><span class="params">(winWidth, winHeight,CV_8UC3)</span></span>;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span>(;;)  </span><br><span class="line">        &#123;  </span><br><span class="line">            setMouseCallback(<span class="string">"Kalman"</span>, mouseEvent);  </span><br><span class="line">            showImg.setTo(<span class="number">0</span>);  </span><br><span class="line">  </span><br><span class="line">            Point statePt = Point( (<span class="keyword">int</span>)KF.statePost.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>), (<span class="keyword">int</span>)KF.statePost.at&lt;<span class="keyword">float</span>&gt;(<span class="number">1</span>));  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">//2.kalman prediction     </span></span><br><span class="line">            Mat prediction = KF.predict();  </span><br><span class="line">            Point predictPt = Point( (<span class="keyword">int</span>)prediction.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>), (<span class="keyword">int</span>)prediction.at&lt;<span class="keyword">float</span>&gt;(<span class="number">1</span>));  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">//3.update measurement  </span></span><br><span class="line">            measurement.at&lt;<span class="keyword">float</span>&gt;(<span class="number">0</span>)= (<span class="keyword">float</span>)mousePosition.x;  </span><br><span class="line">            measurement.at&lt;<span class="keyword">float</span>&gt;(<span class="number">1</span>) = (<span class="keyword">float</span>)mousePosition.y;  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">//4.update  </span></span><br><span class="line">            KF.correct(measurement);  </span><br><span class="line">  </span><br><span class="line">            <span class="comment">//randn( processNoise, Scalar(0), Scalar::all(sqrt(KF.processNoiseCov.at&lt;float&gt;(0, 0))));  </span></span><br><span class="line">            <span class="comment">//state = KF.transitionMatrix*state + processNoise;  </span></span><br><span class="line">            <span class="comment">//draw  </span></span><br><span class="line">            circle(showImg, statePt, <span class="number">5</span>, CV_RGB(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>),<span class="number">1</span>);<span class="comment">//former point  </span></span><br><span class="line">            circle(showImg, predictPt, <span class="number">5</span>, CV_RGB(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">1</span>);<span class="comment">//predict point  </span></span><br><span class="line">            circle(showImg, mousePosition, <span class="number">5</span>, CV_RGB(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),<span class="number">1</span>);<span class="comment">//ture point  </span></span><br><span class="line">              </span><br><span class="line">  </span><br><span class="line"><span class="comment">//          CvFont font;//字体  </span></span><br><span class="line"><span class="comment">//          cvInitFont(&amp;font, CV_FONT_HERSHEY_SCRIPT_COMPLEX, 0.5f, 0.5f, 0, 1, 8);  </span></span><br><span class="line">            putText(showImg, <span class="string">"Red: Former Point"</span>, cvPoint(<span class="number">10</span>,<span class="number">30</span>), FONT_HERSHEY_SIMPLEX, <span class="number">1</span> ,Scalar :: all(<span class="number">255</span>));  </span><br><span class="line">            putText(showImg, <span class="string">"Green: Predict Point"</span>, cvPoint(<span class="number">10</span>,<span class="number">60</span>), FONT_HERSHEY_SIMPLEX, <span class="number">1</span> ,Scalar :: all(<span class="number">255</span>));  </span><br><span class="line">            putText(showImg, <span class="string">"Blue: Ture Point"</span>, cvPoint(<span class="number">10</span>,<span class="number">90</span>), FONT_HERSHEY_SIMPLEX, <span class="number">1</span> ,Scalar :: all(<span class="number">255</span>));  </span><br><span class="line">  </span><br><span class="line">            imshow( <span class="string">"Kalman"</span>, showImg );  </span><br><span class="line">            <span class="keyword">int</span> key = waitKey(<span class="number">3</span>);  </span><br><span class="line">            <span class="keyword">if</span> (key == <span class="number">27</span>)  </span><br><span class="line">            &#123;  </span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="//loopvoid.github.io/2017/03/26/Opencv实现Kalman滤波器/out2.JPG" alt="output2"></p><h1 id="主要参考"><a href="#主要参考" class="headerlink" title="主要参考"></a>主要参考</h1><p>1.<a href="http://en.wikipedia.org/wiki/Kalman_filter" target="_blank" rel="noopener">维基百科（英文）</a><a href="http://zh.wikipedia.org/wiki/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2#.E5.8D.A1.E5.B0.94.E6.9B.BC.E6.BB.A4.E6.B3.A2.E5.99.A8" target="_blank" rel="noopener">维基百科（中文）</a><br>2.<a href="http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html?highlight=kalman#kalmanfilter" target="_blank" rel="noopener">OpenCV文档</a><br>3.<a href="http://www.cnblogs.com/feisky/archive/2009/12/04/1617287.html" target="_blank" rel="noopener">博客园kalman详解blog</a><br>4.<a href="http://blog.csdn.net/yang_xian521/article/details/7050398" target="_blank" rel="noopener">CSDN kalman.cpp讲解yangxian</a><br>5.<a href="http://blog.csdn.net/onezeros/article/details/6318944" target="_blank" rel="noopener">CSDN 鼠标跟踪</a><br>6.<a href="http://www.cs.unc.edu/~welch/media/pdf/kalman_intro.pdf" target="_blank" rel="noopener">模型论文</a><br>7.<a href="http://blog.csdn.net/yangtrees/article/details/8075911" target="_blank" rel="noopener">Kalman-Opencv</a><br>8.<a href="http://robotsforroboticists.com/kalman-filtering/" target="_blank" rel="noopener">公式彩色着色，含pyhton源码</a><br>9.<a href="http://alumni.media.mit.edu/~wad/mas864/psrc/kalman.c.txt" target="_blank" rel="noopener">Kalman滤波的C代码</a><br>10.<a href="http://www.cs.unc.edu/~welch/kalman/" target="_blank" rel="noopener">比较全的Kalman链接</a><br>11.<a href="http://blog.sina.com.cn/s/blog_7445c2940102whjq.html" target="_blank" rel="noopener">卡尔曼滤波器（Kalman Filtering）入门</a><br>12.<a href="http://blog.csdn.net/xiahouzuoxin/article/details/39582483" target="_blank" rel="noopener">Kalman滤波器从原理到实现</a><br>13.<a href="http://bbs.21ic.com/icview-292853-1-1.html" target="_blank" rel="noopener">授之以渔： 卡尔曼滤波器 ….大泻蜜</a><br>14.<a href="http://blog.csdn.net/heyijia0327/article/details/17487467" target="_blank" rel="noopener">卡尔曼滤波 – 从推导到应用(一)</a><br>15.<a href="http://blog.csdn.net/heyijia0327/article/details/17667341" target="_blank" rel="noopener">卡尔曼滤波 – 从推导到应用(二)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;卡尔曼滤波是一种高效率的&lt;strong&gt;递归滤波器(自回归滤波器)&lt;/strong&gt;, 它能够从一系列的不完全及包含噪声的测量中，估计动态系
      
    
    </summary>
    
      <category term="Opencv" scheme="https://loopvoid.github.io/categories/Opencv/"/>
    
    
      <category term="Opencv" scheme="https://loopvoid.github.io/tags/Opencv/"/>
    
      <category term="Kalman" scheme="https://loopvoid.github.io/tags/Kalman/"/>
    
  </entry>
  
</feed>
